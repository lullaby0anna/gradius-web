<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gradius Web - Stage 1</title>
  <style>
    html,body{margin:0;height:100%;background:#05060a;color:#e7ecff;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #wrap{display:flex;align-items:center;justify-content:center;height:100%}
    canvas{background:linear-gradient(#04050a,#02030a);border:1px solid rgba(255,255,255,.12);box-shadow:0 10px 30px rgba(0,0,0,.55)}
    #hud{position:fixed;left:12px;top:10px;display:flex;gap:14px;align-items:center;font-size:14px;z-index:3}
    #hud .pill{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);padding:6px 10px;border-radius:999px}
    #hud .pill b{color:#fff}
    #hud .warn{color:#ffd08a}
    #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.55);backdrop-filter:blur(4px);z-index:5}
    #overlay.hidden{display:none}
    #panel{width:min(640px,92vw);background:rgba(10,12,24,.92);border:1px solid rgba(255,255,255,.14);border-radius:18px;box-shadow:0 20px 60px rgba(0,0,0,.6);padding:22px 22px 18px}
    #panel h1{margin:0 0 10px;font-size:26px;letter-spacing:.04em}
    #panel p{margin:8px 0 14px;line-height:1.6;color:rgba(231,236,255,.88)}
    #panel .row{display:flex;gap:10px;flex-wrap:wrap}
    button{cursor:pointer;border:none;border-radius:12px;padding:10px 14px;font-weight:700;background:#2c7dff;color:#fff}
    button:hover{filter:brightness(1.04)}
    button.secondary{background:rgba(255,255,255,.10);color:#e7ecff;border:1px solid rgba(255,255,255,.14)}
    .kbd{display:inline-flex;align-items:center;justify-content:center;min-width:20px;height:20px;padding:0 6px;border-radius:6px;background:rgba(255,255,255,.1);border:1px solid rgba(255,255,255,.16);font-weight:700;font-size:12px}
    #how{position:fixed;right:12px;top:10px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:10px 12px;z-index:3;max-width:360px}
    #how h3{margin:0 0 8px;font-size:13px;opacity:.95}
    #how ul{margin:0;padding-left:18px;font-size:12px;line-height:1.5;color:rgba(231,236,255,.82)}
    #how .tiny{font-size:11px;opacity:.72;margin-top:8px}
    #loading{position:fixed;left:0;right:0;bottom:0;height:3px;background:rgba(255,255,255,.08);z-index:6}
    #loading>div{height:100%;width:0;background:#2c7dff;transition:width .3s ease}
  </style>
</head>
<body>
  <div id="hud">
    <div class="pill">Score: <b id="score">0</b></div>
    <div class="pill">Lives: <b id="lives">3</b></div>
    <div class="pill">Power: <b id="pow">0</b></div>
    <div class="pill warn" id="msg"></div>
  </div>

  <div id="how">
    <h3>操作</h3>
    <ul>
      <li>移動：<span class="kbd">W</span><span class="kbd">A</span><span class="kbd">S</span><span class="kbd">D</span> / 方向キー</li>
      <li>ショット：<span class="kbd">Z</span>　ミサイル：<span class="kbd">X</span></li>
      <li>パワーアップ選択/発動：<span class="kbd">C</span></li>
      <li>ポーズ：<span class="kbd">P</span>　リスタート：<span class="kbd">R</span></li>
    </ul>
    <div class="tiny">※ 音が鳴らない場合はブラウザの自動再生設定を確認。</div>
  </div>

  <div id="wrap">
    <canvas id="cv" width="960" height="540"></canvas>
  </div>

  <div id="overlay">
    <div id="panel">
      <h1>開始</h1>
      <p>
        <b>Gradius Web - Stage 1</b><br/>
        <span class="kbd">Start</span> を押すと開始します。
      </p>
      <div class="row">
        <button id="btnStart">Start</button>
        <button class="secondary" id="btnMute">Mute</button>
      </div>
    </div>
  </div>

  <div id="loading" class="hidden"><div></div></div>

<script>
(() => {
  const cv = document.getElementById("cv");
  const ctx = cv.getContext("2d");

  const elScore = document.getElementById("score");
  const elLives = document.getElementById("lives");
  const elPow = document.getElementById("pow");
  const elMsg = document.getElementById("msg");

  const elOverlay = document.getElementById("overlay");
  const elPanel = document.getElementById("panel");
  const elStart = document.getElementById("btnStart");
  const elMute  = document.getElementById("btnMute");

  const W = cv.width, H = cv.height;

  // -----------------------------
  // Global leaderboard (Top3) via Cloudflare Workers + D1
  // -----------------------------
  const LEADERBOARD_API = "https://gradius-top3.lullaby0anna.workers.dev";

  function escHtml(s){
    return String(s).replace(/[&<>"\']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  async function apiGetTop3() {
    if (!LEADERBOARD_API) return null;
    const r = await fetch(LEADERBOARD_API.replace(/\/$/,"") + "/top?limit=3", { method:"GET" });
    if (!r.ok) throw new Error("top fetch failed: " + r.status);
    return await r.json();
  }

  async function apiPostScore(name, score) {
    if (!LEADERBOARD_API) return null;
    const r = await fetch(LEADERBOARD_API.replace(/\/$/,"") + "/score", {
      method: "POST",
      headers: { "content-type":"application/json" },
      body: JSON.stringify({ name, score })
    });
    if (!r.ok) throw new Error("score post failed: " + r.status);
    return await r.json();
  }

  function top3Html(arr){
    if (!Array.isArray(arr) || arr.length === 0) {
      return `<div style="margin-top:10px; color:rgba(231,236,255,.75)">TOP3：記録なし</div>`;
    }
    const rows = arr.map((x,i) => {
      const n = escHtml(x.name ?? "NONAME");
      const s = Number(x.score ?? 0);
      return `<div>${i+1}位：<b>${n}</b>　<span style="opacity:.85">${s}</span></div>`;
    }).join("");
    return `<div style="margin-top:10px; text-align:left; display:inline-block">
      <div style="margin-bottom:6px; opacity:.9"><b>TOP 3</b></div>
      ${rows}
    </div>`;
  }

  function qualifiesTop3(score, arr){
    if (!Array.isArray(arr)) return true;
    if (arr.length < 3) return true;
    const last = Number(arr[arr.length - 1]?.score ?? -1);
    return score > last;
  }
  // -----------------------------
  // /Global leaderboard
  // -----------------------------

  // =============================
  // Audio
  // =============================
  const audio = {
    mute:false,
    bgm: new Audio("geme.mp3"),
    boss: new Audio("boss.mp3"),
    boss2: new Audio("boss2.mp3"),
  };
  audio.bgm.loop = true;
  audio.boss.loop = true;
  audio.boss2.loop = true;

  function setMute(v){
    audio.mute = v;
    for (const k of Object.keys(audio)){
      if (audio[k] instanceof Audio) audio[k].muted = v;
    }
    elMute.textContent = v ? "Unmute" : "Mute";
  }
  function stopAllBGM(){
    for (const k of ["bgm","boss","boss2"]){
      const a = audio[k];
      try{ a.pause(); a.currentTime = 0; }catch{}
    }
  }
  async function playBGM(which){
    if (audio.mute) return;
    try{
      stopAllBGM();
      const a = audio[which];
      if (!a) return;
      a.volume = 0.75;
      await a.play();
    }catch(e){
      // ignore autoplay restriction; user click will allow later
    }
  }

  // =============================
  // Input
  // =============================
  const keys = new Set();
  window.addEventListener("keydown",(e)=>{
    if(["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," ","z","x","c","p","r","w","a","s","d","Z","X","C","P","R","W","A","S","D"].includes(e.key)) e.preventDefault();
    keys.add(e.key.toLowerCase());
    if(e.key.toLowerCase()==="p") togglePause();
    if(e.key.toLowerCase()==="r" && !started) resetGame();
    if(e.key.toLowerCase()==="c") triggerPower();
  }, {passive:false});
  window.addEventListener("keyup",(e)=> keys.delete(e.key.toLowerCase()));

  // =============================
  // Game state
  // =============================
  let started=false;
  let paused=false;

  let score=0;
  let lives=3;
  let power=0;

  // player
  const player = {
    x: 90, y: H/2,
    w: 36, h: 18,
    spd: 260,
    inv: 0,
    fireCd: 0,
    misCd: 0,
    orb: 0,
    laser: false,
    opt: 0,
  };

  // arrays
  let shots=[], missiles=[], enemies=[], items=[], fx=[], stars=[], boss=null;

  // stage
  let t=0;
  let scroll=0;
  let bossPhase=0;
  let stageClear=false;

  // starfield
  for(let i=0;i<140;i++){
    stars.push({x:Math.random()*W, y:Math.random()*H, s: 20+Math.random()*140, r: Math.random()*2});
  }

  function msg(s, hold=120){
    elMsg.textContent = s;
    elMsg._ttl = hold;
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  // =============================
  // FX helpers
  // =============================
  function explosion(x,y,scale=1){
    for(let i=0;i<18*scale;i++){
      const a = Math.random()*Math.PI*2;
      const sp = (70+Math.random()*220)*scale;
      fx.push({type:"p", x, y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: 0.65+Math.random()*0.4, r: 2+Math.random()*3*scale, g: 200+Math.random()*55});
    }
  }

  // big flashy explosion for bosses
  function megaExplosionFX(x,y,scale=1){
    // rings
    for(let k=0;k<3;k++){
      fx.push({type:"ring", x, y, life:0.55+0.12*k, r: 10*scale, grow:(320+140*k)*scale});
    }
    // sparks
    for(let i=0;i<90*scale;i++){
      const a = Math.random()*Math.PI*2;
      const sp = (120+Math.random()*520)*scale;
      fx.push({type:"p", x, y, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: 0.9+Math.random()*0.7, r: 2+Math.random()*4*scale, g: 180+Math.random()*75});
    }
    // core flash
    fx.push({type:"flash", x, y, life:0.25, r: 16*scale});
  }

  // =============================
  // Entities
  // =============================
  function spawnEnemyBasic(x,y,kind="a"){
    const e = {x,y,kind, hp: kind==="b"?4:2, w:28, h:18, vx:-110-(Math.random()*60), vy:(Math.random()*70-35), cd: 0.6+Math.random()*0.6};
    enemies.push(e);
  }

  function spawnItem(x,y){
    items.push({x,y,w:18,h:18,vx:-120,rot:0});
  }

  function rectHit(a,b){
    return a.x < b.x+b.w && a.x+a.w > b.x && a.y < b.y+b.h && a.y+a.h > b.y;
  }

  function fireShot(px,py,dx=1){
    shots.push({x:px, y:py, w:10,h:3, vx:520*dx, vy:0, dmg: player.laser?2:1, life: 1.4});
  }

  function fireMissile(px,py){
    missiles.push({x:px, y:py, w:9,h:5, vx:340, vy:140, life: 2.1});
  }

  function triggerPower(){
    if(!started||paused) return;
    if(power<=0) return;
    // simple: power gives option or laser alternately
    if(player.opt<2){
      player.opt++;
      msg("OPTION +1", 100);
    }else if(!player.laser){
      player.laser=true;
      msg("LASER", 100);
    }else{
      // extra score
      score += 500;
      msg("BONUS +500", 100);
    }
    power--;
    elPow.textContent = power;
  }

  // =============================
  // Bosses
  // =============================
  function spawnMidBoss(){
    boss = {
      type:"mid",
      x: W+180, y: H/2-60,
      w: 160, h: 120,
      hp: 220,
      t:0,
      phase:0,
      vx:-60,
      cd:0,
    };
    bossPhase=1;
    playBGM("boss");
  }

  function spawnLastBoss(){
    boss = {
      type:"last",
      x: W+220, y: H/2-110,
      w: 220, h: 180,
      hp: 420,
      t:0,
      phase:0,
      vx:-50,
      cd:0,
      core: {x:0,y:0,w:52,h:52, hp: 140}
    };
    bossPhase=2;
    playBGM("boss2");
  }

  function bossHit(dmg){
    if(!boss) return;
    boss.hp -= dmg;
    if(boss.hp<=0){
      // huge explosion
      megaExplosionFX(boss.x+boss.w/2, boss.y+boss.h/2, boss.type==="last"?2.2:1.7);
      // extra blast chain
      for(let i=0;i<6;i++){
        setTimeout(()=>{
          megaExplosionFX(boss.x+Math.random()*boss.w, boss.y+Math.random()*boss.h, boss.type==="last"?1.2:0.9);
        }, i*90);
      }
      score += boss.type==="last" ? 20000 : 10000;
      boss=null;
      stopAllBGM();
      playBGM("bgm");
      if(bossPhase===1){
        msg("MID BOSS DOWN!", 180);
        stageClear=true; // for demo, clear after mid boss
        gameWin();
      }else{
        msg("LAST BOSS DOWN!", 240);
        stageClear=true;
        gameWin();
      }
    }
  }

  // =============================
  // Game flow
  // =============================
  function resetGame(){
    stopAllBGM();
    started=true;
    paused=false;

    score=0;
    lives=3;
    power=0;

    player.x=90; player.y=H/2;
    player.inv=0; player.fireCd=0; player.misCd=0;
    player.opt=0; player.laser=false;

    shots=[]; missiles=[]; enemies=[]; items=[]; fx=[];
    boss=null; bossPhase=0;
    t=0; scroll=0; stageClear=false;

    elScore.textContent=score;
    elLives.textContent=lives;
    elPow.textContent=power;
    elMsg.textContent="";
    elOverlay.classList.add("hidden");

    playBGM("bgm");
  }

  function gameOver(){
    stopAllBGM();
    started=false;
    paused=false;
    elOverlay.classList.remove("hidden");
    elPanel.querySelector("h1").textContent = "ゲームオーバー";
    elPanel.querySelector("p").innerHTML =
      `Score: <b>${score}</b><br/> <span class="kbd">R</span> でリスタート。`;
    elStart.textContent = "リスタート";
    elStart.style.display = "inline-block";
  }

  function gameWin(){
    stopAllBGM();
    started=false;
    paused=false;

    elOverlay.classList.remove("hidden");
    elPanel.querySelector("h1").textContent = "ステージクリア";

    const baseMsg =
      `Score: <b>${score}</b><br/>ステージ1クリア。<span class="kbd">R</span>でリスタート。`;

    // show loading message
    elPanel.querySelector("p").innerHTML = baseMsg + `<div style="margin-top:10px; color:rgba(231,236,255,.75)">TOP3：読み込み中…</div>`;

    (async () => {
      try {
        const top = await apiGetTop3();
        if (qualifiesTop3(score, top)) {
          let name = prompt("TOP3入り！名前を入力（10文字まで）", "PLAYER");
          if (name === null) name = "PLAYER";
          name = (name || "NONAME").trim().slice(0, 10);
          await apiPostScore(name, Math.floor(score));
        }
        const top2 = await apiGetTop3();
        elPanel.querySelector("p").innerHTML = baseMsg + top3Html(top2);
      } catch (e) {
        console.error(e);
        elPanel.querySelector("p").innerHTML = baseMsg + `<div style="margin-top:10px; color:rgba(231,236,255,.75)">TOP3：取得失敗（Console確認）</div>`;
      }
    })();

    elStart.textContent = "リスタート";
    elStart.style.display = "inline-block";
  }

  function togglePause(){
    if(!started) return;
    paused=!paused;
    msg(paused?"PAUSE":"", 80);
  }

  // =============================
  // Main update
  // =============================
  let last=performance.now();
  function step(now){
    const dt = Math.min(0.033, (now-last)/1000);
    last=now;

    // update stars
    for(const s of stars){
      s.x -= s.s*dt;
      if(s.x<0){ s.x = W+Math.random()*120; s.y=Math.random()*H; s.s=20+Math.random()*140; s.r=Math.random()*2;}
    }

    if(elMsg._ttl){
      elMsg._ttl -= 60*dt;
      if(elMsg._ttl<=0){ elMsg.textContent=""; elMsg._ttl=0; }
    }

    if(started && !paused){
      t += dt;
      scroll += 180*dt;

      // spawn enemies
      if(t<14){
        if(Math.random()<0.08){
          spawnEnemyBasic(W+40, 60+Math.random()*(H-120), Math.random()<0.2?"b":"a");
        }
      }

      // mid boss spawn at 14s
      if(!boss && bossPhase===0 && t>14){
        spawnMidBoss();
      }

      // player move
      let mx=0,my=0;
      if(keys.has("arrowup")||keys.has("w")) my-=1;
      if(keys.has("arrowdown")||keys.has("s")) my+=1;
      if(keys.has("arrowleft")||keys.has("a")) mx-=1;
      if(keys.has("arrowright")||keys.has("d")) mx+=1;
      const len = Math.hypot(mx,my)||1;
      mx/=len; my/=len;

      player.x = clamp(player.x + mx*player.spd*dt, 10, W-50);
      player.y = clamp(player.y + my*player.spd*dt, 20, H-30);

      if(player.inv>0) player.inv -= dt;

      // fire
      player.fireCd -= dt;
      player.misCd -= dt;

      const wantShot = keys.has("z");
      const wantMis  = keys.has("x");

      if(wantShot && player.fireCd<=0){
        player.fireCd = player.laser ? 0.12 : 0.16;
        fireShot(player.x+player.w, player.y+player.h/2-2);

        // options
        if(player.opt>=1) fireShot(player.x+player.w-10, player.y+player.h/2-16);
        if(player.opt>=2) fireShot(player.x+player.w-10, player.y+player.h/2+12);
      }

      if(wantMis && player.misCd<=0){
        player.misCd = 0.38;
        fireMissile(player.x+player.w-4, player.y+player.h-2);
      }

      // update shots
      for(const s of shots){
        s.x += s.vx*dt;
        s.y += s.vy*dt;
        s.life -= dt;
      }
      shots = shots.filter(s=>s.life>0 && s.x<W+50);

      // missiles
      for(const m of missiles){
        m.x += m.vx*dt;
        m.y += m.vy*dt;
        m.vy -= 280*dt;
        m.life -= dt;
      }
      missiles = missiles.filter(m=>m.life>0 && m.x<W+50 && m.y>-20 && m.y<H+20);

      // enemies
      for(const e of enemies){
        e.x += e.vx*dt;
        e.y += e.vy*dt;
        e.cd -= dt;
        if(e.cd<=0){
          e.cd = 0.9+Math.random()*0.8;
          // enemy bullet as fx particle (simple)
          fx.push({type:"b", x:e.x, y:e.y+e.h/2, vx:-280-(Math.random()*80), vy:(Math.random()*80-40), life: 2.2, r:3});
        }
      }
      enemies = enemies.filter(e=>e.x>-80 && e.y>-80 && e.y<H+80 && e.hp>0);

      // items
      for(const it of items){
        it.x += it.vx*dt;
        it.rot += 3*dt;
      }
      items = items.filter(it=>it.x>-40);

      // boss
      if(boss){
        boss.t += dt;
        // move in
        if(boss.x > W- boss.w - 50){
          boss.x += boss.vx*dt;
        }else{
          boss.y = H/2 - boss.h/2 + Math.sin(boss.t*1.3)*40;
          boss.cd -= dt;
          if(boss.cd<=0){
            boss.cd = boss.type==="last" ? 0.22 : 0.30;
            // boss bullets
            const cx = boss.x;
            const cy = boss.y + boss.h/2;
            for(let k=0;k<(boss.type==="last"?6:4);k++){
              const a = (k/(boss.type==="last"?6:4))*Math.PI*2;
              const sp = boss.type==="last"? 260:220;
              fx.push({type:"b", x:cx+boss.w/2, y:cy, vx:Math.cos(a)*sp, vy:Math.sin(a)*sp, life: 3.0, r:4});
            }
          }
        }
      }

      // update bullets (fx type b) and particles
      for(const f of fx){
        f.life -= dt;
        if(f.type==="p"||f.type==="b"){
          f.x += f.vx*dt;
          f.y += f.vy*dt;
          if(f.type==="p"){
            f.vx *= (1-1.6*dt);
            f.vy *= (1-1.6*dt);
          }
        }else if(f.type==="ring"){
          f.r += f.grow*dt;
        }else if(f.type==="flash"){
          f.r += 700*dt;
        }
      }
      fx = fx.filter(f=>f.life>0);

      // collisions: shots vs enemies/boss
      for(const s of shots){
        // enemies
        for(const e of enemies){
          if(rectHit({x:s.x,y:s.y,w:s.w,h:s.h},{x:e.x,y:e.y,w:e.w,h:e.h})){
            e.hp -= s.dmg;
            s.life = 0;
            explosion(s.x,s.y,1);
            if(e.hp<=0){
              score += (e.kind==="b"?300:180);
              if(Math.random()<0.18) spawnItem(e.x,e.y);
              explosion(e.x+e.w/2,e.y+e.h/2,1.2);
            }
            break;
          }
        }
        // boss
        if(boss && rectHit({x:s.x,y:s.y,w:s.w,h:s.h},{x:boss.x,y:boss.y,w:boss.w,h:boss.h})){
          s.life=0;
          explosion(s.x,s.y,1.2);
          bossHit(s.dmg);
        }
      }

      // missiles vs enemies/boss
      for(const m of missiles){
        for(const e of enemies){
          if(rectHit({x:m.x,y:m.y,w:m.w,h:m.h},{x:e.x,y:e.y,w:e.w,h:e.h})){
            e.hp -= 2;
            m.life = 0;
            explosion(m.x,m.y,1.3);
            if(e.hp<=0){
              score += (e.kind==="b"?300:180);
              if(Math.random()<0.18) spawnItem(e.x,e.y);
              explosion(e.x+e.w/2,e.y+e.h/2,1.2);
            }
            break;
          }
        }
        if(boss && rectHit({x:m.x,y:m.y,w:m.w,h:m.h},{x:boss.x,y:boss.y,w:boss.w,h:boss.h})){
          m.life=0;
          megaExplosionFX(m.x,m.y,0.7);
          bossHit(2);
        }
      }

      // player hit by boss bullets
      if(player.inv<=0){
        for(const f of fx){
          if(f.type!=="b") continue;
          const hb = {x:f.x-3,y:f.y-3,w:6,h:6};
          if(rectHit({x:player.x,y:player.y,w:player.w,h:player.h}, hb)){
            // hit
            lives--;
            player.inv = 1.8;
            megaExplosionFX(player.x+player.w/2, player.y+player.h/2, 1.1);
            msg("HIT!", 90);
            if(lives<=0){
              elLives.textContent = lives;
              gameOver();
            }
            break;
          }
        }
      }

      // player pickups
      for(const it of items){
        if(rectHit({x:player.x,y:player.y,w:player.w,h:player.h}, it)){
          it.x = -9999;
          power++;
          score += 100;
          msg("POWER UP", 90);
        }
      }
      items = items.filter(it=>it.x>-200);

      elScore.textContent = score;
      elLives.textContent = lives;
      elPow.textContent = power;
    }

    draw();
    requestAnimationFrame(step);
  }

  // =============================
  // Draw
  // =============================
  function draw(){
    ctx.clearRect(0,0,W,H);

    // stars
    ctx.fillStyle="rgba(255,255,255,.8)";
    for(const s of stars){
      ctx.globalAlpha = 0.16 + (s.s/160)*0.5;
      ctx.fillRect(s.x, s.y, 1+s.r, 1+s.r);
    }
    ctx.globalAlpha=1;

    // terrain vibe
    ctx.fillStyle="rgba(120,140,255,.06)";
    for(let i=0;i<8;i++){
      const x = ( (i*200) - (scroll%200) );
      ctx.fillRect(x, H-40, 140, 40);
    }

    // enemies
    for(const e of enemies){
      ctx.fillStyle = e.kind==="b" ? "rgba(255,120,120,.9)" : "rgba(180,200,255,.9)";
      ctx.fillRect(e.x,e.y,e.w,e.h);
      ctx.fillStyle="rgba(0,0,0,.35)";
      ctx.fillRect(e.x+4,e.y+4,e.w-8,e.h-8);
    }

    // items
    for(const it of items){
      ctx.save();
      ctx.translate(it.x+it.w/2, it.y+it.h/2);
      ctx.rotate(it.rot);
      ctx.strokeStyle="rgba(255,255,255,.8)";
      ctx.lineWidth=2;
      ctx.strokeRect(-it.w/2,-it.h/2,it.w,it.h);
      ctx.restore();
    }

    // boss
    if(boss){
      // body
      ctx.fillStyle = boss.type==="last" ? "rgba(255,160,70,.95)" : "rgba(220,120,255,.92)";
      ctx.fillRect(boss.x,boss.y,boss.w,boss.h);
      // details
      ctx.fillStyle="rgba(0,0,0,.35)";
      ctx.fillRect(boss.x+10,boss.y+10,boss.w-20,boss.h-20);

      // HP bar
      const maxHP = boss.type==="last"?420:220;
      const hpw = clamp((boss.hp/maxHP),0,1)*(boss.w);
      ctx.fillStyle="rgba(255,255,255,.18)";
      ctx.fillRect(boss.x, boss.y-12, boss.w, 6);
      ctx.fillStyle="rgba(255,255,255,.85)";
      ctx.fillRect(boss.x, boss.y-12, hpw, 6);
    }

    // shots
    ctx.fillStyle="rgba(120,255,190,.95)";
    for(const s of shots){
      ctx.fillRect(s.x,s.y,s.w,s.h);
      if(player.laser){
        ctx.fillStyle="rgba(90,240,255,.5)";
        ctx.fillRect(s.x-2, s.y-2, s.w+4, s.h+4);
        ctx.fillStyle="rgba(120,255,190,.95)";
      }
    }

    // missiles
    ctx.fillStyle="rgba(255,220,120,.95)";
    for(const m of missiles){
      ctx.fillRect(m.x,m.y,m.w,m.h);
    }

    // fx
    for(const f of fx){
      if(f.type==="p"){
        ctx.globalAlpha = clamp(f.life,0,1);
        ctx.fillStyle = `rgba(255,${f.g|0},90,.9)`;
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
        ctx.fill();
      }else if(f.type==="b"){
        ctx.globalAlpha = clamp(f.life/2,0,1);
        ctx.fillStyle = "rgba(255,90,90,.95)";
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
        ctx.fill();
      }else if(f.type==="ring"){
        ctx.globalAlpha = clamp(f.life,0,1);
        ctx.strokeStyle="rgba(255,220,120,.55)";
        ctx.lineWidth=3;
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
        ctx.stroke();
      }else if(f.type==="flash"){
        ctx.globalAlpha = clamp(f.life*4,0,1);
        ctx.fillStyle="rgba(255,255,255,.65)";
        ctx.beginPath();
        ctx.arc(f.x,f.y,f.r,0,Math.PI*2);
        ctx.fill();
      }
      ctx.globalAlpha=1;
    }

    // player
    if(started){
      const alpha = player.inv>0 ? (0.35 + 0.65*Math.abs(Math.sin(performance.now()/90))) : 1;
      ctx.globalAlpha = alpha;
      ctx.fillStyle="rgba(120,200,255,.95)";
      ctx.fillRect(player.x,player.y,player.w,player.h);
      ctx.fillStyle="rgba(0,0,0,.35)";
      ctx.fillRect(player.x+6,player.y+4,player.w-12,player.h-8);
      ctx.globalAlpha=1;

      // options
      ctx.fillStyle="rgba(160,255,200,.8)";
      for(let i=0;i<player.opt;i++){
        const oy = player.y + (i===0?-22:22);
        ctx.beginPath();
        ctx.arc(player.x-18, oy+player.h/2, 7, 0, Math.PI*2);
        ctx.fill();
      }
    }

    // border vignette
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0,"rgba(0,0,0,.35)");
    g.addColorStop(.5,"rgba(0,0,0,0)");
    g.addColorStop(1,"rgba(0,0,0,.55)");
    ctx.fillStyle=g;
    ctx.fillRect(0,0,W,H);

    if(paused){
      ctx.fillStyle="rgba(0,0,0,.55)";
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle="rgba(255,255,255,.92)";
      ctx.font="bold 42px system-ui";
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText("PAUSE", W/2, H/2);
      ctx.textAlign="left"; ctx.textBaseline="alphabetic";
    }
  }

  // UI
  elStart.addEventListener("click", ()=>{
    if(!started) resetGame();
    else resetGame();
    // user interaction unlock audio
    if(!audio.mute) playBGM("bgm");
  });
  elMute.addEventListener("click", ()=>{
    setMute(!audio.mute);
  });

  // start
  setMute(false);
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
