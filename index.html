<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PC専用ありす的グラディウス</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@600;700;800&family=Noto+Sans+JP:wght@400;600;800;900&display=swap');
    :root { --bg:#0b0f1a; --fg:#e7ecff; --muted:#97a1c6; --danger:#ff4b4b; --ok:#36d399; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; }
    #wrap { height:100%; display:grid; place-items:center; }
    #frame { width:min(96vw, 1280px); aspect-ratio:16/9; position:relative; border-radius:18px; overflow:hidden; box-shadow: 0 14px 60px rgba(0,0,0,.45); background:#000; }
    canvas { width:100%; height:100%; display:block; image-rendering:auto; }
    #overlay {
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      justify-content:flex-start; align-items:center;
      background-image:
        radial-gradient(ellipse at center, rgba(0,0,0,.25), rgba(0,0,0,.92)),
        url("promo_bg_1920x1080.jpg");
      background-size: cover, cover;
      background-position: center, center;
      background-repeat: no-repeat, no-repeat;
      padding:22px;
      text-align:center;
      overflow-y:auto;
    }

    #overlay.hidden { display:none; }
    h1 { margin:0 0 8px; font-size:24px; letter-spacing:.5px; }
    p { margin:6px 0; color:var(--muted); font-size:14px; line-height:1.5; max-width:60ch; }
    .row { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-top:14px; }
    button {
      border:0; padding:10px 14px; border-radius:12px; cursor:pointer;
      background: rgba(231,236,255,.12); color:var(--fg);
      font-weight:650; letter-spacing:.2px;
    }
    button:hover { background: rgba(231,236,255,.18); }
    .kbd {
      display:inline-block; padding:1px 6px; border-radius:6px;
      background: rgba(231,236,255,.12); border: 1px solid rgba(231,236,255,.18);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px; color: var(--fg);
    }
    #hud {
      position:absolute; inset:0; pointer-events:none;
      padding:12px 14px; display:flex; justify-content:space-between; align-items:flex-start;
      text-shadow: 0 2px 10px rgba(0,0,0,.6);
    }
    #hudLeft { display:flex; flex-direction:column; gap:6px; }
    #hudRight { display:flex; flex-direction:column; align-items:flex-end; gap:6px; }
    #bottomHUD {
      position:absolute; left:0; right:0; bottom:0; padding:10px 14px 12px;
      display:flex; justify-content:center; align-items:center; gap:16px;
      pointer-events:none; text-shadow: 0 2px 10px rgba(0,0,0,.6);
    }
    #gauge {
      display:flex; gap:8px; align-items:center;
      background: rgba(0,0,0,.35); border: 1px solid rgba(231,236,255,.14);
      padding:8px 10px; border-radius:14px;
    }
    .cell {
      width:92px;
      height:26px;
      display:grid;
      place-items:center;
      border-radius:10px;
      font-size:12px;
      font-weight:700;
      border:1px solid rgba(231,236,255,.16);
      color: rgba(231,236,255,.85);
      background: rgba(231,236,255,.06);
      position:relative;
      padding-right:6px;
    }

    /* --- Level Badge --- */
    .levelBadge{
      position:absolute;
      top:-8px;
      right:-10px;
      min-width:16px;
      height:16px;
      padding:0 5px;
      border-radius:999px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:9px;
      font-weight:800;
      color:rgba(255,255,255,0.9);
      background:linear-gradient(
        180deg,
        rgba(255,120,120,0.40),
        rgba(255,60,60,0.35)
      );
      border:1px solid rgba(255,80,80,0.30);
      box-shadow:0 0 5px rgba(255,80,80,0.18);
      backdrop-filter: blur(2px);
      pointer-events:none;
    }

    .levelBadge.zero{
      background: rgba(231,236,255,0.06);
      border-color: rgba(231,236,255,0.22);
      box-shadow: none;
      color: rgba(231,236,255,0.60);
      backdrop-filter: none;
    }
    
    /* --- Badge pop + ring (on power-up) --- */
    .levelBadge{
      transform: translateZ(0);
    }
    .levelBadge.pop{
      animation: badgePop 180ms ease-out;
    }
    .levelBadge.pop::after{
      content:"";
      position:absolute;
      left:50%;
      top:50%;
      width:18px;
      height:18px;
      transform: translate(-50%,-50%) scale(0.6);
      border-radius:999px;
      border: 1px solid rgba(255,80,80,0.55);
      box-shadow: 0 0 12px rgba(255,80,80,0.25);
      opacity:0.0;
      animation: badgeRing 220ms ease-out;
      pointer-events:none;
    }
    @keyframes badgePop{
      0%   { transform: scale(1); }
      55%  { transform: scale(1.28); box-shadow:0 0 14px rgba(255,80,80,0.35); }
      100% { transform: scale(1); }
    }
    @keyframes badgeRing{
      0%   { opacity:0.0; transform: translate(-50%,-50%) scale(0.55); }
      15%  { opacity:0.75; }
      100% { opacity:0.0; transform: translate(-50%,-50%) scale(1.55); }
    }
.cell.active { outline:2px solid rgba(231,236,255,.45); background: rgba(231,236,255,.12); }
    .cell.ready { background: rgba(54,211,153,.18); border-color: rgba(54,211,153,.35); color: rgba(231,236,255,.95); }
    #tips { font-size:12px; color: rgba(231,236,255,.75); background: rgba(0,0,0,.32); border:1px solid rgba(231,236,255,.12); padding:8px 10px; border-radius:14px; }
    #lives { display:flex; gap:6px; align-items:center; }
    .life { width:14px; height:14px; border-radius:999px; background: rgba(231,236,255,.22); border:1px solid rgba(231,236,255,.32); }
    .life.on { background: rgba(231,236,255,.75); }
    .tag { font-size:12px; color: rgba(231,236,255,.85); background: rgba(0,0,0,.32); border:1px solid rgba(231,236,255,.12); padding:6px 10px; border-radius:999px; }
  
  #progressWrap{
    position: absolute;
    left: 50%;
    top: 18px;
    transform: translateX(-50%);
    width: min(560px, 72vw);
    height: 18px;
    border-radius: 999px;
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.12);
    overflow: hidden;
    pointer-events: none;
  }
  #progressBar{
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, rgba(120,200,255,0.95), rgba(255,220,140,0.95));
    box-shadow: 0 0 18px rgba(120,200,255,0.25);
  }
  #progressText{
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    font-size: 12px;
    color: rgba(231,236,255,0.92);
    text-shadow: 0 1px 8px rgba(0,0,0,0.45);
    letter-spacing: 0.02em;
  }

    /* --- Leaderboard (Global / Workers + D1) --- */
    #lb {
      margin-top: 14px;
      width: min(560px, 92vw);
      background: rgba(231,236,255,.06);
      border: 1px solid rgba(231,236,255,.14);
      border-radius: 14px;
      padding: 12px 12px 10px;
      text-align: left;
    }
    #lbHead { display:flex; align-items:baseline; justify-content:space-between; gap:10px; margin-bottom:8px; }
    #lbTitle { font-weight: 750; letter-spacing: .2px; }
    #lbStatus { font-size: 12px; color: var(--muted); white-space: nowrap; }
    #lbBody { margin: 0; padding-left: 22px; font-size: 13px; line-height: 1.5; }
    #lbBody li { display:flex; align-items:baseline; justify-content:space-between; gap:12px; margin: 4px 0; }
    #lbBody .name { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width: 320px; }
    #lbBody .val { font-variant-numeric: tabular-nums; color: rgba(231,236,255,.88); }
    #lbHint { margin-top: 8px; font-size: 12px; color: var(--muted); }

  
    /* --- Start screen typography --- */
    #overlay h1.gameTitle{
      margin: 6px 0 12px;
      font-size: clamp(34px, 4.2vw, 64px);
      line-height: 1.05;
      letter-spacing: 0.08em;
      text-transform: none;
      font-weight: 900;
      font-family: "Orbitron", "Noto Sans JP", system-ui, sans-serif;
      background: linear-gradient(180deg, rgba(255,255,255,0.98), rgba(168,77,255,0.92));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow:
        0 0 10px rgba(168,77,255,0.35),
        0 0 28px rgba(168,77,255,0.22),
        0 10px 46px rgba(0,0,0,0.55);
    }
    #overlay h1.gameTitle .jp,
    #overlay h1.gameTitle .gr{ font-family: "Noto Sans JP", system-ui, sans-serif; font-weight: 900; letter-spacing: 0.06em; }
    #overlay h1.gameTitle .x{
      display:inline-block;
      margin: 0 0.18em;
      font-family: "Orbitron", system-ui, sans-serif;
      font-weight: 800;
      color: rgba(255,75,75,0.95);
      text-shadow: 0 0 18px rgba(255,75,75,0.55), 0 0 34px rgba(255,75,75,0.28);
    }
    #overlay .tagline{
      margin: 0 0 10px;
      font-size: 15px;
      line-height: 1.7;
      color: rgba(231,236,255,0.82);
      max-width: 54ch;
      letter-spacing: 0.02em;
    }
    #overlay .tagline strong{
      color: rgba(231,236,255,0.96);
      font-weight: 800;
    }
    #overlay .tagline2{
      margin: 0 0 14px;
      font-size: 16px;
      line-height: 1.6;
      color: rgba(231,236,255,0.90);
      letter-spacing: 0.03em;
      font-weight: 800;
      text-shadow: 0 2px 16px rgba(0,0,0,0.55);
    }
    #overlay .row{ margin-top: 16px; }
    #overlay button#start{
      background: rgba(168,77,255,0.18);
      border: 1px solid rgba(168,77,255,0.32);
      box-shadow: 0 10px 34px rgba(0,0,0,0.45), 0 0 24px rgba(168,77,255,0.18);
    }
    
    #overlay #pcNote{
      margin-top: 12px;
      font-size: 12px;
      line-height: 1.4;
      letter-spacing: 0.02em;
      color: rgba(231,236,255,0.78);
      opacity: 0.72;
      background: rgba(0,0,0,0.30);
      border: 1px solid rgba(231,236,255,0.12);
      padding: 6px 10px;
      border-radius: 999px;
      text-shadow: 0 2px 14px rgba(0,0,0,0.55);
      pointer-events: none;
    }
#overlay button#start:hover{
      background: rgba(168,77,255,0.26);
    }
    /* --- /Start screen typography --- */

  
/* Mission Failed background */
#overlay.mission-failed-bg{
  background-image: url('END.jpg');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}
#overlay.mission-failed-bg::before{
  content:"";
  position:absolute; inset:0;
  background: radial-gradient(ellipse at center, rgba(0,0,0,0.10) 0%, rgba(0,0,0,0.55) 55%, rgba(0,0,0,0.78) 100%);
  pointer-events:none;
}
#overlay.mission-failed-bg > *{ position: relative; z-index: 1; }


/* ===== CLEAR BACKGROUND (Final Boss Defeated) ===== */
#overlay.clear-bg{
  background-image: url('cla2.png');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
}
#overlay.clear-bg::before{
  content:"";
  position:absolute;
  inset:0;
  background: radial-gradient(ellipse at center,
    rgba(0,0,0,0.15) 0%,
    rgba(0,0,0,0.55) 60%,
    rgba(0,0,0,0.80) 100%);
  pointer-events:none;
}
#overlay.clear-bg > *{
  position:relative;
  z-index:1;
}

</style>
<link rel="preload" as="image" href="cla2.png">
</head>
<body>
<div id="wrap">
  <div id="frame">
    <canvas id="c" width="1280" height="720"></canvas>

    <audio id="bgmNormal" src="geme.mp3" loop preload="auto"></audio>
    <audio id="bgmBoss" src="boss.mp3" loop preload="auto"></audio>
    <audio id="bgmMidboss" src="boss2.mp3" loop preload="auto"></audio>

    <div id="hud">
      <div id="hudLeft">
        <div class="tag">スコア： <span id="score">0</span></div>
        </div>
      <div id="hudRight">
        <div id="lives" class="tag" aria-label="lives"></div>
      </div>
    </div>

    <div id="progressWrap" aria-label="ゴールまでの進捗">
      <div id="progressBar"></div>
      <div id="progressText">進捗：0%</div>
    </div>

    <div id="bottomHUD">
      <div id="gauge" aria-label="powerup gauge"></div>
      <div id="tips">
        移動 <span class="kbd">WASD</span> / <span class="kbd">↑↓←→</span>　
        ショット <span class="kbd">Z</span>/<span class="kbd">Space</span>　
        ミサイル <span class="kbd">X</span>　
        発動 <span class="kbd">C</span>　
        ポーズ <span class="kbd">Esc</span>
      </div>
    </div>

    <div id="overlay">

      <h1 class="gameTitle"><span class="jp">ありす</span><span class="x">×</span><span class="gr">グラディウス</span></h1>
      <p class="tagline">撃つたびに、強くなる。<br/>だが、敵も進化する。</p>
      <p class="tagline2">あなたは、生き残れるか。</p>
      <div class="row">
        <button id="start">出撃</button>
      </div>

      <div id="lb" aria-live="polite">
        <div id="lbHead">
          <div id="lbTitle">ランキング TOP10</div>
          <div id="lbStatus">読み込み中…</div>
        </div>
        <ol id="lbBody"></ol>
        <div id="lbHint">※ クリア時、<b>TOP10</b>に入った場合のみ名前入力が出ます。</div>
      </div>
      <div id="pcNote">※このゲームはPCブラウザ用です。スマホでの使用は想定していません。</div>

    </div>

  </div>
</div>

<script>
(() => {
  "use strict";
  const STAGE_TOTAL_SEC = 480;
  const PROGRESS_SCALE = 3.0; // 進捗3倍速
  function updateProgressUI() {
    const bar = document.getElementById("progressBar");
    const txtEl = document.getElementById("progressText");
    const t = (typeof progressMaxAbs === "number") ? progressMaxAbs : 0;
    let p = Math.min(0.995, t / STAGE_TOTAL_SEC);
    try { if (director && director.bossDead) p = 1.0; } catch {}
    const pct = Math.max(0, Math.min(100, Math.round(p * 100)));
    if (bar) bar.style.width = pct + "%";
    if (txtEl) txtEl.textContent = "進捗：" + pct + "%";
  }

  const clamp = (v, a, b) => (v < a ? a : (v > b ? b : v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const rand = (a,b) => a + Math.random()*(b-a);
  const TAU = Math.PI * 2;

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });

  // --- Player sprite (custom ship) ---
  // Place a transparent PNG named "ship.png" next to this HTML file.
  const shipImg = new Image();
  shipImg.src = "ship.png";
  let shipImgReady = false;
  shipImg.onload = () => { shipImgReady = true; };
  shipImg.onerror = (e) => { console.warn("ship.png load failed", e); shipImgReady = false; };
  // --- /Player sprite ---

  // roundRect polyfill（古い環境対策）
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w*0.5, h*0.5);
      this.beginPath();
      this.moveTo(x+r, y);
      this.lineTo(x+w-r, y);
      this.quadraticCurveTo(x+w, y, x+w, y+r);
      this.lineTo(x+w, y+h-r);
      this.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      this.lineTo(x+r, y+h);
      this.quadraticCurveTo(x, y+h, x, y+h-r);
      this.lineTo(x, y+r);
      this.quadraticCurveTo(x, y, x+r, y);
      this.closePath();
      return this;
    };
  }
  const W = canvas.width, H = canvas.height;  const SCROLL_SCALE = 2.0; // スクロール速度倍率（2.0＝2倍）

  const elOverlay = document.getElementById("overlay");
  const elStart = document.getElementById("start");
  const elHow = document.getElementById("how");
  const elHowTxt = document.getElementById("howtxt"); // (may be null)
  const elScore = document.getElementById("score");
  const elFPS = document.getElementById("fps");
  const elCP = document.getElementById("cp");
  const elGauge = document.getElementById("gauge");
  const elLives = document.getElementById("lives");
  const elProgBar = document.getElementById("progressBar");
  const elProgTxt = document.getElementById("progressText");


  // -----------------------------
  // Global leaderboard (TOP10表示 / TOP10のみ登録) via Cloudflare Workers + D1
  // -----------------------------
  const LEADERBOARD_API = "https://gradius-top3.lullaby0anna.workers.dev";
  const elLBStatus = document.getElementById("lbStatus");
  const elLBBody   = document.getElementById("lbBody");

  // Overlay paragraphs (start説明の2行) を勝敗画面では隠す
  const _overlayPs = elOverlay.querySelectorAll("p");
  const elOverlayP1 = _overlayPs[0] || null;
  const elOverlayP2 = _overlayPs[1] || null;

  function lbEsc(s){
    return String(s).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
  }
  function lbBase(){
    return (LEADERBOARD_API || "").replace(/\/$/,"");
  }
  async function lbGetTop(limit=10){
    const url = lbBase() + "/top?limit=" + encodeURIComponent(String(limit));
    const r = await fetch(url, { method:"GET", cache:"no-store" });
    if (!r.ok) throw new Error("top fetch failed: " + r.status);
    return await r.json();
  }
  async function lbPostScore(name, scoreVal){
    const url = lbBase() + "/score";
    const r = await fetch(url, {
      method:"POST",
      headers:{ "content-type":"application/json" },
      body: JSON.stringify({ name, score: Math.floor(Number(scoreVal) || 0) })
    });
    if (!r.ok) throw new Error("score post failed: " + r.status);
    return await r.json();
  }
  function lbRender(rows){
    if(!elLBBody) return;
    const list = Array.isArray(rows) ? rows.slice(0, 10) : [];
    const out = [];
    for(let i=0;i<10;i++){
      const x = list[i];
      if(x){
        const n = lbEsc(x.name ?? "NONAME");
        const sc = Number(x.score ?? 0);
        out.push(`<li><span class="name">${i+1}位：${n}</span><span class="val">${sc}</span></li>`);
      }else{
        out.push(`<li><span class="name">${i+1}位：<span style="opacity:.7">—</span></span><span class="val" style="opacity:.7">—</span></li>`);
      }
    }
    elLBBody.innerHTML = out.join("");
  }

  function lbQualifies(scoreVal, list, n=10){
    const s = Math.floor(Number(scoreVal) || 0);
    if (!Array.isArray(list)) return false;
    if (list.length < n) return true;
    const last = Math.floor(Number(list[n-1] && list[n-1].score) || -1);
    return s > last;
  }
  async function lbRefresh(limit=10, statusPrefix=""){
    if (!LEADERBOARD_API || !elLBBody) return null;
    try{
      if (elLBStatus) elLBStatus.textContent = statusPrefix ? (statusPrefix + " 読み込み中…") : "読み込み中…";
      const top = await lbGetTop(limit);
      lbRender(top);
      if (elLBStatus) elLBStatus.textContent = statusPrefix ? (statusPrefix + " 更新") : "更新";
      return top;
    }catch(e){
      console.error(e);
      lbRender([]);
      if (elLBStatus) elLBStatus.textContent = "取得失敗";
      return null;
    }
  }
  async function lbHandleClear(scoreVal){
    const top10 = await lbRefresh(10);
    if (!top10) return;
    if (!lbQualifies(scoreVal, top10, 10)) return;

    let name = prompt("TOP10入り！名前を入力（10文字まで）", "PLAYER");
    if (name === null) name = "PLAYER";
    name = (name || "NONAME").trim().slice(0, 10) || "NONAME";

    try{
      if (elLBStatus) elLBStatus.textContent = "送信中…";
      await lbPostScore(name, scoreVal);
      await lbRefresh(10, "送信完了");
    }catch(e){
      console.error(e);
      if (elLBStatus) elLBStatus.textContent = "送信失敗";
    }
  }
  // -----------------------------
  // /Global leaderboard
  // -----------------------------

  // 起動時：スタート画面でランキングを表示
  lbRefresh(10);


  // ---- Boss Power Popup (Midboss/Boss) ----
  function showBossPowerPopup(kind, hpScale, atkScale){
    try{
      const host = document.getElementById("frame") || document.body;
      const div = document.createElement("div");
      const hpPct  = Math.round((hpScale - 1) * 100);
      const atkPct = Math.round((atkScale - 1) * 100);
      const title = (kind === "midboss") ? "MIDBOSS POWER" : "FINAL BOSS";
      div.innerHTML = `<div style="font-size:44px;font-weight:900;letter-spacing:.04em">${title}</div>`
        + `<div style="margin-top:6px;font-size:18px;font-weight:800;opacity:.95">HP +${hpPct}% / ATK +${atkPct}%</div>`;
      div.style.position = "absolute";
      div.style.top = "42%";
      div.style.left = "50%";
      div.style.transform = "translate(-50%, -50%) scale(0.92)";
      div.style.opacity = "0";
      div.style.padding = "14px 18px";
      div.style.borderRadius = "16px";
      div.style.border = "1px solid rgba(255,255,255,0.14)";
      div.style.background = "rgba(0,0,0,0.35)";
      // color shifts toward purple as scaling rises
      const heat = Math.min(1, Math.max(0, (Math.max(hpPct, atkPct) - 20) / 80));
      div.style.color = heat > 0.55 ? "rgba(210,160,255,0.98)" : "rgba(255,92,92,0.98)";
      div.style.textShadow = heat > 0.55 ? "0 0 22px rgba(190,140,255,0.75)" : "0 0 22px rgba(255,60,60,0.75)";
      div.style.pointerEvents = "none";
      div.style.zIndex = "9999";
      div.style.transition = "transform 1.8s ease-out, opacity 1.8s ease-out";
      host.appendChild(div);
      // animate in
      requestAnimationFrame(()=>{
        div.style.opacity = "1";
        div.style.transform = "translate(-50%, -56%) scale(1.18)";
      });
      // fade out near end
      setTimeout(()=>{
        div.style.opacity = "0";
        div.style.transform = "translate(-50%, -64%) scale(1.28)";
      }, 1200);
      setTimeout(()=>{ try{ div.remove(); }catch{} }, 2000);
    }catch(err){ console.error("showBossPowerPopup failed:", err); }
  }
  // ---- /Boss Power Popup ----



// Global error catcher: show errors on overlay so "start not working" is diagnosable.
window.addEventListener("error", (ev) => {
  try {
    console.error(ev.error || ev.message || ev);
    elOverlay.classList.remove("hidden");
    elOverlay.querySelector("h1").textContent = "エラー発生";
    const msg = (ev && (ev.message || (ev.error && ev.error.message))) ? (ev.message || ev.error.message) : "unknown error";
    const line = (ev && ev.lineno) ? (" (line " + ev.lineno + ")") : "";
    elOverlay.querySelector("p").textContent = "Console を確認: " + msg + line;
    elStart.textContent = "リロード";
    elStart.style.display = "inline-block";
    if (elHow) elHow.style.display = "none";
    if (elHowTxt) elHowTxt.style.display = "none";
    elStart.onclick = () => location.reload();
  } catch {}
});

if (elHow && elHowTxt) {
    elHow.addEventListener("click", () => {
      elHowTxt.style.display = (elHowTxt.style.display === "none") ? "block" : "none";
    });
  }

const keys = new Set();
  let lastFocus = true;

  window.addEventListener("keydown", (e) => {
    // Start from title/overlay with Enter
    if ((e.code === "Enter" || e.key === "Enter") && !started && !elOverlay.classList.contains("hidden")) {
      e.preventDefault();
      try { elStart.click(); } catch {}
      return;
    }
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (e.code === "Escape") togglePause();
  }, { passive:false });

  window.addEventListener("keyup", (e) => {
    keys.delete(e.code);
  });

  window.addEventListener("blur", () => { lastFocus = false; keys.clear(); });
  window.addEventListener("focus", () => { lastFocus = true; });

  const isDown = (codes) => codes.some(c => keys.has(c));

  let audioCtx = null;
  const ensureAudio = () => {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === "suspended") return audioCtx.resume();
  return Promise.resolve();
};

// Unlock audio on browsers that require a synchronous sound on user gesture.
function unlockAudio() {
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // resume without waiting (still in gesture)
    if (audioCtx.state === "suspended") audioCtx.resume();
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    o.type = "sine";
    o.frequency.setValueAtTime(440, t);
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start(t);
    o.stop(t + 0.02);
  } catch (e) {
    console.error("unlockAudio failed:", e);
  }
}

// --- MP3 BGM (geme.mp3 / boss2.mp3 / boss.mp3) ---
const bgmNormalEl  = document.getElementById("bgmNormal");
const bgmMidbossEl = document.getElementById("bgmMidboss");
const bgmBossEl    = document.getElementById("bgmBoss");

let _bgmCurrent = null;
let _fadeOutTimer = null;
let _fadeInTimer = null;

function _clearFadeTimers() {
  try { if (_fadeOutTimer) { clearInterval(_fadeOutTimer); _fadeOutTimer = null; } } catch {}
  try { if (_fadeInTimer)  { clearInterval(_fadeInTimer);  _fadeInTimer  = null; } } catch {}
}

function _safePlay(el) {
  if (!el) return;
  try {
    const p = el.play();
    if (p && typeof p.catch === "function") p.catch(() => {});
  } catch {}
}

function stopAllBGM() {
  _clearFadeTimers();
  try {
    for (const el of [bgmNormalEl, bgmMidbossEl, bgmBossEl]) {
      if (!el) continue;
      el.pause();
      el.currentTime = 0;
      el.volume = 0;
    }
    _bgmCurrent = null;
  } catch {}
}

// Fade switch: always restarts target from the beginning (midboss appears multiple times).
function fadeToBGM(targetEl, targetVol = 0.70, ms = 900) {
  if (!targetEl) return;
  if (_bgmCurrent === targetEl) return;

  _clearFadeTimers();

  const prev = _bgmCurrent;
  _bgmCurrent = targetEl;

  // fade out previous
  if (prev) {
    let v = Math.max(0, Math.min(1, prev.volume || 0));
    const steps = Math.max(1, Math.floor(ms / 50));
    const step = v / steps;

    _fadeOutTimer = setInterval(() => {
      v -= step;
      if (v <= 0.001) {
        prev.volume = 0;
        prev.pause();
        try { prev.currentTime = 0; } catch {}
        clearInterval(_fadeOutTimer);
        _fadeOutTimer = null;
      } else {
        prev.volume = v;
      }
    }, 50);
  }

  // start & fade in target
  try {
    targetEl.pause();
    targetEl.currentTime = 0; // every time from start
    targetEl.volume = 0;
  } catch {}
  _safePlay(targetEl);

  {
    let v = 0;
    const steps = Math.max(1, Math.floor(ms / 50));
    const step = targetVol / steps;

    _fadeInTimer = setInterval(() => {
      v += step;
      if (v >= targetVol) {
        targetEl.volume = targetVol;
        clearInterval(_fadeInTimer);
        _fadeInTimer = null;
      } else {
        targetEl.volume = v;
      }
    }, 50);
  }
}

function playNormalBGM(ms = 900)  { fadeToBGM(bgmNormalEl,  0.62, ms); }
function playMidbossBGM(ms = 900) { fadeToBGM(bgmMidbossEl, 0.70, ms); }
function playBossBGM(ms = 900)    { fadeToBGM(bgmBossEl,    0.72, ms); }
// --- /MP3 BGM ---




  function sfx(type="shot") {
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);

    if (type === "shot") {
      o.type = "square"; o.frequency.setValueAtTime(560, t);
      g.gain.setValueAtTime(0.06, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.06);
      o.start(t); o.stop(t+0.07);
    } else if (type === "missile") {
      o.type = "sawtooth"; o.frequency.setValueAtTime(220, t);
      o.frequency.exponentialRampToValueAtTime(110, t+0.18);
      g.gain.setValueAtTime(0.08, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
      o.start(t); o.stop(t+0.22);
    } else if (type === "power") {
      o.type = "triangle"; o.frequency.setValueAtTime(520, t);
      o.frequency.setValueAtTime(740, t+0.06);
      g.gain.setValueAtTime(0.09, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.25);
      o.start(t); o.stop(t+0.26);
    } else if (type === "hit") {
      o.type = "square"; o.frequency.setValueAtTime(90, t);
      g.gain.setValueAtTime(0.12, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.25);
      o.start(t); o.stop(t+0.26);
    } else if (type === "boom") {
      o.type = "sine"; o.frequency.setValueAtTime(130, t);
      o.frequency.exponentialRampToValueAtTime(60, t+0.3);
      g.gain.setValueAtTime(0.14, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.35);
      o.start(t); o.stop(t+0.36);
    } else if (type === "warn") {
      o.type = "square"; o.frequency.setValueAtTime(880, t);
      g.gain.setValueAtTime(0.07, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.12);
      o.start(t); o.stop(t+0.13);
    } else if (type === "rumble") {
      o.type = "sine"; o.frequency.setValueAtTime(58, t);
      o.frequency.exponentialRampToValueAtTime(38, t+0.55);
      g.gain.setValueAtTime(0.14, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.65);
      o.start(t); o.stop(t+0.66);
    }
  }

// --- BGM: Star Soldier–style chiptune (original, procedural) ---
// Uses WebAudio (square/square/triangle + noise) and schedules a short loop.
let bgm = {
  on: false,
  timer: null,
  tempo: 232,          // BPM
  lookahead: 0.10,     // seconds
  scheduleAhead: 0.18, // seconds
  step: 0,
  nextTime: 0,
  gain: null,
  comp: null,
  noiseBuf: null,
};

const mtof = (m) => 440 * Math.pow(2, (m - 69) / 12);

function initBGMIfNeeded() {
  if (!audioCtx) return;
  if (!bgm.gain) {
    bgm.gain = audioCtx.createGain();
    bgm.gain.gain.value = 0.0;

    // Arcade mix: light compression so we can push BGM louder without harsh clipping
    bgm.comp = audioCtx.createDynamicsCompressor();
    bgm.comp.threshold.setValueAtTime(-18, audioCtx.currentTime);
    bgm.comp.knee.setValueAtTime(12, audioCtx.currentTime);
    bgm.comp.ratio.setValueAtTime(6, audioCtx.currentTime);
    bgm.comp.attack.setValueAtTime(0.003, audioCtx.currentTime);
    bgm.comp.release.setValueAtTime(0.12, audioCtx.currentTime);

    bgm.gain.connect(bgm.comp);
    bgm.comp.connect(audioCtx.destination);
  }
  if (!bgm.noiseBuf) {
    const dur = 0.20;
    const len = Math.floor(audioCtx.sampleRate * dur);
    const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
    const ch = buf.getChannelData(0);
    for (let i=0;i<len;i++) ch[i] = (Math.random()*2 - 1) * 0.85;
    bgm.noiseBuf = buf;
  }
}

function chipNote(time, midi, dur, type, gain=0.07, detune=0) {
  if (!audioCtx || !bgm.gain) return;
  if (midi === null) return;

  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();

  o.type = type;
  o.frequency.setValueAtTime(mtof(midi), time);
  if (detune) o.detune.setValueAtTime(detune, time);

  // envelope
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.03, dur));

  o.connect(g);
  g.connect(bgm.gain);

  o.start(time);
  o.stop(time + Math.max(0.04, dur + 0.02));
}

function chipHat(time, dur=0.05, gain=0.035) {
  if (!audioCtx || !bgm.gain || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const hp = audioCtx.createBiquadFilter();
  hp.type = "highpass";
  hp.frequency.setValueAtTime(7000, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.02, dur));

  src.connect(hp);
  hp.connect(g);
  g.connect(bgm.gain);

  src.start(time);
  src.stop(time + Math.max(0.03, dur + 0.02));
}

function chipSnare(time, dur=0.10, gain=0.06) {
  if (!audioCtx || !bgm.gain || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const bp = audioCtx.createBiquadFilter();
  bp.type = "bandpass";
  bp.frequency.setValueAtTime(1800, time);
  bp.Q.setValueAtTime(0.8, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.004);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.05, dur));

  src.connect(bp);
  bp.connect(g);
  g.connect(bgm.gain);

  src.start(time);
  src.stop(time + Math.max(0.06, dur + 0.03));
}
function chipCrash(time, dur=0.35, gain=0.080) {
  if (!audioCtx || !bgm.gain || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const hp = audioCtx.createBiquadFilter();
  hp.type = "highpass";
  hp.frequency.setValueAtTime(2400, time);

  const bp = audioCtx.createBiquadFilter();
  bp.type = "bandpass";
  bp.frequency.setValueAtTime(6200, time);
  bp.Q.setValueAtTime(0.55, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.006);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.12, dur));

  src.connect(hp);
  hp.connect(bp);
  bp.connect(g);
  g.connect(bgm.gain);

  src.start(time);
  src.stop(time + Math.max(0.14, dur + 0.05));
}




function chipKick(time, dur=0.12, gain=0.09) {
  if (!audioCtx || !bgm.gain) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.setValueAtTime(140, time);
  o.frequency.exponentialRampToValueAtTime(60, time + Math.max(0.05, dur));
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.006);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.05, dur));
  o.connect(g); g.connect(bgm.gain);
  o.start(time);
  o.stop(time + Math.max(0.06, dur + 0.03));
}
function bgmStepSec() {
  return (60 / bgm.tempo) / 4; // 16th note
}

// 64-step loop (4 bars of 16th notes)
const BGM_LEN = 64;

// Melody (midi notes) - upbeat chiptune line (original pattern)
const MEL = [
// 4 bars (64 steps). E minor feel, fast arps + hooks.
83,86,88,86, 83,79,76,79, 83,86,88,91, 88,86,83,79,
81,83,84,83, 81,79,76,74, 76,79,81,83, 81,79,76,79,

88,91,93,91, 88,86,83,86, 88,91,93,95, 93,91,88,86,
84,86,88,86, 84,83,81,79, 81,83,84,86, 84,83,81,79,
];

// Harmony (a bit lower, simpler)
const HAR = [
// Harmony/2nd pulse (lower), mostly chord tones
71,74,76,74, 71,67,64,67, 71,74,76,79, 76,74,71,67,
69,71,72,71, 69,67,64,62, 64,67,69,71, 69,67,64,67,

76,79,81,79, 76,74,71,74, 76,79,81,83, 81,79,76,74,
72,74,76,74, 72,71,69,67, 69,71,72,74, 72,71,69,67,
];

// Bass (triangle), hits on 8ths
const BAS = [
// Bass (triangle): roots + walking movement (8ths with occasional pickups)
40,null,40,null, 43,null,43,null, 45,null,45,null, 47,null,47,null,
36,null,36,null, 38,null,38,null, 40,null,40,null, 43,null,43,null,

40,null,40,null, 43,null,43,null, 47,null,47,null, 45,null,45,null,
36,null,36,null, 38,null,38,null, 40,null,40,null, 35,null,35,null,
];

// Arp/Counter (square): fast upper arpeggio to make it more "shooting game" vivid
const ARP = [
  95,91,88,91, 95,91,88,91, 96,93,89,93, 96,93,89,93,
  95,91,88,91, 95,91,88,91, 98,95,91,95, 98,95,91,95,

  100,96,93,96, 100,96,93,96, 98,95,91,95, 98,95,91,95,
  96,93,89,93, 96,93,89,93, 95,91,88,91, 95,91,88,91,
];

// Drums: hat every 16th, snare on 2&4 (steps 16,48), plus extra hits
function scheduleBGMNote(time, step) {
  const i = step % BGM_LEN;
  const barStep = i % 16;

  // --- tonal layers ---
  // lead + harmony: brighter, slightly shorter for punch
    // lead: detuned double-square for aggressive arcade thickness
  chipNote(time, MEL[i], 0.075, "square", 0.120, -10);
  chipNote(time, MEL[i], 0.075, "square", 0.120, +10);
  // harmony: keep under the lead
  chipNote(time, HAR[i], 0.080, "square", 0.070, -18);

  // bass (triangle): keep it driving
  chipNote(time, BAS[i], 0.140, "triangle", 0.110, 0);

  // upper arp: makes it feel more "shooting game"
  // (small gain so it doesn't mask SFX)
  chipNote(time, ARP[i], 0.060, "square", 0.075, 12);

  // --- drums / groove ---
  // hats: stronger + occasional open-hat feel
  chipHat(time, 0.045, 0.045);
  if (barStep === 2 || barStep === 6 || barStep === 10 || barStep === 14) {
    chipHat(time, 0.080, 0.030);
  }

  // kick: double-kick on downbeats + pickup before snare
  if (barStep === 0 || barStep === 8) {
    chipKick(time, 0.16, 0.120);
    chipKick(time + 0.02, 0.12, 0.075);
  }
  if (barStep === 3 || barStep === 11) chipKick(time, 0.12, 0.080);

  // snare: 2&4 + extra ghost note
  if (barStep === 4 || barStep === 12) chipSnare(time, 0.12, 0.110);
  if (barStep === 7 || barStep === 15) chipSnare(time, 0.07, 0.070);
  // end-of-bar roll
  if (barStep === 14) chipSnare(time, 0.08, 0.060);
  if (barStep === 15) chipSnare(time + 0.02, 0.06, 0.050);

  // crash on bar start (strong)
  if (barStep === 0) chipCrash(time, 0.35, 0.085);
}

function bgmSchedulerTick() {
  if (!audioCtx || !bgm.on) return;
  const now = audioCtx.currentTime;
  while (bgm.nextTime < now + bgm.scheduleAhead) {
    scheduleBGMNote(bgm.nextTime, bgm.step);
    bgm.step = (bgm.step + 1) % BGM_LEN;
    bgm.nextTime += bgmStepSec();
  }
}

function startBGM() {
  ensureAudio().then(() => {
    initBGMIfNeeded();
    if (!audioCtx || !bgm.gain) return;

    try { console.log('[BGM] startBGM ARCADE v3 tempo=', bgm.tempo, 'targetGain=0.42'); } catch(e) {}

    // fade in
    const t = audioCtx.currentTime;
    bgm.gain.gain.cancelScheduledValues(t);
    bgm.gain.gain.setValueAtTime(Math.max(0.0001, bgm.gain.gain.value), t);
    bgm.gain.gain.exponentialRampToValueAtTime(0.42, t + 0.22);

    if (bgm.on) return;
    bgm.on = true;
    bgm.step = bgm.step % BGM_LEN;
    bgm.nextTime = audioCtx.currentTime + 0.05;
    bgm.timer = setInterval(bgmSchedulerTick, Math.floor(bgm.lookahead * 1000));
  }).catch((err) => {
    console.error("startBGM resume failed:", err);
  });
}

function pauseBGM(paused) {
  if (!audioCtx || !bgm.gain) return;
  const t = audioCtx.currentTime;
  bgm.gain.gain.cancelScheduledValues(t);
  bgm.gain.gain.setValueAtTime(Math.max(0.0001, bgm.gain.gain.value), t);
  bgm.gain.gain.exponentialRampToValueAtTime(paused ? 0.0001 : 0.42, t + 0.18);
}

function stopBGM() {
  if (!audioCtx || !bgm.gain) { bgm.on = false; return; }
  const t = audioCtx.currentTime;
  bgm.gain.gain.cancelScheduledValues(t);
  bgm.gain.gain.setValueAtTime(Math.max(0.0001, bgm.gain.gain.value), t);
  bgm.gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.20);

  bgm.on = false;
  if (bgm.timer) { clearInterval(bgm.timer); bgm.timer = null; }
}


// --- Boss intro + Boss BGM (phase 1/2) ---
let bossIntro = { active:false, t:0, dur:2.6, flash:0.0, dark:0.0, white:0.0, shake:0.0 };

let bossBgm = {
  on:false,
  timer:null,
  tempo:168,
  lookahead:0.10,
  scheduleAhead:0.18,
  step:0,
  nextTime:0,
  gain:null,
  mode:1, // 1 or 2
};

function initBossBGMIfNeeded() {
  if (!audioCtx) return;
  initBGMIfNeeded(); // reuse noise buffer
  if (!bossBgm.gain) {
    bossBgm.gain = audioCtx.createGain();
    bossBgm.gain.gain.value = 0.0;
    bossBgm.gain.connect(audioCtx.destination);
  }
}

function chipNoteBus(time, midi, dur, type, outGainNode, gain=0.07, detune=0) {
  if (!audioCtx || !outGainNode) return;
  if (midi === null) return;

  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();

  o.type = type;
  o.frequency.setValueAtTime(mtof(midi), time);
  if (detune) o.detune.setValueAtTime(detune, time);

  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.03, dur));

  o.connect(g);
  g.connect(outGainNode);

  o.start(time);
  o.stop(time + Math.max(0.04, dur + 0.02));
}

function chipHatBus(time, dur, outGainNode, gain=0.03) {
  if (!audioCtx || !outGainNode || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const hp = audioCtx.createBiquadFilter();
  hp.type = "highpass";
  hp.frequency.setValueAtTime(7800, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.02, dur));

  src.connect(hp);
  hp.connect(g);
  g.connect(outGainNode);

  src.start(time);
  src.stop(time + Math.max(0.03, dur + 0.02));
}

function chipKickBus(time, dur, outGainNode, gain=0.085) {
  if (!audioCtx || !outGainNode) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.setValueAtTime(150, time);
  o.frequency.exponentialRampToValueAtTime(55, time + Math.max(0.05, dur));
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.006);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.05, dur));
  o.connect(g); g.connect(outGainNode);
  o.start(time);
  o.stop(time + Math.max(0.06, dur + 0.03));
}

function chipSnareBus(time, dur, outGainNode, gain=0.06) {
  if (!audioCtx || !outGainNode || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const bp = audioCtx.createBiquadFilter();
  bp.type = "bandpass";
  bp.frequency.setValueAtTime(2100, time);
  bp.Q.setValueAtTime(0.9, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.004);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.05, dur));

  src.connect(bp);
  bp.connect(g);
  g.connect(outGainNode);

  src.start(time);
  src.stop(time + Math.max(0.06, dur + 0.03));
}

function bossBgmStepSec() {
  return (60 / bossBgm.tempo) / 4; // 16th note
}

const BOSS_BGM_LEN = 64;

// Phase 1: heavy, tense ostinato (original pattern)
const BOSS_MEL_1 = [
  76,null,76,null, 79,null,78,null, 76,null,74,null, 73,null,74,null,
  76,null,76,null, 79,null,81,null, 83,null,81,null, 79,null,78,null,

  76,null,76,null, 79,null,78,null, 76,null,74,null, 73,null,74,null,
  69,null,69,null, 71,null,73,null, 74,null,73,null, 71,null,69,null,
];

const BOSS_HAR_1 = [
  64,null,64,null, 67,null,66,null, 64,null,62,null, 61,null,62,null,
  64,null,64,null, 67,null,69,null, 71,null,69,null, 67,null,66,null,

  64,null,64,null, 67,null,66,null, 64,null,62,null, 61,null,62,null,
  57,null,57,null, 59,null,61,null, 62,null,61,null, 59,null,57,null,
];

const BOSS_BAS_1 = [
  33,null,33,null, 33,null,33,null, 36,null,36,null, 36,null,36,null,
  38,null,38,null, 38,null,38,null, 36,null,36,null, 35,null,35,null,

  33,null,33,null, 33,null,33,null, 36,null,36,null, 36,null,36,null,
  31,null,31,null, 31,null,31,null, 33,null,33,null, 28,null,28,null,
];

// Phase 2: faster + brighter lead, more aggressive drums (original pattern)
const BOSS_MEL_2 = [
  83,86,88,86, 83,79,78,79, 83,86,90,88, 86,83,81,83,
  86,88,90,88, 86,83,81,79, 81,83,86,83, 81,79,78,79,

  88,90,93,90, 88,86,83,86, 88,90,95,93, 90,88,86,83,
  81,83,86,83, 81,79,78,79, 83,86,88,86, 83,81,79,78,
];

const BOSS_HAR_2 = [
  71,74,76,74, 71,67,66,67, 71,74,78,76, 74,71,69,71,
  74,76,78,76, 74,71,69,67, 69,71,74,71, 69,67,66,67,

  76,78,81,78, 76,74,71,74, 76,78,83,81, 78,76,74,71,
  69,71,74,71, 69,67,66,67, 71,74,76,74, 71,69,67,66,
];

const BOSS_BAS_2 = [
  40,null,40,null, 43,null,43,null, 45,null,45,null, 47,null,47,null,
  45,null,45,null, 43,null,43,null, 40,null,40,null, 38,null,38,null,

  40,null,40,null, 43,null,43,null, 47,null,47,null, 45,null,45,null,
  40,null,40,null, 38,null,38,null, 36,null,36,null, 35,null,35,null,
];

function scheduleBossBGMNote(time, step) {
  const i = step % BOSS_BGM_LEN;
  const barStep = i % 16;

  const mel = (bossBgm.mode === 2) ? BOSS_MEL_2 : BOSS_MEL_1;
  const har = (bossBgm.mode === 2) ? BOSS_HAR_2 : BOSS_HAR_1;
  const bas = (bossBgm.mode === 2) ? BOSS_BAS_2 : BOSS_BAS_1;

  const leadGain = (bossBgm.mode === 2) ? 0.095 : 0.080;
  const harGain  = (bossBgm.mode === 2) ? 0.060 : 0.055;
  const basGain  = (bossBgm.mode === 2) ? 0.090 : 0.085;

  chipNoteBus(time, mel[i], 0.090, "square", bossBgm.gain, leadGain, 0);
  chipNoteBus(time, har[i], 0.090, "square", bossBgm.gain, harGain, -10);
  chipNoteBus(time, bas[i], 0.140, "triangle", bossBgm.gain, basGain, 0);

  // drums
  const hatGain = (bossBgm.mode === 2) ? 0.034 : 0.028;
  chipHatBus(time, 0.045, bossBgm.gain, hatGain);

  // kick/snare accents
  if (barStep === 0 || barStep === 8) chipKickBus(time, 0.12, bossBgm.gain, bossBgm.mode === 2 ? 0.095 : 0.085);
  if (barStep === 4 || barStep === 12) chipSnareBus(time, 0.10, bossBgm.gain, bossBgm.mode === 2 ? 0.080 : 0.070);

  if (bossBgm.mode === 2) {
    // extra fill for phase 2
    if (barStep === 14) chipSnareBus(time, 0.06, bossBgm.gain, 0.055);
    if (barStep === 15) chipHatBus(time, 0.06, bossBgm.gain, 0.045);
  } else {
    if (barStep === 15) chipSnareBus(time, 0.06, bossBgm.gain, 0.045);
  }
}

function bossBgmSchedulerTick() {
  if (!audioCtx || !bossBgm.on) return;
  const now = audioCtx.currentTime;
  while (bossBgm.nextTime < now + bossBgm.scheduleAhead) {
    scheduleBossBGMNote(bossBgm.nextTime, bossBgm.step);
    bossBgm.step = (bossBgm.step + 1) % BOSS_BGM_LEN;
    bossBgm.nextTime += bossBgmStepSec();
  }
}

function startBossBGM(mode=1) {
  ensureAudio().then(() => {
    initBossBGMIfNeeded();
    if (!audioCtx || !bossBgm.gain) return;

    bossBgm.mode = mode;
    bossBgm.tempo = (mode === 2) ? 186 : 168;

    // fade in
    const t = audioCtx.currentTime;
    bossBgm.gain.gain.cancelScheduledValues(t);
    bossBgm.gain.gain.setValueAtTime(Math.max(0.0001, bossBgm.gain.gain.value), t);
    bossBgm.gain.gain.exponentialRampToValueAtTime(0.20, t + 0.20);

    if (bossBgm.on) return;
    bossBgm.on = true;
    bossBgm.step = bossBgm.step % BOSS_BGM_LEN;
    bossBgm.nextTime = audioCtx.currentTime + 0.05;
    bossBgm.timer = setInterval(bossBgmSchedulerTick, Math.floor(bossBgm.lookahead * 1000));
  }).catch((err) => {
    console.error("startBossBGM resume failed:", err);
  });
}

function stopBossBGM() {
  if (!audioCtx || !bossBgm.gain) { bossBgm.on = false; return; }
  const t = audioCtx.currentTime;
  bossBgm.gain.gain.cancelScheduledValues(t);
  bossBgm.gain.gain.setValueAtTime(Math.max(0.0001, bossBgm.gain.gain.value), t);
  bossBgm.gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);

  bossBgm.on = false;
  if (bossBgm.timer) { clearInterval(bossBgm.timer); bossBgm.timer = null; }
}

function bossIntroFlash(str=0.7) {
  bossIntro.flash = Math.max(bossIntro.flash, str);
}

function triggerBossIntro() {
  bossIntro.active = true;
  bossIntro.t = 0;
  bossIntro.dur = 2.6;
  bossIntro.flash = 1.0;
  bossIntro.dark = 0.65;
  bossIntro.white = 1.0;
  bossIntro.shake = 10.0;
  // loud warning + low rumble
  sfx("rumble");
  sfx("warn");
  // a couple of warning chirps
  setTimeout(() => { try { sfx("warn"); } catch {} }, 260);
  setTimeout(() => { try { sfx("warn"); } catch {} }, 520);
}
// --- /Boss intro + Boss BGM ---

// --- /BGM ---


  class Pool {
    constructor(create, cap=256) { this.create=create; this.items=[]; this.cap=cap; }
    get() { return this.items.pop() || this.create(); }
    put(o) { if (this.items.length < this.cap) this.items.push(o); }
  }


  const shotPool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,r:4,ttl:0,kind:"shot",dmg:1}), 600);
  const enemyShotPool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,r:5,ttl:0,kind:"e",homing:0,spd:0}), 900);
  const missilePool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,r:5,ttl:0,trail:0,dmg:6}), 200);
  const fxPool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,ttl:0,size:0,kind:"spark"}), 900);
  const capsulePool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,r:10,ttl:0}), 32);

  const enemyPool = new Pool(() => ({
    active:false, x:0,y:0,vx:0,vy:0, r:16, hp:1, score:100,
    ai:"", t:0, p:0, w:32,h:32, solid:false
  }), 220);

  const gaugeItems = ["SPEED","MISSILE","DOUBLE","LASER","OPTION","SHIELD"];
  const gaugeLabels = {SPEED:"スピード",MISSILE:"ミサイル",DOUBLE:"ダブル",LASER:"レーザー",OPTION:"オプション",SHIELD:"シールド"};
  let gaugeProgress = -1; // 初期は未選択 // 0..len-1 as step
  let gaugeReady = false;
  let __prevGaugeLevels = Object.create(null);

  let paused = false;
  let started = false;

  let score = 0;
  let lives = 1;

  let checkpoint = "A";
  let stageTime = 0;      // seconds since stage start (from last checkpoint restart, we use absolute stage timeline for spawns)
  let stageTimeAbs = 0;   // absolute stage time across deaths (to preserve progression). We'll reset to checkpoint time on death.
  let progressMaxAbs = 0;   // 到達した最大の絶対時間（死亡で戻さない）
  let stageTimeGlobal = 0; // 死亡で巻き戻さない進捗用タイム
  let section = "A";

  const checkpointTimes = { A:0, C:150, M:280, B:370 }; // seconds in the stage timeline

  const player = {
    x: 220, y: H*0.5,
    vx:0, vy:0,
    roll: 0,
    w: 42, h: 24, // sprite box
    hx: 22, hy: 12, // hitbox half-size (smaller)
    invuln: 0,
    speedLevel: 0, // 0..2
    missile: false,
    missileLevel: 0, // unlimited stacks (dmg +10% each)
    shotLevel: 0, // 0:single 1:double (derived from doubleLevel)
    doubleLevel: 0, // unlimited stacks (dmg +10% each)
    hasLaser: false,
    laserLevel: 0,
    laserPulse: 0,
    options: 0,   // 0..2
    shield: 0,    // stackable
    shieldPulse: 0,
    shieldDownTimer: 0, // visual pulse on gain/hit
    shieldDownX: 0,
    shieldDownY: 0,
    fireCD: 0,
    missileCD: 0,
    alive: true,
    trail: [], // for options follow
    laserOn: false,
    laserSfx: 0,
    optionLaserOn: 0,
  };

  // expose safe hook for shield-down UI/VFX (used by global triggerShieldDown wrapper)
  window.__triggerShieldDown = () => {
    // no-op here; the in-game -1 popup is drawn from player.shieldDownTimer/X/Y
  };


  const optionDelayFrames = []; // unlimited options (delay in trail frames)
const optionPos = []; // {x,y} for each option

function ensureOptions(n) {
  // Ensure arrays are sized for n options. Delay grows with index but clamps to trail length.
  const maxDelay = 88; // player.trail max is 90
  for (let i = optionPos.length; i < n; i++) {
    optionPos.push({x: player.x, y: player.y});
  }
  for (let i = optionDelayFrames.length; i < n; i++) {
    optionDelayFrames.push(Math.min(10 * (i + 1), maxDelay));
  }
}


  let terrain = []; // array of {x,y,w,h} AABB blocks (solid)
  let terrainHint = []; // for rendering outlines (lightweight)

  let shots = [];
  let enemyShots = [];
  let missiles = [];
  let enemies = [];
  let capsules = [];
  let fx = [];

  let midboss = null;
  let boss = null;

  let director = { midbossStarted:false, midbossDead:false, bossStarted:false, bossDead:false, warnOutcrop:false,
    pMidIdx:0, pMidActive:false,
    bossPhase2Bgm:false
  };

  let fps = 0, fpsAcc = 0, fpsFrames = 0;

  // render-time delta (used by drawShots etc.)
  let _dtRender = 1/60;

  function renderGaugeUI() {
    elGauge.innerHTML = "";

    for (let i=0;i<gaugeItems.length;i++) {
      const type = gaugeItems[i];
      const d = document.createElement("div");
      d.className = "cell";
      d.textContent = gaugeLabels[type] || type;

      if (gaugeProgress >= 0 && i === gaugeProgress)
        d.classList.add("active");

      if (gaugeProgress >= 0 && gaugeReady && i === gaugeProgress)
        d.classList.add("ready");

      let level = 0;
      if (type === "SPEED")   level = player.speedLevel;
      if (type === "MISSILE") level = player.missileLevel;
      if (type === "DOUBLE")  level = player.doubleLevel;
      if (type === "LASER")   level = player.laserLevel;
      if (type === "OPTION")  level = player.options;
      if (type === "SHIELD")  level = player.shield;

      const prev = (__prevGaugeLevels[type] ?? level);

      // Always show badge; level 0 is shown as a subtle "inactive" badge.
      const badge = document.createElement("div");
      badge.className = "levelBadge" + (level <= 0 ? " zero" : "");
      badge.textContent = Math.max(0, level);

      // Pop + ring only when the level increased
      if (level > prev) badge.classList.add("pop");

      d.appendChild(badge);
      elGauge.appendChild(d);

      __prevGaugeLevels[type] = level;
    }
  }

  function renderLivesUI() {
    elLives.innerHTML = "";
    const label = document.createElement("span");
    label.textContent = "残機：";
    label.style.marginRight = "8px";
    elLives.appendChild(label);

    for (let i=0;i<1;i++) {
      const d = document.createElement("div");
      d.className = "life" + (i < lives ? " on" : "");
      elLives.appendChild(d);
    }
  }

  function setCheckpointLabel() {
    const cpMap = {A:"A（開始）", C:"C（洞窟）", M:"M（中ボス）", B:"B（ボス）"};
    if (elCP) elCP.textContent = cpMap[checkpoint] || checkpoint;
  }

  function circleHit(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    const rr = (a.r + b.r);
    return dx*dx + dy*dy <= rr*rr;
  }

  function playerHitCircle(c) {
    const px1 = player.x - player.hx, px2 = player.x + player.hx;
    const py1 = player.y - player.hy, py2 = player.y + player.hy;
    const cx = c.x, cy = c.y, r = c.r;
    const nx = clamp(cx, px1, px2);
    const ny = clamp(cy, py1, py2);
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= r*r;
  }

  function rectOverlap(ax,ay,aw,ah, bx,by,bw,bh) {
    return (ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by);
  }

  function clearTerrain() { terrain.length = 0; terrainHint.length = 0; }

  function genCave(sectionId) {
    clearTerrain();
    const tile = 32;
    const length = (sectionId === "C") ? 2200 : 1800; // px world length
    const startX = 0;
    const cols = Math.floor(length / tile);
    const blocks = [];

    let baseCeil = (sectionId === "C") ? 110 : 100;
    let baseFloor = (sectionId === "C") ? 660 : 670;
    let amp = (sectionId === "C") ? 70 : 55;
    let freq = (sectionId === "C") ? 0.07 : 0.09;

    const pinch = (sectionId === "C") ? [
      {x: 620, w: 300, shrink: 150},
      {x: 1450, w: 260, shrink: 170},
    ] : [];

    for (let i=0;i<cols;i++) {
      const x = startX + i*tile;
      const s = Math.sin((x*freq));
      const s2 = Math.sin((x*freq*0.57)+1.8);
      let ceil = baseCeil + (s*amp*0.6) + (s2*amp*0.25);
      let floor = baseFloor + (s*amp*0.55) - (s2*amp*0.25);

      for (const p of pinch) {
        if (x >= p.x && x <= p.x + p.w) {
          const t = (x - p.x) / p.w;
          const k = 1 - Math.abs(t-0.5)*2; // peak at middle
          ceil += k * (p.shrink*0.55);
          floor -= k * (p.shrink*0.55);
        }
      }

      ceil = clamp(ceil, 30, 260);
      floor = clamp(floor, 420, 710);

      const ceilRows = Math.ceil(ceil / tile);
      for (let r=0;r<ceilRows;r++) blocks.push({x, y:r*tile, w:tile, h:tile});
      const floorRowsStart = Math.floor(floor / tile);
      for (let r=floorRowsStart;r<Math.ceil(H/tile);r++) blocks.push({x, y:r*tile, w:tile, h:tile});

      terrainHint.push({x, ceilY: ceil, floorY: floor});
    }

    terrain.push(...blocks);
  }

  function genOutcrop() {
  }

  function drawBackground(t) {
    ctx.fillStyle = "#060812";
    ctx.fillRect(0,0,W,H);

    const baseX = (t*120) % W;        // scroll speed
    const baseX2 = (t*60) % W;

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "#0f1530";
    for (let i=0;i<90;i++) {
      const x = (i*73 + (W-baseX)) % W;
      const y = (i*151) % H;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = "#1b2a66";
    for (let i=0;i<60;i++) {
      const x = (i*127 + (W-baseX2)) % W;
      const y = (i*193 + 90) % H;
      ctx.fillRect(x, y, 1, 1);
    }
    ctx.globalAlpha = 1;
  }

  function drawTerrain(worldOffsetX) {
    if (terrainHint.length === 0) return;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    for (const b of terrain) {
      const sx = b.x - worldOffsetX;
      if (sx < -64 || sx > W+64) continue;
      ctx.fillRect(sx, b.y, b.w, b.h);
    }

    ctx.strokeStyle = "rgba(231,236,255,0.12)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (const h of terrainHint) {
      const sx = h.x - worldOffsetX;
      if (sx < -64 || sx > W+64) continue;
      ctx.moveTo(sx, h.ceilY);
      ctx.lineTo(sx+32, h.ceilY);
      ctx.moveTo(sx, h.floorY);
      ctx.lineTo(sx+32, h.floorY);
    }
    ctx.stroke();
  }

  function drawPlayer() {
    const blink = player.invuln > 0 ? (Math.floor(player.invuln*12)%2===0) : false;
    const prevAlpha = ctx.globalAlpha;
    if (blink) ctx.globalAlpha = 0.45;

    // --- sprite animation settings ---
    const SPRITE_SCALE = 0.72;             // smaller ship
    const V_SCALE = 0.70;                // vertical squash (1.0 = normal)
    const ROLL_MAX = 0.28;                 // radians
    const ROLL_SMOOTH = 0.18;              // 0..1

    // Roll based on vertical velocity (up = nose up, down = nose down)
    const targetRoll = clamp(player.vy / 380, -ROLL_MAX, ROLL_MAX);
    player.roll = (typeof player.roll === "number") ? lerp(player.roll, targetRoll, ROLL_SMOOTH) : targetRoll;

    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.rotate(player.roll);

    // Flip horizontally so it faces left (game direction)
    // Draw sprite if available; otherwise fallback to simple vector ship.
    const dw = player.w * 2 * SPRITE_SCALE;
    const dh = player.h * 2 * SPRITE_SCALE;

    // ===== Stack Aura (自機まわりのエフェクト) =====
    // ミサイル / ダブル / レーザー / オプション / シールドの重ね掛けで色が濃くなる
    const stMissile = player.missile ? (player.missileLevel|0) : 0;
    const stDouble  = (player.doubleLevel|0);
    const stLaser   = player.hasLaser ? (player.laserLevel|0) : 0;
    const stOption  = (player.options|0);
    const stShield  = (player.shield|0);

    const auraRing = (rgb, st, base=1.12) => {
      if (st <= 0) return;
      const cap = Math.min(st, 12);
      const a = Math.min(0.06 + cap * 0.03, 0.48);       // 濃度（スタックで増える）
      const grow = 1.00 + cap * 0.045;                   // サイズ（少しだけ増える）
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = a;
      ctx.strokeStyle = `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`;
      ctx.lineWidth = 1.6 + cap * 0.22;

      const rx = (dw * 0.55) * base * grow;
      const ry = (dh * 0.55) * base * grow;

      ctx.beginPath();
      ctx.ellipse(0, 0, rx, ry, 0, 0, TAU);
      ctx.stroke();

      // 内側リング（濃さを足す）
      ctx.globalAlpha *= 0.55;
      ctx.lineWidth = 1.2 + cap * 0.16;
      ctx.beginPath();
      ctx.ellipse(0, 0, rx * 0.82, ry * 0.82, 0, 0, TAU);
      ctx.stroke();

      ctx.restore();
    };

    // 色は固定、濃度のみスタックで増やす
    auraRing([120, 200, 255], stMissile, 1.10); // MISSILE
    auraRing([255, 200, 120], stDouble,  1.08); // DOUBLE
    auraRing([190, 140, 255], stLaser,   1.14); // LASER
    auraRing([255, 240, 140], stOption,  1.06); // OPTION
    auraRing([54,  211, 153], stShield,  1.18); // SHIELD
    // ===== /Stack Aura =====

    if (shipImgReady && shipImg && shipImg.naturalWidth > 0) {
      ctx.drawImage(shipImg, -dw*0.5, -(dh*V_SCALE)*0.5, dw, dh*V_SCALE);
    // Shield Down text
    if (player.shieldDownTimer > 0) {
      ctx.save();
      ctx.globalAlpha = Math.min(1, player.shieldDownTimer);
      ctx.fillStyle = "rgba(255,60,60,0.95)";
      ctx.font = "bold 18px sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("SHIELD -1", player.x, player.y - (player.h || 12) - 18);
      ctx.restore();
    }

} else {
      // fallback: vector ship scaled to match sprite size
      ctx.scale(SPRITE_SCALE, SPRITE_SCALE * V_SCALE);
ctx.fillStyle = "#c9d3ff";
      ctx.beginPath();
      ctx.moveTo(-18, -10);
      ctx.lineTo(16, 0);
      ctx.lineTo(-18, 10);
      ctx.closePath();
      ctx.fill();

      ctx.fillStyle = "#7ea2ff";
      ctx.fillRect(-10, -4, 10, 8);

      ctx.fillStyle = "#9fb6ff";
      ctx.beginPath();
      ctx.moveTo(-8, -10);
      ctx.lineTo(0, -2);
      ctx.lineTo(-8, 0);
      ctx.closePath();
      ctx.fill();

      // engine glow
      ctx.globalAlpha = 0.85;
      ctx.fillStyle = "#5de0ff";
      ctx.beginPath();
      ctx.arc(16, 0, 5, 0, TAU);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.restore();

    // ===== Shield VFX (always-on + gain/hit pulse) =====
    if ((player.shield|0) > 0) {
      const t = performance.now() * 0.006;
      const _sh = (player.shield|0);
      const _shCap = Math.min(_sh, 12);
      const baseA = 0.10 + _shCap * 0.018;
      const pulse = Math.max(0, player.shieldPulse || 0);
      const a = Math.min(0.55, baseA + pulse * 0.9 + (Math.sin(t) * 0.03));
      const wob = 0.06 + pulse * 0.10;

      ctx.save();
      ctx.globalAlpha = a;
      ctx.lineWidth = 2.5 + pulse * 3.0;
      {
        const lvl = player.shield || 1;
        const hue = 190 + lvl * 12;
        const _shLight = Math.max(42, 65 - _shCap * 2);
        ctx.strokeStyle = `hsl(${hue},80%,${_shLight}%)`;
    }

      // Elliptical shield fits side-view ship; slight breathing/wobble.
      const rx = player.w * 2.0 * 0.78 * (1 + Math.sin(t) * wob);
      const ry = player.h * 2.0 * 0.78 * (1 - Math.sin(t * 1.3) * wob);

      ctx.beginPath();
      ctx.ellipse(player.x, player.y, rx, ry, 0, 0, TAU);
      ctx.stroke();

      // inner faint ring for depth
      ctx.globalAlpha *= 0.55;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.ellipse(player.x, player.y, rx * 0.82, ry * 0.82, 0, 0, TAU);
      ctx.stroke();

      ctx.restore();
    }

    ctx.globalAlpha = prevAlpha;
  }

    function drawOptions() {
      if (!player || player.options <= 0) return;

      const now = (typeof performance !== "undefined" ? performance.now() : Date.now()) * 0.002;

      const _op = (player.options|0);
      const _opCap = Math.min(_op, 12);
      const _opDark = _opCap * 1.6;
      const _opA = Math.min(0.95, 0.55 + _opCap * 0.03);

      for (let i = 0; i < player.options; i++) {
        const p = optionPos[i];
        if (!p) continue;

        // 1..10: deepen purple; clamp after 10
        const step = Math.min(i, 9);
        const hue = 275;

        const r = 12;
        const ringLight = Math.max(28, (60 - step * 3) - _opDark);
        const coreLight = Math.max(36, (82 - step * 2) - _opDark);

        ctx.save();
        ctx.translate(p.x, p.y);

        // slow spin for "orbital bit" feel
        ctx.rotate(now + i * 0.55);

        // outer ring
        ctx.strokeStyle = `hsla(${hue}, 90%, ${ringLight}%, ${_opA})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, TAU);
        ctx.stroke();

        // segmented inner ring
        ctx.lineWidth = 2;
        for (let a = 0; a < 4; a++) {
          ctx.beginPath();
          ctx.arc(0, 0, r * 0.70, a * (TAU / 4), a * (TAU / 4) + 0.70);
          ctx.stroke();
        }

        // glowing core (core only glows)
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.shadowBlur = 12 + step;
        ctx.shadowColor = `hsla(${hue}, 100%, ${coreLight}%, ${_opA})`;
        ctx.fillStyle = `hsla(${hue}, 100%, ${coreLight}%, ${_opA})`;
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.35, 0, TAU);
        ctx.fill();
        ctx.restore();

        ctx.restore();
      }
    }

  function drawShots() {
    const tt = performance.now() * 0.001;
    const laserLvl = (player.laserLevel|0);
    const laserHue = (200 + laserLvl * 24) % 360;
    const lp = (player.laserPulse > 0) ? (player.laserPulse / 0.65) : 0;

    // Laser beam (continuous)
    if (player.laserOn) {
      const x0 = player.x + 22;
      const x1 = W + 20;
      const y = player.y;
      const flick = 0.75 + 0.25*Math.sin(tt*38 + y*0.03);
      const outerH = 14 * flick;
      const innerH = 5.0;

      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      // Outer glow
      const _laserCap = Math.min((player.laserLevel|0), 12);
      const _laserOuterA = (0.22 + _laserCap * 0.03);
      ctx.globalAlpha = _laserOuterA * flick;
      ctx.fillStyle = `hsla(${laserHue}, 95%, 60%, 1)`;
      ctx.fillRect(x0, y - outerH*0.5, x1 - x0, outerH);

      // Core
      const _laserCoreA = Math.min(1.0, 0.78 + _laserCap * 0.04);
      ctx.globalAlpha = _laserCoreA;
      const g = ctx.createLinearGradient(x0, y, x1, y);
      g.addColorStop(0.0, `hsla(${laserHue}, 95%, 60%, 0.00)`);
      g.addColorStop(0.08, `hsla(${laserHue}, 95%, 62%, ${0.75 + 0.20*lp})`);
      g.addColorStop(0.18, "rgba(255,255,255,1.00)");
      g.addColorStop(0.92, `hsla(${laserHue}, 95%, 62%, ${0.75 + 0.20*lp})`);
      g.addColorStop(1.0, `hsla(${laserHue}, 95%, 60%, 0.00)`);
      ctx.fillStyle = g;
      ctx.fillRect(x0, y - innerH*0.5, x1 - x0, innerH);

      ctx.restore();
    }

    // Option lasers
    if (player.optionLaserOn > 0) {
      for (let i=0;i<player.optionLaserOn;i++) {
        const p = optionPos[i];
        const x0 = p.x + 18;
        const x1 = W + 20;
        const y = p.y;
        const flick = 0.75 + 0.25*Math.sin(tt*38 + y*0.03 + i*1.7);
        const outerH = 12 * flick;
        const innerH = 4.5;

        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = 0.28 * flick;
        ctx.fillStyle = `hsla(${laserHue}, 95%, 60%, 1)`;
        ctx.fillRect(x0, y - outerH*0.5, x1 - x0, outerH);

        ctx.globalAlpha = 0.88;
        const g = ctx.createLinearGradient(x0, y, x1, y);
        g.addColorStop(0.0, `hsla(${laserHue}, 95%, 60%, 0.00)`);
        g.addColorStop(0.10, `hsla(${laserHue}, 95%, 60%, ${0.68 + 0.18*lp})`);
        g.addColorStop(0.20, "rgba(255,255,255,0.92)");
        g.addColorStop(0.90, `hsla(${laserHue}, 95%, 60%, ${0.68 + 0.18*lp})`);
        g.addColorStop(1.0, `hsla(${laserHue}, 95%, 60%, 0.00)`);
        ctx.fillStyle = g;
        ctx.fillRect(x0, y - innerH*0.5, x1 - x0, innerH);

        ctx.restore();
      }
    }

    // Player normal shots (DOUBLE stacks tint + glow)
    for (const s of shots) {
      if (!s.active) continue;
      const hue = s.hue;
      if (hue == null) {
      // Distinct colors: normal = white, double = magenta
      if (s.kind === "double") {
        const lvl = player.doubleLevel || 1;
        const cap = Math.min(lvl, 12);
        const hue = 300 + lvl * 8;  // shift toward purple with power
        const glowA = Math.min(0.65, 0.22 + cap * 0.04);
        const coreA = Math.min(1.00, 0.70 + cap * 0.05);
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = glowA;
        ctx.fillStyle = `hsl(${hue},90%,60%)`;
        ctx.fillRect(s.x-10, s.y-4, 20, 8);
        ctx.globalAlpha = coreA;
        ctx.fillStyle = `hsl(${hue},100%,75%)`;
        ctx.fillRect(s.x-6, s.y-1.5, 12, 3);
        ctx.restore();
      } else {
        ctx.fillStyle = "rgba(231,236,255,0.95)";
        ctx.fillRect(s.x-6, s.y-1.5, 12, 3);
      }
      } else {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = 0.32;
        ctx.fillStyle = `hsla(${hue}, 95%, 62%, 1)`;
        ctx.fillRect(s.x-10, s.y-4, 20, 8);
        ctx.globalAlpha = 0.92;
        ctx.fillStyle = `hsla(${hue}, 95%, 72%, 1)`;
        ctx.fillRect(s.x-6, s.y-1.5, 12, 3);
        ctx.restore();
      }
    }

    // Missiles (stacking color + stronger glow)
    for (const m of missiles) {
      if (!m.active) continue;
      // Missile gravity: slight downward drift (stacking weapons still guide within terrain)
      m.vy = clamp((m.vy||0) + 32*_dtRender, -240, 240);
      const lvl = (player.missileLevel||1);
      const cap = Math.min(lvl, 12);
      const hue = 180 + lvl * 10;
      const glowA = Math.min(0.70, 0.20 + cap * 0.045);
      const coreA = Math.min(1.00, 0.68 + cap * 0.045);
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      // glow
      ctx.globalAlpha = glowA;
      ctx.fillStyle = `hsla(${hue}, 95%, 60%, 1)`;
      ctx.fillRect(m.x-9, m.y-5, 18, 10);
      // core
      ctx.globalAlpha = coreA;
      ctx.fillStyle = `hsla(${hue}, 95%, 70%, 1)`;
      ctx.fillRect(m.x-5, m.y-2, 10, 4);
      ctx.restore();
    }

    // Enemy bullets
    ctx.fillStyle = "rgba(255,75,75,0.92)";
    for (const b of enemyShots) {
      if (!b.active) continue;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, TAU);
      ctx.fill();
    }
  }



  function drawEnemies() {
    const tt = performance.now() * 0.001;
    for (const e of enemies) {
      if (!e.active) continue;

      // 共有：簡易メタル質感
      function metalFill(x, y, w, h, a0=0.75, a1=0.18) {
        const g = ctx.createLinearGradient(x, y-h*0.4, x, y+h*0.6);
        g.addColorStop(0, `rgba(231,236,255,${a0})`);
        g.addColorStop(0.35, `rgba(140,170,210,${a1})`);
        g.addColorStop(1, `rgba(231,236,255,${a0*0.55})`);
        ctx.fillStyle = g;
      }
      function glowCore(x,y,r,alpha=0.85){
        const g = ctx.createRadialGradient(x,y,0,x,y,r*1.4);
        g.addColorStop(0, `rgba(255,75,75,${alpha})`);
        g.addColorStop(0.45, `rgba(255,75,75,${alpha*0.35})`);
        g.addColorStop(1, `rgba(255,75,75,0)`);
        ctx.fillStyle=g;
        ctx.beginPath(); ctx.arc(x,y,r*1.2,0,TAU); ctx.fill();
        ctx.fillStyle=`rgba(255,75,75,${alpha})`;
        ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
      }
      function thruster(x,y,scale=1){
        const p = 0.5 + 0.5*Math.sin(tt*10 + x*0.03);
        const len = (18 + 10*p) * scale;
        const g = ctx.createLinearGradient(x, y, x-len, y);
        g.addColorStop(0, `rgba(120,200,255,${0.55+0.25*p})`);
        g.addColorStop(0.6, `rgba(120,200,255,${0.15+0.15*p})`);
        g.addColorStop(1, `rgba(120,200,255,0)`);
        ctx.fillStyle=g;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x-len, y-6*scale);
        ctx.lineTo(x-len, y+6*scale);
        ctx.closePath();
        ctx.fill();
      }


      function bolt(x,y,r=1.2,a=0.45){
        ctx.fillStyle=`rgba(231,236,255,${a})`;
        ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
        ctx.strokeStyle=`rgba(0,0,0,${a*0.35})`;
        ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(x-r*0.6,y); ctx.lineTo(x+r*0.6,y); ctx.stroke();
      }
      function panelLines(points, a=0.22){
        ctx.strokeStyle=`rgba(0,0,0,${a})`;
        ctx.lineWidth=1;
        ctx.beginPath();
        for(const [x1,y1,x2,y2] of points){ ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); }
        ctx.stroke();
      }
      function hazardStripe(x,y,w,h,phase=0){
        ctx.save();
        ctx.translate(x,y);
        ctx.beginPath(); ctx.roundRect(-w/2,-h/2,w,h,4); ctx.clip();
        ctx.globalAlpha=0.55;
        ctx.rotate(-0.45);
        ctx.fillStyle="rgba(255,220,140,0.85)";
        for(let i=-w*2;i<w*2;i+=10){
          ctx.fillRect(i+phase, -h*2, 5, h*4);
        }
        ctx.globalAlpha=1;
        ctx.restore();
      }

      ctx.save();
      ctx.translate(e.x, e.y);

      if (e.ai === "turret") {
        // 角型砲台：メタル面＋砲身＋赤いコア
        metalFill(-16, -16, 32, 32, 0.75, 0.22);
        ctx.beginPath();
        ctx.roundRect(-16,-16,32,32,8);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.28)";
        ctx.lineWidth=2;
        ctx.stroke();

        // 面取り＆パネルライン
        ctx.strokeStyle="rgba(0,0,0,0.22)";
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-12,-6); ctx.lineTo(12,-6);
        ctx.moveTo(-12,6); ctx.lineTo(12,6);
        ctx.stroke();

        // 砲身
        ctx.fillStyle="rgba(231,236,255,0.22)";
        ctx.fillRect(-2,-4,20,8);
        ctx.strokeStyle="rgba(231,236,255,0.25)";
        ctx.strokeRect(-2,-4,20,8);

        glowCore(0,0,4,0.9);
        // ボルト＆警告ストライプ
        bolt(-10,-10,1.2,0.40); bolt(10,-10,1.2,0.40); bolt(-10,10,1.2,0.40); bolt(10,10,1.2,0.40);
        hazardStripe(-6,0,10,20, (tt*40)%10);

      } else if (e.ai === "droneSine") {
        // ドローン：船体＋キャノピー＋翼灯（メカ寄り強化）
        metalFill(-22,-14,44,28,0.62,0.18);
        ctx.beginPath();
        ctx.ellipse(0,0,20,12,0,0,TAU);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.25)";
        ctx.lineWidth=2;
        ctx.stroke();

        // キャノピー
        const cg = ctx.createRadialGradient(6,-3,2,6,-3,12);
        cg.addColorStop(0,"rgba(120,200,255,0.55)");
        cg.addColorStop(1,"rgba(120,200,255,0.05)");
        ctx.fillStyle=cg;
        ctx.beginPath();
        ctx.ellipse(6,-3,10,7,0.15,0,TAU);
        ctx.fill();

        // 翼
        ctx.fillStyle="rgba(231,236,255,0.10)";
        ctx.beginPath();
        ctx.moveTo(-6,0); ctx.lineTo(-22,-10); ctx.lineTo(-18,0); ctx.lineTo(-22,10);
        ctx.closePath();
        ctx.fill();

        // 追加：装甲プレート＆ベント
        ctx.fillStyle='rgba(0,0,0,0.18)';
        ctx.beginPath();
        ctx.moveTo(2,-10); ctx.lineTo(18,-6); ctx.lineTo(12,-1); ctx.lineTo(-2,-3);
        ctx.closePath(); ctx.fill();
        panelLines([[-12,-2,12,-2],[-6,6,10,6],[4,-8,10,0]],0.20);
        bolt(-8,0,1.1,0.38); bolt(8,0,1.1,0.38);
        ctx.fillStyle='rgba(231,236,255,0.12)'; ctx.fillRect(-16,-2,6,4);
        ctx.fillStyle='rgba(0,0,0,0.28)'; ctx.fillRect(-15,-1,4,2);

        // 翼灯（点滅）
        const blink = 0.35 + 0.35*(0.5+0.5*Math.sin(tt*6 + e.y*0.02));
        ctx.fillStyle=`rgba(54,211,153,${blink})`;
        ctx.beginPath(); ctx.arc(14,0,2.6,0,TAU); ctx.fill();

      
      } else if (e.ai === "hookDive") {
        // HOOK-DIVE Mk.II: mechanical interceptor (magenta)
        const ang = e._ang || 0;
        ctx.rotate(ang);

        // body base
        const g = ctx.createLinearGradient(-24, -10, 20, 10);
        g.addColorStop(0, "rgba(59,15,46,0.78)");   // deep magenta
        g.addColorStop(0.55, "rgba(20,8,18,0.55)");
        g.addColorStop(1, "rgba(231,236,255,0.12)");
        ctx.fillStyle = g;

        // delta-wing silhouette
        ctx.beginPath();
        ctx.moveTo(22, 0);
        ctx.lineTo(2, -12);
        ctx.lineTo(-22, -6);
        ctx.lineTo(-16, 0);
        ctx.lineTo(-22, 6);
        ctx.lineTo(2, 12);
        ctx.closePath();
        ctx.fill();

        // edge highlight (danger)
        ctx.strokeStyle = "rgba(255,42,138,0.85)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // core (state intensity)
        const state = (e.p || 0);
        const coreA = (state===2) ? 0.95 : (state===1 ? 0.75 : 0.55);
        ctx.save();
        ctx.shadowColor = `rgba(255,91,192,${0.55+0.25*coreA})`;
        ctx.shadowBlur = 10 + (state===2 ? 10 : (state===1 ? 6 : 2));
        ctx.fillStyle = `rgba(255,91,192,${0.55+0.35*coreA})`;
        ctx.beginPath(); ctx.ellipse(4,0,5.5,3.8,0,0,TAU); ctx.fill();
        ctx.restore();

        // rear thruster flash during dive
        if (state === 2) {
          const p = 0.5 + 0.5*Math.sin(tt*18 + e.y*0.02);
          const len = 16 + 10*p;
          const tg = ctx.createLinearGradient(-20,0,-20-len,0);
          tg.addColorStop(0, `rgba(168,77,255,${0.55+0.25*p})`);
          tg.addColorStop(0.7, `rgba(168,77,255,${0.12+0.12*p})`);
          tg.addColorStop(1, "rgba(168,77,255,0)");
          ctx.fillStyle = tg;
          ctx.beginPath();
          ctx.moveTo(-20,0);
          ctx.lineTo(-20-len, -5);
          ctx.lineTo(-20-len, 5);
          ctx.closePath();
          ctx.fill();
        }

} else if (e.ai === "charger") {
        // 突撃機：尖った機首＋可動フィン

        // 突進機：鋭い機首＋エンジン
        metalFill(-18,-10,36,20,0.58,0.16);
        ctx.beginPath();
        ctx.moveTo(18,0);
        ctx.lineTo(2,-12);
        ctx.lineTo(-18,-8);
        ctx.lineTo(-18,8);
        ctx.lineTo(2,12);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.22)";
        ctx.lineWidth=2;
        ctx.stroke();

        // コクピット
        ctx.fillStyle="rgba(120,200,255,0.18)";
        ctx.beginPath(); ctx.ellipse(4,0,6,4,0,0,TAU); ctx.fill();

        // 推進炎
        thruster(-18,0,0.9);

      } else if (e.ai === "armored") {
        // 装甲艇：角張った装甲＋キャタピラ風パーツ

        // 装甲機：重装甲パネル＋コア
        metalFill(-26,-18,52,36,0.55,0.14);
        ctx.beginPath();
        ctx.roundRect(-24,-16,48,32,10);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.20)";
        ctx.lineWidth=2;
        ctx.stroke();

        // 装甲パネル
        ctx.strokeStyle="rgba(0,0,0,0.25)";
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-18,-6); ctx.lineTo(18,-6);
        ctx.moveTo(-18,6); ctx.lineTo(18,6);
        ctx.moveTo(-6,-12); ctx.lineTo(-6,12);
        ctx.stroke();

        // コア
        ctx.fillStyle="rgba(54,211,153,0.22)";
        ctx.beginPath(); ctx.roundRect(-10,-7,20,14,6); ctx.fill();
        ctx.strokeStyle="rgba(54,211,153,0.35)";
        ctx.stroke();
        thruster(-24,0,0.75);

      } else if (e.ai === "slime") {
        // メカマイン：球体装甲＋スポーク

        // 有機体：粘膜の層（グラデ＋縁）
        const g = ctx.createRadialGradient(-6,-6,4,0,0,22);
        g.addColorStop(0,"rgba(255,120,120,0.28)");
        g.addColorStop(0.55,"rgba(255,75,75,0.18)");
        g.addColorStop(1,"rgba(255,75,75,0.06)");
        ctx.fillStyle=g;
        ctx.beginPath();
        const wob = 1.0 + 0.06*Math.sin(tt*5 + e.x*0.01);
        ctx.arc(0,0,16*wob,0,TAU);
        ctx.fill();
        ctx.strokeStyle="rgba(255,120,120,0.28)";
        ctx.lineWidth=2;
        ctx.stroke();
        // ハイライト
        ctx.fillStyle="rgba(231,236,255,0.10)";
        ctx.beginPath(); ctx.ellipse(-4,-6,7,4, -0.2, 0, TAU); ctx.fill();

      } else if (e.ai === "midboss") {
        // 中ボス：大型メタル＋派手エフェクト（コア脈動／シールドリング／走査光）
        metalFill(-160,-120,260,240,0.40,0.10);
        ctx.beginPath();
        ctx.roundRect(-150,-110,240,220,18);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.18)";
        ctx.lineWidth=3;
        ctx.stroke();

        // パネルライン
        ctx.strokeStyle="rgba(0,0,0,0.22)";
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-120,-60); ctx.lineTo(70,-60);
        ctx.moveTo(-120,60); ctx.lineTo(70,60);
        ctx.moveTo(-60,-100); ctx.lineTo(-60,100);
        ctx.stroke();

        // 追加：外周エッジ発光（走査）
        {
          const scan = 0.5 + 0.5*Math.sin(tt*3.2 + e.t*0.8);
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = 0.25 + 0.18*scan;
          const eg = ctx.createLinearGradient(-150,-110, 90,110);
          eg.addColorStop(0.0, "rgba(120,200,255,0.05)");
          eg.addColorStop(0.5, "rgba(120,200,255,0.22)");
          eg.addColorStop(1.0, "rgba(255,220,140,0.10)");
          ctx.strokeStyle = eg;
          ctx.lineWidth = 6;
          ctx.beginPath(); ctx.roundRect(-150,-110,240,220,18); ctx.stroke();
          ctx.restore();
        }

        const open = (e.p >= 1);
        const coreAlpha = open ? 0.95 : 0.30;

        // コア（上下2基）＋リング発光
        function ring(x,y,r,ph){
          const a = 0.45 + 0.35*Math.sin(tt*6.0 + ph + e.t*1.2);
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = a;
          ctx.strokeStyle = "rgba(120,200,255,0.35)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          const t0 = (tt*2.6 + ph) % TAU;
          ctx.arc(x,y,r, t0, t0 + Math.PI*1.35);
          ctx.stroke();
          ctx.globalAlpha = a*0.6;
          ctx.strokeStyle = "rgba(255,220,140,0.22)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x,y,r+7, t0+1.7, t0+1.7 + Math.PI*1.05);
          ctx.stroke();
          ctx.restore();
        }

        glowCore(40,-55,18,coreAlpha);
        glowCore(40,55,18,coreAlpha);
        ring(40,-55,24,0.3);
        ring(40,55,24,2.0);

        // 追加：コア間のエネルギーアーク（開放時だけ）
        if (open) {
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = 0.22 + 0.18*(0.5+0.5*Math.sin(tt*10.0 + e.t*2.0));
          ctx.strokeStyle = "rgba(120,200,255,0.55)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          for (let i=0;i<3;i++){
            const k = i/2;
            const wob = 6*Math.sin(tt*7 + k*4 + e.t*1.3);
            ctx.moveTo(40 + wob, -55 + 10);
            ctx.quadraticCurveTo(30 - wob, 0, 40 + wob, 55 - 10);
          }
          ctx.stroke();
          ctx.restore();
        }

        // 閉鎖シャッター
        if (!open) {
          ctx.fillStyle="rgba(231,236,255,0.14)";
          ctx.beginPath(); ctx.roundRect(14,-85,52,60,10); ctx.fill();
          ctx.beginPath(); ctx.roundRect(14,25,52,60,10); ctx.fill();
        }

        // 追加：周囲シールドリング（常時・薄く）
        {
          const pulse = 0.5 + 0.5*Math.sin(tt*2.2 + e.t*0.9);
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = 0.10 + 0.10*pulse;
          ctx.strokeStyle = "rgba(54,211,153,0.35)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(-20,0, 155, 105, 0, 0, TAU);
          ctx.stroke();
          ctx.globalAlpha *= 0.65;
          ctx.strokeStyle = "rgba(120,200,255,0.25)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(-20,0, 165, 115, 0, 0, TAU);
          ctx.stroke();
          ctx.restore();
        }

        // サイドスラスター
        thruster(-150,-55,1.2);
        thruster(-150,55,1.2);

        // 追加：警告灯（点滅）
        {
          const blink = 0.25 + 0.55*(0.5+0.5*Math.sin(tt*8.0 + e.t*2.8));
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = blink;
          ctx.fillStyle="rgba(255,75,75,0.45)";
          ctx.beginPath(); ctx.arc(-120,-85,4.2,0,TAU); ctx.fill();
          ctx.beginPath(); ctx.arc(-120,85,4.2,0,TAU); ctx.fill();
          ctx.restore();
        }

      } else if (e.ai === "boss") {
        // ボス：巨大艦体＋派手エフェクト（コア多層／シールド／走査ライン強化）
        metalFill(-260,-170,420,340,0.32,0.08);
        ctx.beginPath();
        ctx.roundRect(-250,-160,400,320,24);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.14)";
        ctx.lineWidth=4;
        ctx.stroke();

        // 追加：外装の発光パネル（脈動）
        {
          const p = 0.5 + 0.5*Math.sin(tt*2.4 + e.t*0.9);
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = 0.10 + 0.10*p;
          ctx.fillStyle="rgba(120,200,255,0.18)";
          ctx.beginPath(); ctx.roundRect(-220,-120,70,52,12); ctx.fill();
          ctx.beginPath(); ctx.roundRect(-220,68,70,52,12); ctx.fill();
          ctx.restore();
        }

        // サイドユニット
        ctx.fillStyle="rgba(231,236,255,0.10)";
        ctx.beginPath(); ctx.roundRect(-210,-130,44,44,10); ctx.fill();
        ctx.beginPath(); ctx.roundRect(-210,86,44,44,10); ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.16)";
        ctx.lineWidth=2;
        ctx.strokeRect(-210,-130,44,44);
        ctx.strokeRect(-210,86,44,44);

        const coreOpen = (e.p >= 1);
        const a = coreOpen ? 0.95 : 0.30;

        // コア：多層グロー＋回転リング
        {
          const pulse = 0.55 + 0.45*Math.sin(tt*4.2 + e.t*1.1);
          ctx.save();
          ctx.globalCompositeOperation="lighter";

          // outer halo
          ctx.globalAlpha = (coreOpen ? 0.28 : 0.14) + 0.10*pulse;
          const g = ctx.createRadialGradient(70,0,8, 70,0, 70);
          g.addColorStop(0.0, "rgba(255,75,75,0.55)");
          g.addColorStop(0.35,"rgba(255,75,75,0.20)");
          g.addColorStop(1.0, "rgba(255,75,75,0.00)");
          ctx.fillStyle = g;
          ctx.beginPath(); ctx.arc(70,0, 62, 0, TAU); ctx.fill();

          // core
          glowCore(70,0, coreOpen ? 24 : 16, a);

          // rotating rings
          const t0 = (tt*2.1 + e.t*0.6) % TAU;
          ctx.globalAlpha = 0.32 + 0.18*pulse;
          ctx.strokeStyle = "rgba(120,200,255,0.45)";
          ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(70,0, 34, t0, t0 + Math.PI*1.35); ctx.stroke();
          ctx.globalAlpha *= 0.7;
          ctx.strokeStyle = "rgba(255,220,140,0.30)";
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(70,0, 44, t0+1.3, t0+1.3 + Math.PI*1.10); ctx.stroke();

          ctx.restore();
        }

        // 排気（強化）
        thruster(-250,-90,1.7);
        thruster(-250,0,1.7);
        thruster(-250,90,1.7);

        // 追加：ボス全体シールド（フェーズで強度変化）
        {
          const sh = 0.5 + 0.5*Math.sin(tt*1.9 + e.t*0.8);
          const base = coreOpen ? 0.14 : 0.08;
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = base + 0.10*sh;
          ctx.strokeStyle = "rgba(120,200,255,0.28)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.ellipse(-60,0, 235, 160, 0, 0, TAU);
          ctx.stroke();
          ctx.globalAlpha *= 0.6;
          ctx.strokeStyle = "rgba(54,211,153,0.22)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(-60,0, 248, 172, 0, 0, TAU);
          ctx.stroke();
          ctx.restore();
        }

        // 掃射ライン演出（強化：二重ライン＋閃光）
        if (e.p >= 1 && e.t % 3.2 < 0.8) {
          const k = (e.t % 3.2) / 0.8;
          const yL = lerp(-140, 140, k);

          ctx.save();
          ctx.globalCompositeOperation = "lighter";

          ctx.globalAlpha = 0.18;
          ctx.strokeStyle = "rgba(255,75,75,0.35)";
          ctx.lineWidth = 10;
          ctx.beginPath();
          ctx.moveTo(-230, yL);
          ctx.lineTo(130, yL);
          ctx.stroke();

          ctx.globalAlpha = 0.30;
          ctx.strokeStyle = "rgba(255,220,140,0.25)";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(-230, yL);
          ctx.lineTo(130, yL);
          ctx.stroke();

          // flash at core
          ctx.globalAlpha = 0.22;
          ctx.fillStyle = "rgba(255,220,140,0.22)";
          ctx.beginPath(); ctx.arc(70,0, 46, 0, TAU); ctx.fill();

          ctx.restore();
        }

        // 追加：点滅警告灯
        {
          const blink = 0.22 + 0.58*(0.5+0.5*Math.sin(tt*7.6 + e.t*2.9));
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = blink;
          ctx.fillStyle="rgba(255,75,75,0.40)";
          ctx.beginPath(); ctx.arc(-170,-130,4.5,0,TAU); ctx.fill();
          ctx.beginPath(); ctx.arc(-170,130,4.5,0,TAU); ctx.fill();
          ctx.beginPath(); ctx.arc(-40,-150,3.8,0,TAU); ctx.fill();
          ctx.beginPath(); ctx.arc(-40,150,3.8,0,TAU); ctx.fill();
          ctx.restore();
        }

      } else {
        // Fallback: lightweight interceptor drone (was a gray square)
        const r = Math.max(10, (e.r ?? 16) * 0.9);
        // body (diamond)
        ctx.save();
        ctx.rotate((e.t*0.9 + e.p*0.3) * 0.35);
        ctx.fillStyle = "rgba(28,34,64,0.85)";
        ctx.beginPath();
        ctx.moveTo( r, 0);
        ctx.lineTo( 0, 0.75*r);
        ctx.lineTo(-r, 0);
        ctx.lineTo( 0,-0.75*r);
        ctx.closePath();
        ctx.fill();

        // rim
        ctx.strokeStyle = "rgba(200,210,255,0.20)";
        ctx.lineWidth = 2;
        ctx.stroke();

        // core
        ctx.globalCompositeOperation = "lighter";
        ctx.shadowColor = "rgba(160,90,255,0.85)";
        ctx.shadowBlur = 10;
        ctx.fillStyle = "rgba(160,90,255,0.55)";
        ctx.beginPath(); ctx.arc(0,0, r*0.28, 0, TAU); ctx.fill();

        // tiny thruster (rear)
        ctx.shadowBlur = 8;
        ctx.fillStyle = "rgba(120,200,255,0.35)";
        ctx.beginPath();
        ctx.ellipse(-r*0.75, 0, r*0.20, r*0.12, 0, 0, TAU);
        ctx.fill();

        ctx.restore();
      }

      ctx.restore();

      if (e.ai === "midboss" || e.ai === "boss") {
        const max = (e.maxHp !== undefined ? e.maxHp : (e.ai==="midboss" ? 220 : 520));

        // 進捗バー(#progressWrap)と見た目（長さ/太さ）を合わせる
        const w = Math.min(560, W * 0.72);
        const h = 18;
        const x = (W - w) / 2;
        const y = 18 + h + 6; // progressWrap(top=18px, height=18px) の下段

        // ratio: 1.0(full) -> 0.0(dead)
        const r = clamp(e.hp, 0, max) / max;

        // HPが減るほど 緑→黄→赤（HSL 120→0）
        const hue = 120 * r;
        const fill = `hsla(${hue.toFixed(0)}, 85%, 55%, 0.65)`;

        // rounded rect helper
        const rr = (x, y, w, h, rad) => {
          const r = Math.min(rad, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x + r, y);
          ctx.arcTo(x + w, y, x + w, y + h, r);
          ctx.arcTo(x + w, y + h, x, y + h, r);
          ctx.arcTo(x, y + h, x, y, r);
          ctx.arcTo(x, y, x + w, y, r);
          ctx.closePath();
        };

        rr(x, y, w, h, 999);
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.fill();

        rr(x, y, w * r, h, 999);
        ctx.fillStyle = fill;
        ctx.fill();

        rr(x, y, w, h, 999);
        ctx.strokeStyle = "rgba(255,255,255,0.12)";
        ctx.lineWidth = 1;
        ctx.stroke();
      }
    }
  }

  function drawCapsules() {
    for (const c of capsules) {
      if (!c.active) continue;

      const step = (c.step|0) || 1;

      // +1: normal (no glow) / +2: cyan glow / +3: purple strong glow
      let fill = "rgba(54,211,153,0.26)";
      let stroke = "rgba(54,211,153,0.72)";
      let glow = null;

      if (step === 2) {
        fill = "rgba(120,200,255,0.26)";
        stroke = "rgba(120,200,255,0.78)";
        glow = "rgba(120,200,255,0.95)";
      }
      if (step >= 3) {
        fill = "rgba(190,140,255,0.26)";
        stroke = "rgba(190,140,255,0.82)";
        glow = "rgba(190,140,255,0.98)";
      }

      ctx.save();

      // Glow only for +2 and +3
      if (glow) {
        ctx.globalCompositeOperation = "lighter";
        ctx.shadowBlur = 10 + step * 4;
        ctx.shadowColor = glow;
      }

      ctx.fillStyle = fill;
      ctx.beginPath(); 
      ctx.arc(c.x, c.y, 12, 0, TAU); 
      ctx.fill();

      ctx.strokeStyle = stroke;
      ctx.lineWidth = 2.0 + step * 0.4;
      ctx.beginPath(); 
      ctx.arc(c.x, c.y, 12, 0, TAU); 
      ctx.stroke();

      // Center core
      ctx.shadowBlur = 0;
      ctx.fillStyle = "rgba(231,236,255,0.88)";
      ctx.fillRect(c.x-4, c.y-4, 8, 8);

      ctx.restore();

      // Display number only for +2/+3
      if (step >= 2) {
        ctx.save();
        ctx.fillStyle = "rgba(255,255,255,0.92)";
        ctx.font = "bold 12px sans-serif";
        ctx.textAlign = "center";
        ctx.fillText("+"+step, c.x, c.y + 4);
        ctx.restore();
      }
    }
  }


function drawFX() {
    for (const p of fx) {
      if (!p.active) continue;
      const a = clamp(p.ttl / 0.6, 0, 1);
      ctx.globalAlpha = a;
      if (p.kind === "spark") {
        ctx.fillStyle = "rgba(231,236,255,0.95)";
        ctx.fillRect(p.x, p.y, p.size, p.size);
      } else if (p.kind === "boom") {
        ctx.strokeStyle = "rgba(255,75,75,0.85)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, TAU);
        ctx.stroke();
      } else if (p.kind === "shield") {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const hue = p.hue ?? 160;
        const r = p.size ?? 34;
        const a2 = clamp(p.ttl / 0.55, 0, 1);
        ctx.lineWidth = 3 + (1-a2)*3;
        ctx.strokeStyle = `hsla(${hue}, 95%, 62%, ${0.28 + 0.22*a2})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r*(1.0 + (1-a2)*0.35), 0, TAU);
        ctx.stroke();
        ctx.restore();
      } else if (p.kind === "shieldSpark") {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const hue = p.hue ?? 200;
        ctx.fillStyle = `hsla(${hue}, 95%, 70%, 1)`;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.restore();
      } else if (p.kind === "weaponRing") {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const hue = p.hue ?? 160;
        const r = p.size ?? 30;
        const a2 = clamp(p.ttl / 0.55, 0, 1);
        ctx.lineWidth = 2 + (1-a2)*4;
        ctx.strokeStyle = `hsla(${hue}, 95%, 62%, ${0.22 + 0.26*a2})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r*(1.0 + (1-a2)*0.45), 0, TAU);
        ctx.stroke();
        ctx.restore();
      } else if (p.kind === "weaponSpark") {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const hue = p.hue ?? 200;
        ctx.fillStyle = `hsla(${hue}, 95%, 70%, 1)`;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        ctx.restore();

      } else if (p.kind === "popup") {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        const hue = p.hue ?? 200;
        const life = 0.85;
        const t = clamp(1 - (p.ttl / life), 0, 1);
        const s = (p.scale ?? 1) * (0.90 + 0.35 * Math.sin(t * Math.PI));
        const lift = 18 * t;

        ctx.translate(p.x, p.y - lift);
        ctx.scale(s, s);

        const big = String(p.lvl ?? "");
        const small = String(p.label ?? "");

        // glow
        ctx.shadowColor = `hsla(${hue}, 95%, 70%, 0.85)`;
        ctx.shadowBlur = 18;

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        // big number
        ctx.font = "900 44px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace";
        ctx.fillStyle = `hsla(${hue}, 95%, 68%, ${0.95})`;
        ctx.fillText(big, 0, 0);

        // outline for readability
        ctx.shadowBlur = 0;
        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(0,0,0,0.55)";
        ctx.strokeText(big, 0, 0);

        // label under
        ctx.font = '800 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif';
        ctx.fillStyle = `hsla(${hue}, 95%, 78%, ${0.95})`;
        ctx.fillText(small, 0, 34);

        ctx.restore();
      }
      ctx.globalAlpha = 1;
    }
  }

  
  // --- Cave corridor clamp for enemies (prevents unreachable low spawns) ---
  function clampEnemyToCaveCorridor(e, worldX) {
    try {
      if (!terrainHint || terrainHint.length === 0) return;
      const tile = 32;
      const idx = Math.max(0, Math.min(terrainHint.length - 1, Math.floor(worldX / tile)));
      const h = terrainHint[idx];
      const margin = 40; // keep enemies away from walls / floor blocks
      const top = h.ceilY + margin;
      const bottom = h.floorY - margin;
      if (!(top < bottom)) return;
      e.y = Math.max(top, Math.min(bottom, e.y));
    } catch (_) {}
  }
  // --- /Cave corridor clamp ---
function addEnemy(ai, x, y, params={}) {
    const e = enemyPool.get();
    e.active = true;
    e.x = x; e.y = y;
    e.vx = params.vx ?? -140;
    e.vy = params.vy ?? 0;
    e.r = params.r ?? 16;
    e.w = params.w ?? 32;
    e.h = params.h ?? 32;
    e.hp = params.hp ?? 3;
    e.score = params.score ?? 100;
    e.ai = ai;
    e.t = 0;
    e.p = params.p ?? 0;
    e.solid = params.solid ?? false;
    if (section === "C") clampEnemyToCaveCorridor(e, e.x);
    enemies.push(e);
    return e;
  }

  function addCapsule(x,y, minN=2, maxN=4, scatter=1, force=false) {
  // Drop burst: random count between minN..maxN, with scatter strength.
  const maxActive = 24;
  const activeN = capsules.filter(c=>c.active).length;
  if (!force && activeN >= maxActive) return;

  minN = Math.max(1, minN|0);
  maxN = Math.max(minN, maxN|0);
  scatter = Math.max(0.5, scatter);

  const want = minN + Math.floor(Math.random() * (maxN - minN + 1));
  const spawnN = force ? want : Math.min(want, maxActive - activeN);

  for (let i=0;i<spawnN;i++) {
    const c = capsulePool.get();
    c.active = true;

    // Drop grade: 5% +3 / 20% +2 / else +1
    const rr = Math.random();
    c.step = (rr < 0.05) ? 3 : (rr < 0.25) ? 2 : 1;
    const px = x + rand(-14, 14) * scatter;
    const py = y + rand(-14, 14) * scatter;
    c.x = clamp(px, 60, W-60);
    c.y = clamp(py, 60, H-60);

    const ang = Math.random() * TAU;
    const spd = (120 + rand(-40, 80)) * scatter;
    c.vx = Math.cos(ang) * spd;
    c.vy = Math.sin(ang) * spd;

    c.r = 10;
    c.ttl = Infinity;
    capsules.push(c);
  }
}


  function shieldBurstFX(x, y, lvl=1) {
    const hue = ((lvl|0) * 47) % 360;
    // ring
    const ring = fxPool.get();
    ring.active = true;
    ring.x = x;
    ring.y = y;
    ring.vx = 0;
    ring.vy = 0;
    ring.ttl = 0.55;
    ring.size = 28 + Math.min(22, Math.sqrt(lvl)*6);
    ring.kind = "shield";
    ring.hue = hue;
    fx.push(ring);

    // sparks
    const n = Math.min(18, 6 + Math.floor(Math.log2((lvl|0)+1) * 6));
    for (let i=0;i<n;i++) {
      const p = fxPool.get();
      p.active = true;
      p.x = x + rand(-8,8);
      p.y = y + rand(-8,8);
      p.vx = rand(-180, 180);
      p.vy = rand(-180, 180);
      p.ttl = 0.18 + Math.random()*0.22;
      p.size = 2.2 + Math.random()*2.2;
      p.kind = "shieldSpark";
      p.hue = (hue + 40 + i*12) % 360;
      fx.push(p);
    }
  }

  function weaponBoostFX(x, y, kind="weapon", lvl=1) {
    // Generic stacking-weapon enhancement burst (missile/double/laser pickup etc.)
    const baseHue = (kind === "missile") ? 120 : (kind === "double" ? 280 : 200);
    const hue = (baseHue + ((lvl|0) * 37)) % 360;

    const ring = fxPool.get();
    ring.active = true;
    ring.x = x; ring.y = y;
    ring.vx = 0; ring.vy = 0;
    ring.ttl = 0.55;
    ring.size = 26 + Math.min(28, Math.sqrt(Math.max(1,lvl))*7);
    ring.kind = "weaponRing";
    ring.hue = hue;
    fx.push(ring);

    const n = Math.min(28, 10 + Math.floor(Math.log2((lvl|0)+1) * 8));
    for (let i=0;i<n;i++) {
      const p = fxPool.get();
      p.active = true;
      p.x = x + rand(-10,10);
      p.y = y + rand(-10,10);
      const ang = Math.random()*TAU;
      const spd = 160 + Math.random()*220;
      p.vx = Math.cos(ang)*spd;
      p.vy = Math.sin(ang)*spd;
      p.ttl = 0.18 + Math.random()*0.28;
      p.size = 2.2 + Math.random()*2.4;
      p.kind = "weaponSpark";
      p.hue = (hue + 40 + i*9) % 360;
      fx.push(p);
    }
  }


  function powerLevelPopup(x, y, label, lvl, hue=200) {
    // Stylish level popup (brief) to show current stack level
    const p = fxPool.get();
    p.active = true;
    p.x = x;
    p.y = y - 34;
    p.vx = 0;
    p.vy = -52;
    p.ttl = 0.85;
    p.kind = "popup";
    p.hue = hue;
    p.label = label;
    p.lvl = lvl;
    p.scale = 1.0;
    fx.push(p);
  }


  function burstFX(x,y, n=10, kind="spark") {
    for (let i=0;i<n;i++) {
      const p = fxPool.get();
      p.active = true;
      p.x = x + rand(-6,6);
      p.y = y + rand(-6,6);
      p.vx = rand(-120, 120);
      p.vy = rand(-120, 120);
      p.ttl = 0.35 + Math.random()*0.35;
      p.size = 2 + Math.random()*2;
      p.kind = kind;
      fx.push(p);
    }


  // Big explosion for midboss/boss defeat (do not touch start logic; pure visuals)
  function megaExplosionFX(x, y, scale=1.0) {
    // multiple spark sprays
    for (let k=0;k<4;k++) {
      burstFX(x + rand(-18,18), y + rand(-18,18), Math.floor(26*scale), "spark");
    }
    // multiple boom rings
    for (let k=0;k<5;k++) {
      burstFX(x + rand(-28,28), y + rand(-28,28), Math.floor(16*scale), "boom");
    }
    // a few large, slow rings
    const bigN = 7 + Math.floor(4*scale);
    for (let i=0;i<bigN;i++) {
      const p = fxPool.get();
      p.active = true;
      p.x = x + rand(-40,40);
      p.y = y + rand(-30,30);
      p.vx = rand(-18,18);
      p.vy = rand(-18,18);
      p.ttl = 0.55 + Math.random()*0.55;
      p.size = (22 + Math.random()*52) * scale;
      p.kind = "boom";
      fx.push(p);
    }
    // brief screen flash using existing bossIntro flash channel (safe if bossIntro exists)
    try { bossIntroFlash(0.95); } catch (_) {}
  }

  }

  function fireEnemyShot(x,y, vx,vy, r=5, homing=0) {
    const b = enemyShotPool.get();
    b.active = true;
    b.x=x; b.y=y;
    b.vx=vx; b.vy=vy;
    b.r=r;
    b.ttl=7;
    b.homing = homing; // seconds to home
    b.spd = Math.hypot(vx,vy);
    enemyShots.push(b);
  }

  function fireAim(x,y, speed=220, spread=0) {
    const dx = (player.x - x), dy = (player.y - y);
    const ang = Math.atan2(dy, dx) + spread;
    fireEnemyShot(x,y, Math.cos(ang)*speed, Math.sin(ang)*speed, 5, 0);
  }

  function fireFan(x,y, speed=200, n=3, angCenter=Math.PI, angSpan=0.55) {
    if (n === 1) { fireEnemyShot(x,y, Math.cos(angCenter)*speed, Math.sin(angCenter)*speed, 5, 0); return; }
    for (let i=0;i<n;i++) {
      const t = (i/(n-1)) - 0.5;
      const a = angCenter + t*angSpan;
      fireEnemyShot(x,y, Math.cos(a)*speed, Math.sin(a)*speed, 5, 0);
    }
  }

  function fireRing(x,y, speed=170, n=12) {
    for (let i=0;i<n;i++) {
      const a = (i/n)*TAU;
      fireEnemyShot(x,y, Math.cos(a)*speed, Math.sin(a)*speed, 5, 0);
    }
  }

  function fireHomingLite(x,y, speed=170, homingSeconds=0.8) {
    const dx = (player.x - x), dy = (player.y - y);
    const ang = Math.atan2(dy, dx);
    fireEnemyShot(x,y, Math.cos(ang)*speed, Math.sin(ang)*speed, 5, homingSeconds);
  }

  function firePlayerShot(fromX, fromY, vx, vy, kind="shot", dmg=1, r=4, hue=null) {
    const s = shotPool.get();
    s.active = true;
    s.x = fromX; s.y = fromY;
    s.vx = vx; s.vy = vy;
    s.r = r;
    s.ttl = 2.0;
    s.kind = kind;
    s.dmg = dmg;
    s.hue = hue;
    shots.push(s);
  }

  function firePlayerMissile(fromX, fromY, dmg=2, hue=120) {
    const m = missilePool.get();
    m.active = true;
    m.x = fromX; m.y = fromY;
    m.vx = 360;
    m.vy = 0;
    m.r = 5;
    m.ttl = 2.2;
    m.trail = 0;
    m.dmg = dmg;
    m.hue = hue;
    if (missiles.filter(mm=>mm.active).length < 4) missiles.push(m);
  }

  function muzzleY(y){
  // Auto offset: tie to hitbox height so it scales with ship size.
  // Slightly lower than center to match side-view sprite.
  const h = (player && player.h) ? player.h : 12;
  const off = Math.round(h * 0.35);
  return y + off;
}

function doPlayerFire(dt) {
  const firing = isDown(["KeyZ","Space"]);
  const missileKey = isDown(["KeyX"]);
  const activateKey = isDown(["KeyC"]);

  if (activateKey && !doPlayerFire._cHeld) {
    activatePowerup();
  }
  doPlayerFire._cHeld = activateKey;

  // Laser is a continuous beam (not a projectile). Reset each frame.
  player.laserOn = false;
  player.optionLaserOn = 0;

  // Normal shots (single/double) use cooldown.
  player.fireCD = Math.max(0, player.fireCD - dt);
  if (firing && player.fireCD <= 0) {
    let cd = 0.12;

    const dblLvl = Math.max(1, (player.doubleLevel|0));
    const dblMul = 1 + 0.1 * (dblLvl - 1);
    const dblHue = ((dblLvl * 53) % 360);

    if (player.shotLevel === 0) {
      firePlayerShot(player.x+18, muzzleY(player.y), 520, 0, "shot", 1, 4);
    } else { // double
      firePlayerShot(player.x+18, muzzleY(player.y-5), 520, -40, "double", 1*dblMul, 4, null);
      firePlayerShot(player.x+18, muzzleY(player.y+5), 520, 40, "double", 1*dblMul, 4, null);
      cd = 0.14;

      // Enhanced muzzle effect for stacked DOUBLE
      for (let k=0;k<2;k++) {
        const p = fxPool.get();
        p.active = true;
        p.x = player.x+26 + rand(-2,2);
        p.y = player.y + (k===0?-6:6) + rand(-2,2);
        p.vx = rand(120, 240);
        p.vy = rand(-80, 80);
        p.ttl = 0.12 + Math.random()*0.10;
        p.size = 2.2 + Math.random()*2.2;
        p.kind = "weaponSpark";
        p.hue = 310;
        fx.push(p);
      }
    }

    for (let i=0;i<player.options;i++) {
      const p = optionPos[i];
      if (player.shotLevel === 0) {
        firePlayerShot(p.x+16, p.y, 520, 0, "shot", 0.7, 4);
      } else {
        firePlayerShot(p.x+16, p.y-5, 520, -40, "double", 0.7*dblMul, 4, null);
        firePlayerShot(p.x+16, p.y+5, 520, 40, "double", 0.7*dblMul, 4, null);
      }
    }

    sfx("shot");
    player.fireCD = cd;
  }

  // Laser: hold-to-fire continuous beam (can be combined with SINGLE/DOUBLE)
  if (player.hasLaser && firing) {
    player.laserOn = true;
    player.optionLaserOn = player.options;
  }

  // Laser SFX
  if (player.laserOn) {
    player.laserSfx = Math.max(0, player.laserSfx - dt);
    if (player.laserSfx <= 0) {
      sfx("laser");
      player.laserSfx = 0.22;
    }
  }

  // Missiles
  player.missileCD = Math.max(0, player.missileCD - dt);
  if (player.missile && missileKey && player.missileCD <= 0) {
    if (missiles.filter(mm=>mm.active).length >= 4) { return; }
    const mLvl = Math.max(1, (player.missileLevel|0));
    const mMul = 1 + 0.1 * (mLvl - 1);
    const mHue = ((mLvl * 41) % 360);
    firePlayerMissile(player.x-6, player.y+10, 4*mMul, mHue);
    for (let i=0;i<player.options;i++) {
      const p = optionPos[i];
      const m = missilePool.get();
      m.active = true; m.x = p.x-6; m.y = p.y+10;
      m.vx = 360; m.vy = 0; m.r=5; m.ttl=2.0; m.trail=0; m.dmg=2.8;
      m.dmg *= mMul;
      m.hue = (mHue + 18 + i*14) % 360;
      if (missiles.filter(mm=>mm.active).length < 4) missiles.push(m);
    }
    sfx("missile");
    player.missileCD = 0.36;
  }
}
doPlayerFire._cHeld = false;


  function addGaugeStep(steps=1) {
    steps = (steps|0) || 1;
    steps = Math.max(1, steps);

    for (let k=0; k<steps; k++) {
      gaugeProgress = (gaugeProgress < 0) ? 0 : ((gaugeProgress + 1) % gaugeItems.length);
      gaugeReady = true;
      renderGaugeUI();
    // Auto-equip SHIELD as soon as the gauge reaches it (no extra SFX)
    if (gaugeProgress >= 0 && gaugeItems[gaugeProgress] === "SHIELD") {
      player.shield = (player.shield|0) + 1;
      player.shieldPulse = 0.65;
      const hue = (200 + ((player.shield|0) * 18)) % 360;
      shieldBurstFX(player.x, player.y, player.shield);
      powerLevelPopup(player.x, player.y, "SHIELD", player.shield, hue);
      resetGauge();
    }
  }

  }

  function resetGauge() {
    gaugeProgress = -1;
    gaugeReady = false;
    renderGaugeUI();
  }

  function activatePowerup() {
    if (gaugeProgress < 0) return;
    if (!gaugeReady) return;
    const item = gaugeItems[gaugeProgress];

    if (item === "SPEED") {
      player.speedLevel = clamp(player.speedLevel + 1, 0, 2);
      const lvl = (player.speedLevel|0);
      const hue = (40 + lvl * 28) % 360;
      powerLevelPopup(player.x, player.y, "SPEED", lvl, hue);
    } else if (item === "MISSILE") {
      player.missileLevel = (player.missileLevel|0) + 1;
      player.missile = true;
      weaponBoostFX(player.x, player.y, "missile", player.missileLevel);
      const hue = ((player.missileLevel|0) * 41) % 360;
      powerLevelPopup(player.x, player.y, "MISSILE", player.missileLevel, hue);
    } else if (item === "DOUBLE") {
      player.doubleLevel = (player.doubleLevel|0) + 1;
      player.shotLevel = 1;
      weaponBoostFX(player.x, player.y, "double", player.doubleLevel);
      const hue = (280 + ((player.doubleLevel|0) * 37)) % 360;
      powerLevelPopup(player.x, player.y, "DOUBLE", player.doubleLevel, hue);
    } else if (item === "LASER") {
      player.hasLaser = true;
      player.laserLevel = (player.laserLevel|0) + 1;
      player.laserPulse = 0.65;
      weaponBoostFX(player.x, player.y, "laser", player.laserLevel);
      const hue = (200 + ((player.laserLevel|0) * 53)) % 360;
      powerLevelPopup(player.x, player.y, "LASER", player.laserLevel, hue);
    } else if (item === "OPTION") {
        player.options = player.options + 1;
        ensureOptions(player.options);
        const hue = (210 + ((player.options|0) * 22)) % 360;
        powerLevelPopup(player.x, player.y, "OPTION", player.options, hue);
} else if (item === "SHIELD") {
  player.shield = (player.shield|0) + 1;
  player.shieldPulse = 0.65;
  // strengthening effect
  const hue = (200 + ((player.shield|0) * 18)) % 360;
  shieldBurstFX(player.x, player.y, player.shield);
  powerLevelPopup(player.x, player.y, "SHIELD", player.shield, hue);
    }

    sfx("power");
    resetGauge();
  }

    let frameDT = 1/60;
let worldX = 0;
  const scrollSpeed = 150; // px/s baseline

  function setSectionFromTime(t) {
    if (t < 70) section = "A";
    else if (t < 150) section = "B";
    else if (t < 225) section = "C";
    else if (t < 280) section = "D";
    else if (t < 310) section = "M";
    else if (t < 370) section = "E";
    else section = "BOSS";
  }

  function maybeInitTerrainForSection() {
    if ((section === "C") && !maybeInitTerrainForSection._cDone) {
      genCave("C");
      maybeInitTerrainForSection._cDone = true;
      maybeInitTerrainForSection._eDone = false;
    }
    if ((section === "E") && !maybeInitTerrainForSection._eDone) {
      genCave("E");
      maybeInitTerrainForSection._eDone = true;
    }
    if ((section === "A" || section === "B" || section === "D" || section === "M" || section === "BOSS") && terrain.length > 0) {
      if (section !== "C" && section !== "E") clearTerrain();
    }
  }
  maybeInitTerrainForSection._cDone = false;
  maybeInitTerrainForSection._eDone = false;

  const sched = {
    A1: 0, A2: 8,
    B1: 70, B2: 78,
    Cslime: 152,
    HD1: 156,
    D1: 226, D2: 238,
    Mid: 280,
    E1: 312, E2: 320, E3: 332,
    Boss: 370,
    OutWarn: 252,
  };
  const SPAWN_SCALE = 0.80; // 敵出現の多さ（小さいほど多い）
  const CAPSULE_RATE = 1.35; // アイテム出やすさ倍率（>1で出やすい）

  function directorUpdate(t, dt) {
    setSectionFromTime(t);
    maybeInitTerrainForSection();

    if (elCP) elCP.textContent = checkpoint;

    // 進捗20%ごと中ボス（20/40/60/80%）
    const pctNow = Math.floor((progressMaxAbs / STAGE_TOTAL_SEC) * 100);
    const pList = [20,40,60,80];

    if (director.pMidActive) {
      // 中ボス戦中は通常スポーンを抑制
      if (!midboss || !midboss.active) {
        director.pMidActive = false;
      } else {
        return;
      }
    }

    if (!director.bossStarted && !director.bossDead && director.pMidIdx < pList.length && pctNow >= pList[director.pMidIdx]) {
      const th = pList[director.pMidIdx];
      director.pMidIdx += 1;
      director.pMidActive = true;
      director.midbossStarted = true;
      director.midbossDead = false;
      const tier = Math.max(1, Math.min(4, Math.floor(th/20))); // 1..4 (進捗ベース)
      const opt = Math.max(0, Math.floor(player.options || 0)); // オプション取得数（無制限）
      const hpBase = 120 + (tier-1)*60; // 20%:120 → 80%:300
      const pwrBase = 1.0 + (tier-1)*0.25; // 1.00,1.25,1.50,1.75

      // 取ったオプションに応じて強化（体力＋攻撃テンポ/弾速）
      const hpScale = 1.0 + opt*0.15;        // +15% × opt
      const atkScale = 1.0 + opt*0.12;       // +12% × opt

      const hp = hpBase * hpScale;
      const pwr = pwrBase * atkScale;

      // Popup: midboss scales with your options
      showBossPowerPopup("midboss", hpScale, atkScale);

      midboss = addEnemy("midboss", W+200, H/2, {vx:-60, hp:hp, score:3000 + tier*900, r:120, w:240, h:240});
      midboss.maxHp = midboss.hp;
      midboss._tier = tier;
      midboss._opt = opt;
      midboss._pwr = pwr;

      if (started && !director.bossStarted) { try { playMidbossBGM(900); } catch {} }
      midboss.ai = "midboss";
      midboss.p = 0;
      midboss._progressTag = th;
      return;
    }


    if (t < 70) {
      if (t >= sched.A1) {
        for (let i=0;i<1;i++) {
          const y = (i===0? 140 : (i===1? 360 : 580));
          const dir = (Math.floor(t/6)%2===0) ? 1 : -1;
          addEnemy("small", W+40 + i*40, y, {vx:-200, vy: dir*60, hp:2, score:120, r:14});
        }
        sched.A1 += 6.0*SPAWN_SCALE;
      }
      if (t >= sched.A2 && !directorUpdate._A2Placed) {
        const ys = [120, 360, 600];
        for (let i=0;i<3;i++) addEnemy("turret", W+260 + i*220, ys[i], {vx:-120, hp:8, score:300, r:16});
        for (let i=0;i<3;i++) addEnemy("turret", W+260 + i*220, ys[i]-80, {vx:-120, hp:8, score:300, r:16}); // slightly offset
        directorUpdate._A2Placed = true;
      }
    }

    if (t >= 70 && t < 150) {
      if (t >= sched.B1) {
        for (let i=0;i<2;i++) {
          const baseY = rand(140, 580);
          addEnemy("droneSine", W+40 + i*60, baseY, {vx:-170, hp:7, score:260, r:16});
        }
        sched.B1 += 7.5*SPAWN_SCALE;
      }
      if (t >= sched.B2) {
        const e = addEnemy("spawner", W+40, rand(130, 590), {vx:-90, hp:10, score:300, r:14});
        e.ai = "homingEmitter";
        sched.B2 += 12.0*SPAWN_SCALE;
      }
    }

    if (t >= 150 && t < 225) {
      if (t >= sched.Cslime) {
        const isCeil = (Math.floor((t-150)/6)%2===0);
        const y = isCeil ? rand(80, 170) : rand(550, 650);
        const e = addEnemy("slime", W+40, y, {vx:-140, hp:9, score:420, r:16});
        e.p = isCeil ? -1 : 1; // attach side
        sched.Cslime += 6.0*SPAWN_SCALE;
      }
      if (t >= sched.HD1) {
        const e = addEnemy("hookDive", W+40, rand(140, 580), {vx:-190, hp:6, score:240, r:14});
        e.ai = "hookDive";
        e.p = 0;   // state
        e.p2 = 0;  // targetY
        sched.HD1 += 8.5*SPAWN_SCALE;
      }
      if (!directorUpdate._Ccap1 && t > 158) {
        addCapsule(W-120, 360);
        directorUpdate._Ccap1 = true;
      }
    }

    if (t >= 225 && t < 280) {
      if (t >= sched.D1) {
        for (let i=0;i<5;i++) addEnemy("charger", W+40 + i*44, rand(120, 600), {vx:-340, hp:3, score:180, r:14});
        sched.D1 += 9.0*SPAWN_SCALE;
      }
      if (t >= sched.D2) {
        addEnemy("armored", W+40, rand(140, 580), {vx:-150, hp:18, score:600, r:20});
        sched.D2 += 7.0*SPAWN_SCALE;
      }

      if (!director.warnOutcrop && t >= sched.OutWarn) {
        director.warnOutcrop = true;
        directorUpdate._outcropT = t;
        sfx("warn");
      }
    }

    if (t >= 310 && t < 370) {
      if (t >= sched.E1) {
        addEnemy("turret", W+40, rand(120, 600), {vx:-120, hp:9, score:340, r:16});
        sched.E1 += 10.0*SPAWN_SCALE;
      }
      if (t >= sched.E2) {
        addEnemy("droneSine", W+40, rand(130, 590), {vx:-190, hp:8, score:260, r:16});
        sched.E2 += 6.5*SPAWN_SCALE;
      }
      if (t >= sched.E3) {
        const e = addEnemy("rear", -60, rand(140, 580), {vx: 120, hp:3, score:150, r:14});
        e.ai = "rearSpawn";
        e.p = 0.5; // warning time
        sched.E3 += 11.0*SPAWN_SCALE;
      }
    }

    if ((pctNow >= 95) && !director.bossDead) {
      if (!director.bossStarted) {
        director.bossStarted = true;
        const opt = Math.max(0, Math.floor(player.options || 0)); // オプション取得数（無制限）
        const hpScale = 1.0 + opt*0.15;   // +15% × opt
        const atkScale = 1.0 + opt*0.12;  // +12% × opt
        // Popup: boss scales with your options
        showBossPowerPopup("boss", hpScale, atkScale);
        boss = addEnemy("boss", W+260, H/2, {vx:-45, hp:1040*hpScale, score:20000 + opt*1200, r:170, w:360, h:320});
        boss._opt = opt;
        boss._pwr = atkScale;
        boss.ai = "boss";
        boss.p = 0; // phase 0 turret break
        boss.maxHp = boss.hp;
        director.bossPhase2Bgm = false;

        // Boss intro + dedicated BGM
        triggerBossIntro();
        stopAllBGM();
        setTimeout(() => { try { playBossBGM(900); } catch {} }, 2000);
      }
    }
  }
  directorUpdate._A2Placed = false;
  directorUpdate._Ccap1 = false;
  directorUpdate._outcropT = 0;

  function updateEnemies(dt, tAbs) {
    for (const e of enemies) {
      if (!e.active) continue;
      e.t += dt;

      e.x += e.vx*dt;
      e.y += e.vy*dt;

      if (e.ai === "small") {
        if (e.y < 80) e.vy = Math.abs(e.vy);
        if (e.y > H-80) e.vy = -Math.abs(e.vy);
      }
      else if (e.ai === "turret") {
        if (e.t > 0.8 && (e.t % 1.2) < dt) {
          fireAim(e.x-12, e.y, 240);
        }
      }
      else if (e.ai === "droneSine") {
        e.y += Math.sin(e.t*2.2) * 48 * dt;
        if (e.t > 0.9 && (e.t % 1.1) < dt) {
          fireFan(e.x-10, e.y, 210, 3, Math.PI, 0.55);
        }
      }
      else if (e.ai === "homingEmitter") {
        if (e.t > 0.8 && (e.t % 1.3) < dt) {
          if (enemyShots.filter(b=>b.active).length < 8) fireHomingLite(e.x-8, e.y, 180, 0.8);
        }
      }
      else if (e.ai === "slime") {
        if (e.p < 0) e.y = clamp(e.y, 90, 180);
        else e.y = clamp(e.y, 540, 650);
        if (e.t > 0.7 && (e.t % 1.6) < dt) {
          const ang = (e.p < 0) ? (Math.PI*0.35) : (-Math.PI*0.35);
          e.p2 = 0.0;
          e.p3 = ang;
        }
        if (e.p2 !== undefined) {
          e.p2 += dt;
          if (e.p2 < 0.22 && (Math.floor(e.p2*40)%6===0)) {
            fireEnemyShot(e.x-8, e.y, -240, Math.sin(e.p3)*120, 5, 0);
          }
          if (e.p2 > 0.28) { e.p2 = undefined; }
        }
      }
      else if (e.ai === "hookDive") {
        // Hook-Dive: intercept-style dive that pressures player positioning (no bullets)
        // states: 0 cruise, 1 lock, 2 dive, 3 exit
        if (e.p === undefined) e.p = 0;
        if (e.p2 === undefined) e.p2 = 0;

        const spd = Math.hypot(player.vx, player.vy);
        // mild bob during cruise
        if (e.p === 0) {
          e.y += Math.sin(e.t*3.2 + e.y*0.01) * 26 * dt;

          // trigger lock when close enough in-screen
          if ((e.x < W - 160) || (e.t > 1.4 && (e.t % 1.9) < dt)) {
            e.p = 1;
            e._lockT = 0;
            // aim slightly ahead of player vertical position
            e.p2 = clamp(player.y + rand(-46, 46), 110, H-110);
          }
        }
        else if (e.p === 1) {
          e._lockT = (e._lockT || 0) + dt;
          // drift a bit while locking
          e.vx = -170;
          e.vy = 0;
          if (e._lockT > 0.35) {
            e.p = 2;
            e._diveT = 0;
            const dy = (e.p2 - e.y);
            e.vy = clamp(dy * 3.2, -520, 520);
            e.vx = -250;
          }
        }
        else if (e.p === 2) {
          e._diveT = (e._diveT || 0) + dt;
          // after passing near target, transition to exit
          if (Math.abs(e.y - e.p2) < 18 || e._diveT > 0.55) {
            e.p = 3;
            e.vy = 0;
            e.vx = -320;
          }
        }
        else {
          // exit
          e.vx = -320;
          e.vy *= 0.95;
        }

        // visual tilt (stored for renderer)
        let tilt = 0;
        if (e.p === 1) tilt = 0.22;
        if (e.p === 2) tilt = 0.40;
        if (e.p === 3) tilt = 0.12;
        const sgn = (e.vy < -5) ? -1 : (e.vy > 5 ? 1 : 1);
        e._ang = tilt * sgn;
      }

      else if (e.ai === "charger") {
      }
      else if (e.ai === "armored") {
        if (e.t > 1.2 && (e.t % 1.7) < dt) {
          fireAim(e.x-10, e.y, 220);
        }
      }
      else if (e.ai === "rearSpawn") {
        e.p -= dt;
        if (e.p > 0) {
          if ((Math.floor(e.t*10)%2)===0) {
            const p = fxPool.get();
            p.active=true; p.x=40; p.y=e.y; p.vx=0; p.vy=0; p.ttl=0.06; p.size=10; p.kind="boom";
            fx.push(p);
          }
        } else {
          e.ai = "small";
          e.x = 60;
          e.vx = 200;
          e.vy = rand(-40,40);
          e.hp = 2;
          e.score = 150;
          e.r = 14;
        }
      }
      else if (e.ai === "midboss") {
        if (e.x > W-220) e.vx = -90;
        else e.vx = 0;

        if (e.t > 2.0) e.p = 1; // open cores

        // Core open pulse (one-shot)
        if (e.p === 1 && !e._coreOpened) {
          e._coreOpened = true;
          burstFX(e.x+40, e.y-55, 22, "spark");
          burstFX(e.x+40, e.y+55, 22, "spark");
          burstFX(e.x-40, e.y, 18, "boom");
          try { bossIntroFlash(0.55); } catch (_) {}
        }

        // Ambient midboss aura (throttled)
        if ((Math.floor(e.t*18) % 3) === 0) {
          const p = fxPool.get();
          p.active = true;
          p.x = e.x + rand(-130, 130);
          p.y = e.y + rand(-100, 100);
          p.vx = rand(-35, 35);
          p.vy = rand(-35, 35);
          p.ttl = 0.22 + Math.random()*0.22;
          p.size = 2 + Math.random()*3;
          p.kind = "spark";
          fx.push(p);
        }
        if ((Math.floor(e.t*9) % 11) === 0) {
          const p = fxPool.get();
          p.active = true;
          p.x = e.x + rand(-80, 80);
          p.y = e.y + rand(-60, 60);
          p.vx = 0; p.vy = 0;
          p.ttl = 0.32 + Math.random()*0.22;
          p.size = 10 + Math.random()*22;
          p.kind = "boom";
          fx.push(p);
        }

        const f = e._pwr || 1.0;
        const opt = e._opt || 0;

        if (e.p === 0) {
          if ((e.t % (1.0 / f)) < dt) fireAim(e.x-140, e.y, 240 * f);

          // オプション2以上：予告の扇状弾（軽め）
          if (opt >= 2 && (e.t % (1.8 / f)) < dt) {
            fireFan(e.x-120, e.y, 200 * f, 5, Math.PI, 0.55);
          }
        } else {
          if ((e.t % (1.6 / f)) < dt) fireRing(e.x+40, e.y-55, 170 * f, 10);
          if ((e.t % (1.8 / f)) < dt) fireRing(e.x+40, e.y+55, 170 * f, 10);
          if ((e.t % (2.4 / f)) < dt) fireAim(e.x-80, e.y, 260 * f);

          // オプション2以上：コアから追加リング
          if (opt >= 2 && (e.t % (2.2 / f)) < dt) {
            fireRing(e.x-20, e.y, 190 * f, 12);
          }

          // オプション4以上：ライトホーミング追加
          if (opt >= 4 && (e.t % (2.9 / f)) < dt) {
            for (let i=0;i<2;i++) fireHomingLite(e.x+20, e.y + (i? 48 : -48), 200 * f, 0.75);
          }
        }
      }
      else if (e.ai === "boss") {
        if (e.x > W-260) e.vx = -70;
        else e.vx = 0;

        if (bossIntro && bossIntro.active) {
          // during intro, no attacks
          e.y = H/2 + Math.sin(e.t*0.45) * 70;
          continue;
        }

        if (e.maxHp === undefined) e.maxHp = e.hp;

        // phase thresholds scale with max HP
        if (e.hp < e.maxHp * 0.73) e.p = Math.max(e.p, 1);
        if (e.hp < e.maxHp * 0.31) e.p = Math.max(e.p, 2);

        // Boss phase-change pulse (visual only)
        if (e._phase === undefined) e._phase = e.p;
        if (e.p !== e._phase) {
          e._phase = e.p;
          burstFX(e.x-80, e.y, 26, "spark");
          burstFX(e.x-80, e.y, 18, "boom");
          try { bossIntroFlash(0.50 + 0.12*e.p); } catch (_) {}
          try { sfx("power"); } catch (_) {}
        }

        // Ambient boss aura (throttled)
        if ((Math.floor(e.t*20) % 2) === 0) {
          const p = fxPool.get();
          p.active = true;
          p.x = e.x + rand(-170, 170);
          p.y = e.y + rand(-130, 130);
          p.vx = rand(-28, 28);
          p.vy = rand(-28, 28);
          p.ttl = 0.20 + Math.random()*0.24;
          p.size = 2 + Math.random()*3;
          p.kind = "spark";
          fx.push(p);
        }
        if ((Math.floor(e.t*8) % 9) === 0) {
          const p = fxPool.get();
          p.active = true;
          p.x = e.x + rand(-120, 120);
          p.y = e.y + rand(-90, 90);
          p.vx = 0; p.vy = 0;
          p.ttl = 0.34 + Math.random()*0.26;
          p.size = 14 + Math.random()*34;
          p.kind = "boom";
          fx.push(p);
        }

        // BGM phase 2 at 50% HP
        if (!director.bossPhase2Bgm && e.hp <= e.maxHp * 0.50) {
          director.bossPhase2Bgm = true;
          bossIntroFlash(0.55);
          sfx("power");
          startBossBGM(2);
        }

        e.y = H/2 + Math.sin(e.t*0.45) * 70;

        const f = e._pwr || 1.0;
        const opt = e._opt || 0;

        if (e.p === 0) {
          if ((e.t % (0.95 / f)) < dt) fireFan(e.x-200, e.y-110, 220 * f, 3 + Math.floor(opt/3), Math.PI, 0.55);
          if ((e.t % (1.15 / f)) < dt) fireFan(e.x-200, e.y+110, 220 * f, 3 + Math.floor(opt/3), Math.PI, 0.55);
          if (opt >= 3 && (e.t % (1.6 / f)) < dt) fireAim(e.x-160, e.y, 260 * f);
        } else if (e.p === 1) {
          if ((e.t % (1.35 / f)) < dt) {
            for (let i=0;i<10;i++) {
              const a = (i/10)*TAU;
              const vx = Math.cos(a)*160*f - 80*f;
              const vy = Math.sin(a)*160*f;
              fireEnemyShot(e.x+70, e.y, vx, vy, 5, 0);
            }
          }
          // オプション5以上：ホーミング追加
          if (opt >= 5 && (e.t % (2.6 / f)) < dt) {
            for (let i=0;i<2;i++) fireHomingLite(e.x+30, e.y + (i? 60 : -60), 200 * f, 0.75);
          }
          const m = e.t % 3.2;
          if (m > 0.8 && m < 0.8 + dt) {
            const y = lerp(e.y-140, e.y+140, (m-0.8)/0.0001); // placeholder
          }
          if (m > 0.8 && m < 1.0) {
          }
          if (m > 0.78 && m < 0.78 + dt) {
            const k = clamp(m/0.78,0,1);
          }
          if (m > 0.79 && m < 0.79+dt) {
            const k = 0; // not used
          }
          if (m > 0.80 && m < 0.80+dt) {
            const k = ((e.t - m) % 99999); // no-op
          }
          if (m > 0.80 && m < 0.80+dt) {
          }
          if (e._lastSweep === undefined) e._lastSweep = -999;
          if (m < 0.02 && (e.t - e._lastSweep) > 3.0) {
            e._lastSweep = e.t;
          }
          if (e._lastSweep > 0 && e.t > e._lastSweep + 0.8 && !e._sweepDone) {
            e._sweepDone = true;
            const phase = (Math.floor(e._lastSweep / 3.2) % 2);
            const y = phase === 0 ? (e.y - 90) : (e.y + 90);
            for (let i=0;i<26;i++) {
              fireEnemyShot(e.x-230, y + (i-13)*8, -380*f, 0, 5, 0);
            }
          }
          if (e._lastSweep > 0 && e.t > e._lastSweep + 1.0) {
            e._sweepDone = false;
          }
        } else {
          if ((e.t % (1.0 / f)) < dt) fireRing(e.x+70, e.y, 190 * f, 14 + Math.min(6, opt));
          if ((e.t % (1.4 / f)) < dt) {
            fireFan(e.x-200, e.y-110, 250 * f, 5 + Math.floor(opt/2), Math.PI, 0.9);
            fireFan(e.x-200, e.y+110, 250 * f, 5 + Math.floor(opt/2), Math.PI, 0.9);
          }
          if ((e.t % (2.2 / f)) < dt) {
            for (let i=0;i<(3 + Math.min(5, Math.floor(opt/2)));i++) fireHomingLite(e.x+20, e.y + (i-(1+Math.floor((Math.min(5, Math.floor(opt/2))))/2))*34, 190 * f, 0.7);
          }
        }
      }

      if (e.ai !== "midboss" && e.ai !== "boss") {
        
      // Clamp enemies to a lower top boundary so they never sit in the ceiling area (unkillable at top)
      // Matches player's usable frame.
      if (e.ai !== "rearSpawn") {
        const r = (e.r ?? 14);
        e.y = clamp(e.y, 140 + r, (H - 60) - r); // top lowered (was ~60-80)
      }

if (e.x < -120 || e.y < -120 || e.y > H+120) {
          e.active = false;
        }
      } else {
        e.x = clamp(e.x, W-320, W+300);
      }

    }

    for (let i=enemies.length-1;i>=0;i--) {
      if (!enemies[i].active) { enemyPool.put(enemies[i]); enemies.splice(i,1); }
    }
  }

  function updateBullets(dt, worldOffsetX) {
    for (const s of shots) {
      if (!s.active) continue;
      s.x += s.vx*dt;
      s.y += s.vy*dt;
      s.ttl -= dt;
      if (s.ttl <= 0 || s.x > W+80 || s.y < -80 || s.y > H+80) s.active=false;
    }
    for (let i=shots.length-1;i>=0;i--) {
      if (!shots[i].active) { shotPool.put(shots[i]); shots.splice(i,1); }
    }

    for (const m of missiles) {
      if (!m.active) continue;
      m.x += m.vx*dt;
      m.y += m.vy*dt;
      m.ttl -= dt;

      // Homing guidance: steer toward nearest target (enemy first, then boss).
      let tx = null, ty = null;
      let bestD2 = 9e9;
      for (const e of enemies) {
        if (!e.active) continue;
        const dx = (e.x - m.x), dy = (e.y - m.y);
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) { bestD2 = d2; tx = e.x; ty = e.y; }
      }
      if (boss && boss.active) {
        const dx = (boss.x - m.x), dy = (boss.y - m.y);
        const d2 = dx*dx + dy*dy;
        if (d2 < bestD2) { bestD2 = d2; tx = boss.x; ty = boss.y; }
      }
      if (tx != null) {
        const dx = tx - m.x, dy = ty - m.y;
        const ang = Math.atan2(dy, dx);
        const sp = Math.max(260, Math.hypot(m.vx, m.vy));
        const turn = 0.10; // steering strength
        m.vx = lerp(m.vx, Math.cos(ang)*sp, turn);
        m.vy = lerp(m.vy, Math.sin(ang)*sp, turn);
      }

      if (terrainHint.length > 0) {
        const wx = m.x + worldOffsetX;
        const idx = Math.floor(wx/32);
        const h = terrainHint[idx];
        if (h) {
          const mid = (h.ceilY + h.floorY) * 0.5;
          const target = (m.y > mid) ? (h.floorY - 18) : (h.ceilY + 18);
          m.y = lerp(m.y, target, 0.06);
        }
      }

      if (m.ttl <= 0 || m.x > W+120 || m.y < -120 || m.y > H+120) m.active=false;
      m.trail += dt;
      if (m.trail > 0.05) {
        m.trail = 0;
        const p = fxPool.get();
        const hue = 180 + (player.missileLevel||1) * 10;
        p.active = true; p.x = m.x-6; p.y = m.y; p.vx = -40; p.vy = rand(-30,30); p.ttl = 0.22; p.size = 2.8; p.kind="weaponSpark"; p.hue = (hue + rand(-20,20)) % 360;
        fx.push(p);
      }
    }
    for (let i=missiles.length-1;i>=0;i--) {
      if (!missiles[i].active) { missilePool.put(missiles[i]); missiles.splice(i,1); }
    }

    for (const b of enemyShots) {
      if (!b.active) continue;
      if (b.homing > 0) {
        b.homing -= dt;
        const dx = (player.x - b.x), dy = (player.y - b.y);
        const ang = Math.atan2(dy, dx);
        const sp = b.spd || Math.hypot(b.vx,b.vy);
        b.vx = lerp(b.vx, Math.cos(ang)*sp, 0.08);
        b.vy = lerp(b.vy, Math.sin(ang)*sp, 0.08);
      }
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      b.ttl -= dt;
      if (b.ttl <= 0 || b.x < -120 || b.x > W+120 || b.y < -120 || b.y > H+120) b.active=false;
    }
    for (let i=enemyShots.length-1;i>=0;i--) {
      if (!enemyShots[i].active) { enemyShotPool.put(enemyShots[i]); enemyShots.splice(i,1); }
    }

    for (const c of capsules) {
      if (!c.active) continue;

      c.x += c.vx * dt;
      c.y += c.vy * dt;

      // Keep capsules on-screen (and within the player's reachable area):
      // When a capsule hits any limit, it gets pushed back toward the center so it never becomes uncollectable.
      const padX = 18;          // padding from left/right edges
      const topPad = 60;        // match player clamp top (see updatePlayer)
      const bottomPad = 60;     // match player clamp bottom (see updatePlayer)
      const damp = 0.88;        // energy loss on bounce (0..1)

      const minX = padX, maxX = W - padX;
      const minY = topPad, maxY = H - bottomPad;

      // Hard clamp + bounce (keeps it inside)
      if (c.x < minX) { c.x = minX; c.vx = Math.abs(c.vx) * damp; }
      else if (c.x > maxX) { c.x = maxX; c.vx = -Math.abs(c.vx) * damp; }

      if (c.y < minY) { c.y = minY; c.vy = Math.max(Math.abs(c.vy), 120) * damp; }
      else if (c.y > maxY) { c.y = maxY; c.vy = -Math.max(Math.abs(c.vy), 120) * damp; }

      // Center push when near edges (4-direction limit protection)
      const cx = W * 0.5, cy = H * 0.5;
      const edgeBand = 26; // px zone from each limit where we start pushing inward
      let edgeFactor = 0;

      if (c.x <= minX + edgeBand) edgeFactor = Math.max(edgeFactor, (minX + edgeBand - c.x) / edgeBand);
      if (c.x >= maxX - edgeBand) edgeFactor = Math.max(edgeFactor, (c.x - (maxX - edgeBand)) / edgeBand);
      if (c.y <= minY + edgeBand) edgeFactor = Math.max(edgeFactor, (minY + edgeBand - c.y) / edgeBand);
      if (c.y >= maxY - edgeBand) edgeFactor = Math.max(edgeFactor, (c.y - (maxY - edgeBand)) / edgeBand);

      if (edgeFactor > 0) {
        const dx = cx - c.x, dy = cy - c.y;
        const inv = 1 / (Math.hypot(dx, dy) || 1);
        const pushSpd = 220 + 260 * edgeFactor; // px/s
        c.vx += dx * inv * pushSpd * dt;
        c.vy += dy * inv * pushSpd * dt;
      }

      // Slight air drag to prevent endless ping-pong
      const drag = Math.pow(0.995, dt * 60);
      c.vx *= drag;
      c.vy *= drag;

      // Downward bias so capsules never get stuck near the ceiling
      const gravity = 22; // px/s^2 (small)
      c.vy += gravity * dt;
      if (c.y <= minY + 0.5 && c.vy < 30) c.vy = 60;

      // Gentle leftward drift so capsules don't get stranded on the far right.
      // Base drift applies everywhere; extra drift kicks in near the right side.
      const driftBase = 10; // px/s
      const driftBoost = (c.x > W * 0.78) ? 22 : 0; // px/s
      c.vx -= (driftBase + driftBoost) * dt;

      // NOTE: capsules no longer despawn over time
}
    for (let i=capsules.length-1;i>=0;i--) {
      if (!capsules[i].active) { capsulePool.put(capsules[i]); capsules.splice(i,1); }
    }

    for (const p of fx) {
      if (!p.active) continue;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.ttl -= dt;
      if (p.ttl <= 0) p.active=false;
    }
    for (let i=fx.length-1;i>=0;i--) {
      if (!fx[i].active) { fxPool.put(fx[i]); fx.splice(i,1); }
    }
  }

  function updatePlayer(dt, worldOffsetX) {
    if (!player.alive) return;

    const base = 280;
    const speed = base + player.speedLevel*90;

    const up = isDown(["KeyW","ArrowUp"]);
    const down = isDown(["KeyS","ArrowDown"]);
    const left = isDown(["KeyA","ArrowLeft"]);
    const right = isDown(["KeyD","ArrowRight"]);

    let ax = 0, ay = 0;
    if (up) ay -= 1;
    if (down) ay += 1;
    if (left) ax -= 1;
    if (right) ax += 1;

    if (ax !== 0 || ay !== 0) {
      const len = Math.hypot(ax, ay);
      ax /= len; ay /= len;
    }

    player.x += ax * speed * dt;
    player.y += ay * speed * dt;

    player.x = clamp(player.x, 80, W-120);
    player.y = clamp(player.y, 60, H-60);

    if (terrain.length > 0) {
      const wx = player.x + worldOffsetX;
      const idx = clamp(Math.floor(wx/32), 0, terrainHint.length-1);
      const h = terrainHint[idx];
      if (h) {
        const top = h.ceilY + 10 + player.hy;
        const bot = h.floorY - 10 - player.hy;
        player.y = clamp(player.y, top, bot);
      }
    }

    player.invuln = Math.max(0, player.invuln - dt);
    player.shieldPulse = Math.max(0, player.shieldPulse - dt);
    player.laserPulse = Math.max(0, player.laserPulse - dt);
    player.shieldDownTimer = Math.max(0, (player.shieldDownTimer||0) - dt*1.2);

    player.trail.push({x: player.x, y: player.y});
    if (player.trail.length > 90) player.trail.shift();
    ensureOptions(player.options);
for (let i=0;i<player.options;i++) {
  const d = optionDelayFrames[i] ?? 20;
  const idx2 = player.trail.length - 1 - d;
  if (idx2 >= 0) {
    optionPos[i].x = player.trail[idx2].x;
    optionPos[i].y = player.trail[idx2].y;
  } else {
    // If trail isn't long enough yet, keep options at player position.
    optionPos[i].x = player.x;
    optionPos[i].y = player.y;
  }
}

    doPlayerFire(dt);
  }

  function awardScore(n) {
    score += n;
    elScore.textContent = String(score);
  }

  function damageEnemy(e, dmg) {
    e.hp -= dmg;

    // Hit effects: only for midboss/boss, throttled (visual only)
    if ((e.ai === "midboss" || e.ai === "boss") && e.hp > 0) {
      e._hitFx = (e._hitFx || 0) + 1;
      const hx = e.x + rand(-90, 90);
      const hy = e.y + rand(-70, 70);
      if ((e._hitFx % 2) === 0) burstFX(hx, hy, 6, "spark");
      if ((e._hitFx % 6) === 0) burstFX(hx, hy, 4, "boom");
    }

    if (e.hp <= 0) killEnemy(e);
  }

  function killEnemy(e) {
    e.active = false;
    awardScore(e.score || 100);
    if (e.ai==="boss"||e.ai==="midboss") {
      if (typeof megaExplosionFX === "function") {
        megaExplosionFX(e.x, e.y, 1.15);
      } else {
        burstFX(e.x, e.y, 18, "boom");
        burstFX(e.x, e.y, 22, "spark");
      }
    } else {
      burstFX(e.x, e.y, 14, "spark");
    }
    sfx("boom");
    if (e.ai === "boss") {
      // Ensure the run ends reliably when the final boss is defeated.
      director.bossDead = true;
      try { stopBossBGM(); } catch {}
      try { stopBGM(); } catch {}
      boss = null;
      // Trigger win overlay / leaderboard. Guard to avoid double-call.
      if (!killEnemy._won) {
        killEnemy._won = true;
        try { gameWin(); } catch (err) { console.error("gameWin failed:", err); }
      }
    }


    if (e.ai === "turret" && !killEnemy._turretDropsDone) {
      killEnemy._turretDropsDone = (killEnemy._turretDropsDone || 0) + 1;
      if (killEnemy._turretDropsDone <= 2) addCapsule(e.x, e.y);
    } else {
      if (Math.random() < Math.min(0.35, (0.10 * CAPSULE_RATE))) addCapsule(e.x, e.y);
    }

    if (e.ai === "armored") {
      for (let i=0;i<8;i++) {
        const a = (i/8)*TAU;
        fireEnemyShot(e.x, e.y, Math.cos(a)*170, Math.sin(a)*170, 5, 0);
      }
    }

    if (e === midboss) {
      director.midbossDead = true;
      if (e._progressTag) director.pMidActive = false;

      // Midboss defeated: guaranteed drop 4–6 capsules with stronger scatter.
      addCapsule(e.x, e.y, 4, 6, 2.0, true);

      midboss = null;
      if (started && !director.bossStarted) { try { playNormalBGM(900); } catch {} }
    }
    if (e === boss) {
      director.bossDead = true;
      boss = null;
      gameWin();
    }
  }
  killEnemy._turretDropsDone = 0;

  function hurtPlayer() {
    if (player.invuln > 0) return;

    if (player.shield > 0) {
      player.shield = Math.max(0, (player.shield|0) - 1);
      player.shieldPulse = 0.45;
      player.shieldDownTimer = 1.0;
      player.shieldDownX = player.x;
      player.shieldDownY = player.y;
      if (typeof window.__triggerShieldDown === 'function') window.__triggerShieldDown();
      shieldBurstFX(player.x, player.y, player.shield);
      player.invuln = 1.0;
      sfx("hit");
      burstFX(player.x, player.y, 18, "boom");
      return;
    }

    lives -= 1;
    renderLivesUI();
    sfx("hit");
    burstFX(player.x, player.y, 26, "boom");

    if (lives <= 0) {
      gameOver();
      return;
    }

    respawn();
  }


  function resetPlayerFull() {
    // Full initialization on death (no carry-over).
    player.vx = 0; player.vy = 0;
    player.speedLevel = 0;
    player.missile = false;
    player.missileLevel = 0;
    player.shotLevel = 0;
    player.doubleLevel = 0;
    player.hasLaser = false;
    player.laserLevel = 0;
    player.laserPulse = 0;
    player.options = 0;
    player.shield = 0;
    player.fireCD = 0;
    player.missileCD = 0;
    player.alive = true;
    player.laserOn = false;
    player.laserSfx = 0;
    player.optionLaserOn = 0;
    player.trail.length = 0;
    for (let i=0;i<optionPos.length;i++) { optionPos[i].x = player.x; optionPos[i].y = player.y; }

    // Reset power-up gauge selection
    gaugeProgress = -1;
    gaugeReady = false;
    renderGaugeUI();

    // Clear player projectiles
    for (const s of shots) { s.active = false; }
    for (const m of missiles) { m.active = false; }
  }

  function respawn() {
    player.invuln = 1.5;
    player.x = 220;
    player.y = H/2;
    player.trail.length = 0;
    for (let i=0;i<optionPos.length;i++) { optionPos[i].x = player.x; optionPos[i].y = player.y; }

        resetPlayerFull();

    for (const b of enemyShots) { b.active = false; }
    for (const e of enemies) {
      if (e.active && e.x < 520) e.active = false;
    }

    const ct = checkpointTimes[checkpoint];
    stageTimeAbs = ct;
    stageTime = 0;

    resyncSchedules(ct);

    maybeInitTerrainForSection._cDone = false;
    maybeInitTerrainForSection._eDone = false;

    setSectionFromTime(stageTimeAbs);
    maybeInitTerrainForSection();

    setCheckpointLabel();
  }

  function resyncSchedules(t) {
    sched.A1 = Math.max(sched.A1, t);
    sched.A2 = Math.max(sched.A2, t);
    sched.B1 = Math.max(sched.B1, t);
    sched.B2 = Math.max(sched.B2, t);
    sched.Cslime = Math.max(sched.Cslime, t);
    sched.D1 = Math.max(sched.D1, t);
    sched.D2 = Math.max(sched.D2, t);
    sched.E1 = Math.max(sched.E1, t);
    sched.E2 = Math.max(sched.E2, t);
    sched.E3 = Math.max(sched.E3, t);
    sched.OutWarn = Math.max(sched.OutWarn, t);

    if (t < 280) director.midbossStarted = false, director.midbossDead = false, midboss = null;
    if (t < 370) director.bossStarted = false, director.bossDead = false, boss = null;
  }

  function updateCheckpoint(tAbs) {
    if (tAbs >= checkpointTimes.C && checkpoint === "A") checkpoint = "C";
    if (tAbs >= checkpointTimes.M && (checkpoint === "A" || checkpoint === "C")) checkpoint = "M";
    if (tAbs >= checkpointTimes.B && checkpoint !== "B") checkpoint = "B";
    setCheckpointLabel();
  }

  function resolveCombat(worldOffsetX) {
    for (const s of shots) {
      if (!s.active) continue;
      for (const e of enemies) {
        if (!e.active) continue;
        if (e.x < -60 || e.x > W+80) continue;

        const er = (e.ai==="boss") ? 150 : (e.ai==="midboss" ? 120 : e.r);
        const tmp = {x:e.x, y:e.y, r:er};
        if (circleHit(s, tmp)) {
          s.active = false;
          if (e.ai === "midboss") {
            if (e.p >= 1) damageEnemy(e, s.dmg);
          } else if (e.ai === "boss") {
            if (e.p >= 1) damageEnemy(e, s.dmg);
            else damageEnemy(e, s.dmg*0.45); // turret phase: reduced damage
          } else {
            damageEnemy(e, s.dmg);
          }
          break;
        }
      }
    }

    for (const m of missiles) {
      if (!m.active) continue;
      for (const e of enemies) {
        if (!e.active) continue;
        const er = (e.ai==="boss") ? 150 : (e.ai==="midboss" ? 120 : e.r);
        const tmp = {x:e.x, y:e.y, r:er};
        if (circleHit(m, tmp)) {
          m.active = false;
          damageEnemy(e, m.dmg);
          for (const e2 of enemies) {
            if (!e2.active || e2===e) continue;
            const dx = e2.x - e.x, dy = e2.y - e.y;
            if (dx*dx + dy*dy < 70*70) damageEnemy(e2, m.dmg*0.5);
          }
          burstFX(m.x, m.y, 12, "boom");
          break;
        }
      }
    }
// Laser continuous damage (beam). Uses rectangle hit vs enemy circle.
// DPS tuning (laser stacks: +10% per level, unlimited)
const BASE_LASER_DPS = 26.0;
function laserMult() {
  const lvl = Math.max(1, (player.laserLevel|0));
  return 1 + 0.10 * (lvl - 1);
}
function laserDPS() { return BASE_LASER_DPS * laserMult(); }
function optionLaserDPS() { return laserDPS() * 0.70; }

function circleRectHit(cx, cy, r, rx, ry, rw, rh) {
  const nx = clamp(cx, rx, rx+rw);
  const ny = clamp(cy, ry, ry+rh);
  const dx = cx - nx, dy = cy - ny;
  return (dx*dx + dy*dy) <= r*r;
}

function applyLaserDamageAt(y, dps) {
  const rx = player.x + 18;
  const ry = y - 7;          // beam thickness area
  const rw = (W + 40) - rx;
  const rh = 14;
  for (const e of enemies) {
    if (!e.active) continue;
    if (e.x < -60 || e.x > W+120) continue;

    const er = (e.ai==="boss") ? 150 : (e.ai==="midboss" ? 120 : e.r);
    if (!circleRectHit(e.x, e.y, er, rx, ry, rw, rh)) continue;

    // Phase gates same as projectile logic
    let mult = 1.0;
    if (e.ai === "midboss") {
      if (e.p < 1) continue;
    } else if (e.ai === "boss") {
      if (e.p < 1) mult = 0.45; // turret phase
    }
    damageEnemy(e, (dps * mult) * frameDT);
  }
}

if (player.laserOn) {
  const dps = laserDPS();
  applyLaserDamageAt(player.y, dps);
  const odps = optionLaserDPS();
  for (let i=0;i<player.optionLaserOn;i++) {
    applyLaserDamageAt(optionPos[i].y, odps);
  }
}



    if (player.invuln <= 0) {
      for (const b of enemyShots) {
        if (!b.active) continue;
        if (playerHitCircle(b)) {
          b.active = false;
          hurtPlayer();
          break;
        }
      }
    }

    if (player.invuln <= 0) {
      for (const e of enemies) {
        if (!e.active) continue;
        const er = (e.ai==="boss") ? 140 : (e.ai==="midboss" ? 110 : e.r);
        const tmp = {x:e.x, y:e.y, r:er};
        const pc = {x:player.x, y:player.y, r:18};
        if (circleHit(tmp, pc)) {
          hurtPlayer();
          break;
        }
      }
    }

    if (terrain.length > 0) {
      for (const b of enemyShots) {
        if (!b.active) continue;
        const wx = b.x + worldOffsetX;
        const idx = clamp(Math.floor(wx/32), 0, terrainHint.length-1);
        const h = terrainHint[idx];
        if (!h) continue;
        if (b.y < h.ceilY + 10 || b.y > h.floorY - 10) b.active = false;
      }
      for (const s of shots) {
        if (!s.active) continue;
        const wx = s.x + worldOffsetX;
        const idx = clamp(Math.floor(wx/32), 0, terrainHint.length-1);
        const h = terrainHint[idx];
        if (!h) continue;
        if (s.y < h.ceilY + 10 || s.y > h.floorY - 10) s.active = false;
      }
    }

    for (const c of capsules) {
      if (!c.active) continue;
      const tmp = {x:c.x, y:c.y, r:12};
      const pc = {x:player.x, y:player.y, r:18};
      if (circleHit(tmp, pc)) {
        c.active = false;
        addGaugeStep((c.step|0)||1);
        sfx("power");
      }
    }
  }

  let outcrop = {active:false, x:W+80, y: H*0.5, w: 120, h: 280, t:0, warnedAt:0};
  function updateOutcrop(dt, tAbs) {
    // ボス出現中/ボス戦中はアウトクロップ演出を止める（突然の接触即死を防ぐ）
    if ((director && director.bossStarted) || (boss && boss.active) || (bossIntro && bossIntro.active)) return;

    if (director.warnOutcrop && !outcrop.active) {
      const t0 = directorUpdate._outcropT;
      if (tAbs > t0 + 2.8) {
        outcrop.active = true;
        outcrop.x = W + 140;
        outcrop.y = H*0.5;
        outcrop.w = 150;
        outcrop.h = 320;
        outcrop.t = 0;
      }
    }
    if (outcrop.active) {
      outcrop.t += dt;
      const k = clamp(outcrop.t / 1.2, 0, 1);
      outcrop.x = lerp(W+140, W-80, Math.sin(k*Math.PI)); // in then out
      if (player.invuln <= 0) {
        const rx = outcrop.x - outcrop.w/2;
        const ry = outcrop.y - outcrop.h/2;
        if (rectOverlap(player.x-player.hx, player.y-player.hy, player.hx*2, player.hy*2, rx, ry, outcrop.w, outcrop.h)) {
          hurtPlayer();
        }
      }
      if (outcrop.t > 1.2) outcrop.active = false;


    // --- hard reset bosses ---
    midboss = null;
    boss = null;
    try { bossIntro.active = false; bossIntro.t = 0; bossIntro.flash = 0; } catch {}
    try { directorUpdate._outcropT = 0; } catch {}
    }
  }

  function drawOutcrop() {
    if (!director.warnOutcrop) return;
    const tAbs = stageTimeAbs;
    const t0 = directorUpdate._outcropT;
    if (tAbs < t0 + 2.5) {
      const blink = (Math.floor((tAbs-t0)*8)%2===0);
      ctx.fillStyle = blink ? "rgba(255,75,75,0.9)" : "rgba(255,75,75,0.35)";
      ctx.fillRect(W-30, 20, 14, 14);
      ctx.strokeStyle = "rgba(231,236,255,0.2)";
      ctx.strokeRect(W-32, 18, 18, 18);
    }
    if (outcrop.active) {
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      const rx = outcrop.x - outcrop.w/2;
      const ry = outcrop.y - outcrop.h/2;
      ctx.fillRect(rx, ry, outcrop.w, outcrop.h);
      ctx.strokeStyle = "rgba(231,236,255,0.16)";
      ctx.strokeRect(rx, ry, outcrop.w, outcrop.h);
    }
  }

  function resetGame() {
    killEnemy._won = false;
    score = 0; lives = 1;
    checkpoint = "A";
    section = "A";
    stageTime = 0;
    stageTimeAbs = 0;
    stageTimeGlobal = 0;
    progressMaxAbs = 0;
    updateProgressUI();
    stageTimeGlobal = 0;
    progressMaxAbs = 0;
    updateProgressUI();
    worldX = 0;

    player.x = 220; player.y = H/2;
    player.invuln = 1.2;
    player.speedLevel = 0;
    player.missile = false;
    player.missileLevel = 0;
    player.shotLevel = 0;
    player.doubleLevel = 0;
    player.hasLaser = false;

    player.laserLevel = 0;
    player.laserPulse = 0;    player.options = 0;
    player.shield = 0;
    player.fireCD = 0;
    player.missileCD = 0;
    player.trail.length = 0;

    shots.length = 0; enemyShots.length = 0; missiles.length = 0;
    enemies.length = 0; capsules.length = 0; fx.length = 0;
    clearTerrain();

    director = { midbossStarted:false, midbossDead:false, bossStarted:false, bossDead:false, warnOutcrop:false, pMidIdx:0, pMidActive:false };
    directorUpdate._A2Placed = false;
    directorUpdate._Ccap1 = false;
    killEnemy._turretDropsDone = 0;

    sched.A1 = 0; sched.A2 = 8;
    sched.B1 = 70; sched.B2 = 78;
    sched.Cslime = 152;
    sched.D1 = 226; sched.D2 = 238;
    sched.E1 = 312; sched.E2 = 320; sched.E3 = 332;
    sched.OutWarn = 252;

    outcrop.active = false;

    resetGauge();

    elScore.textContent = "0";
    renderGaugeUI();
    renderLivesUI();
    setCheckpointLabel();
  }

  // Restart that fully resets timing/inputs to avoid "freeze" after long pauses or death effects.
  function hardRestart() {
    try { keys.clear(); } catch {}
    // reset fixed-step accumulator so we don't run thousands of updates in one frame
    acc = 0;
    last = performance.now();
    fpsAcc = 0; fpsFrames = 0;
    try { stopAllBGM(); } catch {}
    resetGame();
    started = true;
    paused = false;
    try { elOverlay.classList.add("hidden"); } catch {}
    try { playNormalBGM(450); } catch {}
  }


  function togglePause() {
    if (!started) return;
    paused = !paused;
    if (paused) {
      pauseBGM(true);
      elOverlay.classList.remove("hidden");
      elOverlay.querySelector("h1").textContent = "ポーズ中";
      elOverlay.querySelector("p").textContent = "Escで再開します。";
      elStart.textContent = "再開";
      elStart.style.display = "inline-block";
      if (elHow) elHow.style.display = "none";
      if (elHowTxt) elHowTxt.style.display = "none";
    } else {
      elOverlay.classList.add("hidden");
      pauseBGM(false);
    }
  }

  function gameOver() {
    stopAllBGM();
    started = false;
    paused = false;
    elOverlay.classList.remove("hidden");
    elOverlay.querySelector("h1").textContent = "MISSION FAILED";

    const msg = `Score: <b>${score}</b><br/>Press <span class="kbd">R</span> で再出撃。`;
    if (elOverlayP1) elOverlayP1.innerHTML = msg;
    else elOverlay.querySelector("p").innerHTML = msg;

    if (elOverlayP2) elOverlayP2.style.display = "none";
    elStart.textContent = "再出撃";
    elStart.style.display = "inline-block";
    if (elHow) elHow.style.display = "none";
    if (elHowTxt) elHowTxt.style.display = "none";

    // show latest leaderboard on overlay
    lbRefresh(10);
  }

  function gameWin() {
    stopAllBGM();
    started = false;
    paused = false;
    elOverlay.classList.remove("hidden");
    elOverlay.querySelector("h1").textContent = "ステージクリア";

    const msg = `Score: <b>${score}</b><br/>ステージ1クリア。<span class="kbd">R</span>で再出撃。`;
    if (elOverlayP1) elOverlayP1.innerHTML = msg;
    else elOverlay.querySelector("p").innerHTML = msg;

    if (elOverlayP2) elOverlayP2.style.display = "none";
    elStart.textContent = "再出撃";
    elStart.style.display = "inline-block";
    if (elHow) elHow.style.display = "none";
    if (elHowTxt) elHowTxt.style.display = "none";

    // Clear: if TOP10 qualifies, prompt name & submit; always show TOP10
    lbHandleClear(score);
  }

  window.addEventListener("keydown", (e) => {
    if (e.code === "KeyR" && !started) {
      try { unlockAudio(); ensureAudio(); } catch {}
      hardRestart();
    }
  });

  const fixed = 1/60;
  let acc = 0;
  let last = performance.now();

  function step(now) {
    const dtReal = Math.min(0.05, (now - last) / 1000);
    last = now;

    fpsAcc += dtReal; fpsFrames++;
    if (fpsAcc >= 0.5) {
      fps = Math.round(fpsFrames / fpsAcc);
      if (elFPS) elFPS.textContent = String(fps);
      fpsAcc = 0; fpsFrames = 0;
    }

    if (started && !paused) {
      acc += dtReal;
      while (acc >= fixed) {
        update(fixed);
        acc -= fixed;
      }
      render();
    } else {
      render();
    }

    requestAnimationFrame(step);
  }

    function update(dt) {
    frameDT = dt;
    _dtRender = dt;
    stageTime += dt;
    stageTimeAbs += dt * SCROLL_SCALE;

    // 進捗は中ボス出現中（MISSION FAILEDまで）進めない
    const freezeProgress = (director && director.pMidActive && midboss && midboss.active);
    if (!freezeProgress) {
      stageTimeGlobal += dt * SCROLL_SCALE;
    }
    progressMaxAbs = stageTimeGlobal;
    updateProgressUI();

    const sp = scrollSpeed + (player.speedLevel*18);
    worldX += (sp * SCROLL_SCALE) * dt;

    updateCheckpoint(stageTimeAbs);
    directorUpdate(stageTimeAbs, dt);

    if (bossIntro && bossIntro.active) {
      bossIntro.t += dt;
      bossIntro.flash = Math.max(0, bossIntro.flash - dt*1.9);
      bossIntro.dark  = Math.max(0, bossIntro.dark  - dt*0.55);
      bossIntro.white = Math.max(0, bossIntro.white - dt*3.2);
      bossIntro.shake = Math.max(0, bossIntro.shake - dt*8.0);
      if (bossIntro.t >= bossIntro.dur) bossIntro.active = false;
    }

    updateOutcrop(dt, stageTimeAbs);

    updatePlayer(dt, worldX);
    updateEnemies(dt, stageTimeAbs);
    updateBullets(dt, worldX);
    resolveCombat(worldX);


  }

  function render() {
    // camera shake (boss intro)
    let sx = 0, sy = 0;
    if (bossIntro && bossIntro.active && bossIntro.shake > 0.01) {
      const a = bossIntro.shake * (0.6 + 0.4*Math.sin(bossIntro.t*18));
      sx = (Math.random()*2-1) * a;
      sy = (Math.random()*2-1) * a;
    }
    ctx.setTransform(1,0,0,1,0,0);
    ctx.save();
    ctx.translate(sx, sy);

    drawBackground(stageTimeAbs);
    drawTerrain(worldX);

    drawOutcrop();

    drawOptions();
    drawPlayer();

    drawEnemies();
    drawShots();
    drawCapsules();
    drawFX();

    // Boss intro overlay (WARNING + flashes)
    if (bossIntro && bossIntro.active) {
      const p = bossIntro.t / bossIntro.dur;
      const a = clamp(1.0 - p, 0.0, 1.0);

      // darken background + white flash
      const dark = clamp(bossIntro.dark, 0.0, 0.85);
      if (dark > 0.01) {
        ctx.fillStyle = "rgba(0,0,0," + dark + ")";
        ctx.fillRect(-sx, -sy, W, H);
      }
      const white = clamp(bossIntro.white, 0.0, 1.0);
      if (white > 0.01) {
        ctx.fillStyle = "rgba(255,255,255," + (0.55*white) + ")";
        ctx.fillRect(-sx, -sy, W, H);
      }
      // flash bars
      const flash = clamp(bossIntro.flash, 0.0, 1.0);
      if (flash > 0.01) {
        ctx.fillStyle = "rgba(255,60,60," + (0.18*flash) + ")";
        for (let i=0;i<12;i++) {
          const yy = i * (H/12);
          if ((i + Math.floor(stageTimeAbs*6)) % 2 === 0) ctx.fillRect(0, yy, W, H/12);
        }
      }
      // center text
      ctx.save();
      ctx.globalAlpha = 0.25 + 0.65*a;
      ctx.fillStyle = "rgba(255,80,80,1.0)";
      ctx.font = "900 78px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("WARNING", W*0.5, H*0.45);
      ctx.font = "900 22px system-ui, sans-serif";
      ctx.fillText("BOSS INCOMING", W*0.5, H*0.56);
      ctx.font = "900 18px system-ui, sans-serif";
      ctx.fillText("最終決戦", W*0.5, H*0.62);
      ctx.restore();
    }

    ctx.restore();


    // HUD popup: SHIELD -1 (stable, not affected by camera shake)
    if ((player.shieldDownTimer||0) > 0) {
      const t = clamp(player.shieldDownTimer, 0, 1);
      const px = clamp(player.shieldDownX || player.x, 20, W-20);
      const py = clamp(player.shieldDownY || player.y, 20, H-20) - (1 - t) * 42;
      ctx.save();
      ctx.globalAlpha = t;
      ctx.fillStyle = "rgba(255,80,80,1)";
      ctx.font = "900 28px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("SHIELD -1", px, py);
      ctx.restore();
    }

    ctx.fillStyle = "rgba(231,236,255,0.10)";
    ctx.font = "700 18px system-ui, sans-serif";
    ctx.fillText(section, 18, H-18);
  }

  elStart.addEventListener("click", () => {
  // Robust start handler: even if audio/BGM fails, the game must start.
  try {
    unlockAudio();
    const p = ensureAudio();
    // If ensureAudio returns a Promise in some versions, don't block start.
    if (p && typeof p.then === "function") { /* ignore */ }
  } catch (err) {
    console.error("ensureAudio failed:", err);
  }

  try {
    if (!started) {
      hardRestart();
      return;
    } else {
      paused = false;
      elOverlay.classList.add("hidden");
    }
  } catch (err) {
    console.error("start/reset failed:", err);
  }

  // Start/Resume BGM (optional)
  try {
    if (director && director.bossStarted && !director.bossDead) {
      playBossBGM(450);
    } else if (midboss) {
      playMidbossBGM(450);
    } else {
      playNormalBGM(450);
    }
  } catch (err) {
    console.error("BGM start failed:", err);
  }
});

renderGaugeUI();
  renderLivesUI();
  setCheckpointLabel();

  requestAnimationFrame(step);
})();

// ==== Boss Power Popup Effect ====
function showBossPowerPopup(mult){
  const div = document.createElement("div");
  div.textContent = "FINAL BOSS POWER +" + Math.round((mult-1)*100) + "%";
  div.style.position = "absolute";
  div.style.top = "40%";
  div.style.left = "50%";
  div.style.transform = "translate(-50%, -50%) scale(1)";
  div.style.fontSize = "42px";
  div.style.fontWeight = "900";
  div.style.color = "#ff4444";
  div.style.textShadow = "0 0 20px rgba(255,0,0,0.8)";
  div.style.pointerEvents = "none";
  div.style.transition = "all 0.8s ease-out";
  document.body.appendChild(div);

  setTimeout(()=>{
    div.style.transform = "translate(-50%, -60%) scale(1.4)";
    div.style.opacity = "0";
  }, 30);

  setTimeout(()=>{
    div.remove();
  }, 900);
}
// ==== /Boss Power Popup Effect ====

function triggerShieldDown(){
  // Safe wrapper (player is inside the game closure)
  try {
    if (typeof window.__triggerShieldDown === 'function') window.__triggerShieldDown();
  } catch (e) {}
}

</script>

<script>
(function(){
  const ov = document.getElementById('overlay');
  if(!ov) return;
  const apply = ()=>{
    const t = (ov.innerText || '').toUpperCase();
    if(t.includes('MISSION FAILED')){
      ov.classList.add('mission-failed-bg');
    }else{
      ov.classList.remove('mission-failed-bg');
    }
  };
  // initial + on changes
  apply();
  const mo = new MutationObserver(apply);
  mo.observe(ov, {subtree:true, childList:true, characterData:true});
})();
</script>


<script>
(function(){
  const ov = document.getElementById('overlay');
  if(!ov) return;
  const apply = ()=>{
    const raw = (ov.innerText || '');
    const t = raw.toUpperCase();
    const isClear = raw.includes('ステージクリア');
    if(isClear){
      ov.classList.add('clear-bg');
    }else{
      ov.classList.remove('clear-bg');
    }
  };
  apply();
  const mo = new MutationObserver(apply);
  mo.observe(ov, {subtree:true, childList:true, characterData:true});
})();
</script>

</body>
</html>
