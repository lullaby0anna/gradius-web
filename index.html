<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PC専用ありす的グラディウス</title>
  <style>
    :root { --bg:#0b0f1a; --fg:#e7ecff; --muted:#97a1c6; --danger:#ff4b4b; --ok:#36d399; }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Noto Sans JP", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif; }
    #wrap { height:100%; display:grid; place-items:center; }
    #frame { width:min(96vw, 1280px); aspect-ratio:16/9; position:relative; border-radius:18px; overflow:hidden; box-shadow: 0 14px 60px rgba(0,0,0,.45); background:#000; }
    canvas { width:100%; height:100%; display:block; image-rendering:auto; }
    #overlay {
      position:absolute; inset:0; display:flex; flex-direction:column; justify-content:center; align-items:center;
      background: radial-gradient(ellipse at center, rgba(0,0,0,.55), rgba(0,0,0,.92));
      padding:22px; text-align:center;
    }
    #overlay.hidden { display:none; }
    h1 { margin:0 0 8px; font-size:24px; letter-spacing:.5px; }
    p { margin:6px 0; color:var(--muted); font-size:14px; line-height:1.5; max-width:60ch; }
    .row { display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-top:14px; }
    button {
      border:0; padding:10px 14px; border-radius:12px; cursor:pointer;
      background: rgba(231,236,255,.12); color:var(--fg);
      font-weight:650; letter-spacing:.2px;
    }
    button:hover { background: rgba(231,236,255,.18); }
    .kbd {
      display:inline-block; padding:1px 6px; border-radius:6px;
      background: rgba(231,236,255,.12); border: 1px solid rgba(231,236,255,.18);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size: 12px; color: var(--fg);
    }
    #hud {
      position:absolute; inset:0; pointer-events:none;
      padding:12px 14px; display:flex; justify-content:space-between; align-items:flex-start;
      text-shadow: 0 2px 10px rgba(0,0,0,.6);
    }
    #hudLeft { display:flex; flex-direction:column; gap:6px; }
    #hudRight { display:flex; flex-direction:column; align-items:flex-end; gap:6px; }
    #bottomHUD {
      position:absolute; left:0; right:0; bottom:0; padding:10px 14px 12px;
      display:flex; justify-content:center; align-items:center; gap:16px;
      pointer-events:none; text-shadow: 0 2px 10px rgba(0,0,0,.6);
    }
    #gauge {
      display:flex; gap:8px; align-items:center;
      background: rgba(0,0,0,.35); border: 1px solid rgba(231,236,255,.14);
      padding:8px 10px; border-radius:14px;
    }
    .cell {
      width:92px; height:26px; display:grid; place-items:center;
      border-radius:10px; font-size:12px; font-weight:700;
      border:1px solid rgba(231,236,255,.16);
      color: rgba(231,236,255,.85);
      background: rgba(231,236,255,.06);
    }
    .cell.active { outline:2px solid rgba(231,236,255,.45); background: rgba(231,236,255,.12); }
    .cell.ready { background: rgba(54,211,153,.18); border-color: rgba(54,211,153,.35); color: rgba(231,236,255,.95); }
    #tips { font-size:12px; color: rgba(231,236,255,.75); background: rgba(0,0,0,.32); border:1px solid rgba(231,236,255,.12); padding:8px 10px; border-radius:14px; }
    #lives { display:flex; gap:6px; align-items:center; }
    .life { width:14px; height:14px; border-radius:999px; background: rgba(231,236,255,.22); border:1px solid rgba(231,236,255,.32); }
    .life.on { background: rgba(231,236,255,.75); }
    .tag { font-size:12px; color: rgba(231,236,255,.85); background: rgba(0,0,0,.32); border:1px solid rgba(231,236,255,.12); padding:6px 10px; border-radius:999px; }
  
  #progressWrap{
    position: absolute;
    left: 50%;
    top: 18px;
    transform: translateX(-50%);
    width: min(560px, 72vw);
    height: 18px;
    border-radius: 999px;
    background: rgba(0,0,0,0.35);
    border: 1px solid rgba(255,255,255,0.12);
    overflow: hidden;
    pointer-events: none;
  }
  #progressBar{
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, rgba(120,200,255,0.95), rgba(255,220,140,0.95));
    box-shadow: 0 0 18px rgba(120,200,255,0.25);
  }
  #progressText{
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    font-size: 12px;
    color: rgba(231,236,255,0.92);
    text-shadow: 0 1px 8px rgba(0,0,0,0.45);
    letter-spacing: 0.02em;
  }

    /* --- Leaderboard (Global / Workers + D1) --- */
    #lb {
      margin-top: 14px;
      width: min(560px, 92vw);
      background: rgba(231,236,255,.06);
      border: 1px solid rgba(231,236,255,.14);
      border-radius: 14px;
      padding: 12px 12px 10px;
      text-align: left;
    }
    #lbHead { display:flex; align-items:baseline; justify-content:space-between; gap:10px; margin-bottom:8px; }
    #lbTitle { font-weight: 750; letter-spacing: .2px; }
    #lbStatus { font-size: 12px; color: var(--muted); white-space: nowrap; }
    #lbBody { margin: 0; padding-left: 22px; font-size: 13px; line-height: 1.5; }
    #lbBody li { display:flex; align-items:baseline; justify-content:space-between; gap:12px; margin: 4px 0; }
    #lbBody .name { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; max-width: 320px; }
    #lbBody .val { font-variant-numeric: tabular-nums; color: rgba(231,236,255,.88); }
    #lbHint { margin-top: 8px; font-size: 12px; color: var(--muted); }

  </style>
</head>
<body>
<div id="wrap">
  <div id="frame">
    <canvas id="c" width="1280" height="720"></canvas>

    <audio id="bgmNormal" src="geme.mp3" loop preload="auto"></audio>
    <audio id="bgmBoss" src="boss.mp3" loop preload="auto"></audio>
    <audio id="bgmMidboss" src="boss2.mp3" loop preload="auto"></audio>

    <div id="hud">
      <div id="hudLeft">
        <div class="tag">スコア： <span id="score">0</span></div>
        <div class="tag">チェックポイント： <span id="cp">A</span></div>
      </div>
      <div id="hudRight">
        <div class="tag">FPS: <span id="fps">--</span></div>
        <div id="lives" class="tag" aria-label="lives"></div>
      </div>
    </div>

    <div id="progressWrap" aria-label="ゴールまでの進捗">
      <div id="progressBar"></div>
      <div id="progressText">進捗：0%</div>
    </div>

    <div id="bottomHUD">
      <div id="gauge" aria-label="powerup gauge"></div>
      <div id="tips">
        移動 <span class="kbd">WASD</span> / <span class="kbd">↑↓←→</span>　
        ショット <span class="kbd">Z</span>/<span class="kbd">Space</span>　
        ミサイル <span class="kbd">X</span>　
        発動 <span class="kbd">C</span>　
        ポーズ <span class="kbd">Esc</span>
      </div>
    </div>

    <div id="overlay">
      <h1>PC専用ありす的グラディウス</h1>
      <p>ステージは1つのみ／難易度：<b>Hard</b>／残機：<b>3</b>。理不尽ではなく、パターン学習で突破できる設計です（チェックポイント付近は事故死を防止）。</p>
      <p>パワーアップカプセルでゲージが進みます。<span class="kbd">C</span>で選択中の項目を発動します。</p>
      <div class="row">
        <button id="start">スタート</button>
        <button id="how">操作説明</button>
      </div>
      
      <div id="lb" aria-live="polite">
        <div id="lbHead">
          <div id="lbTitle">ランキング TOP10</div>
          <div id="lbStatus">読み込み中…</div>
        </div>
        <ol id="lbBody"></ol>
        <div id="lbHint">※ クリア時、<b>TOP10</b>に入った場合のみ名前入力が出ます。</div>
      </div>

      <p id="howtxt" style="display:none; margin-top:12px;">
        ・Player hitbox is smaller than the sprite. ・After death: 1.5s invulnerability.<br/>
        ・Checkpoints: C start / Midboss / Boss. ・On respawn you keep Speed1 + Missile (if acquired), but Options reset.
      </p>
    </div>

  </div>
</div>

<script>
(() => {
  "use strict";
  const STAGE_TOTAL_SEC = 480;
  const PROGRESS_SCALE = 3.0; // 進捗3倍速
  function updateProgressUI() {
    const bar = document.getElementById("progressBar");
    const txtEl = document.getElementById("progressText");
    const t = (typeof progressMaxAbs === "number") ? progressMaxAbs : 0;
    let p = Math.min(0.995, t / STAGE_TOTAL_SEC);
    try { if (director && director.bossDead) p = 1.0; } catch {}
    const pct = Math.max(0, Math.min(100, Math.round(p * 100)));
    if (bar) bar.style.width = pct + "%";
    if (txtEl) txtEl.textContent = "進捗：" + pct + "%";
  }

  const clamp = (v, a, b) => (v < a ? a : (v > b ? b : v));
  const lerp = (a,b,t) => a + (b-a)*t;
  const rand = (a,b) => a + Math.random()*(b-a);
  const TAU = Math.PI * 2;

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { alpha: false });
  // roundRect polyfill（古い環境対策）
  if (!CanvasRenderingContext2D.prototype.roundRect) {
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w*0.5, h*0.5);
      this.beginPath();
      this.moveTo(x+r, y);
      this.lineTo(x+w-r, y);
      this.quadraticCurveTo(x+w, y, x+w, y+r);
      this.lineTo(x+w, y+h-r);
      this.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
      this.lineTo(x+r, y+h);
      this.quadraticCurveTo(x, y+h, x, y+h-r);
      this.lineTo(x, y+r);
      this.quadraticCurveTo(x, y, x+r, y);
      this.closePath();
      return this;
    };
  }
  const W = canvas.width, H = canvas.height;  const SCROLL_SCALE = 2.0; // スクロール速度倍率（2.0＝2倍）

  const elOverlay = document.getElementById("overlay");
  const elStart = document.getElementById("start");
  const elHow = document.getElementById("how");
  const elHowTxt = document.getElementById("howtxt");
  const elScore = document.getElementById("score");
  const elFPS = document.getElementById("fps");
  const elCP = document.getElementById("cp");
  const elGauge = document.getElementById("gauge");
  const elLives = document.getElementById("lives");
  const elProgBar = document.getElementById("progressBar");
  const elProgTxt = document.getElementById("progressText");


  // -----------------------------
  // Global leaderboard (TOP10表示 / TOP10のみ登録) via Cloudflare Workers + D1
  // -----------------------------
  const LEADERBOARD_API = "https://gradius-top3.lullaby0anna.workers.dev";
  const elLBStatus = document.getElementById("lbStatus");
  const elLBBody   = document.getElementById("lbBody");

  // Overlay paragraphs (start説明の2行) を勝敗画面では隠す
  const _overlayPs = elOverlay.querySelectorAll("p");
  const elOverlayP1 = _overlayPs[0] || null;
  const elOverlayP2 = _overlayPs[1] || null;

  function lbEsc(s){
    return String(s).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
  }
  function lbBase(){
    return (LEADERBOARD_API || "").replace(/\/$/,"");
  }
  async function lbGetTop(limit=10){
    const url = lbBase() + "/top?limit=" + encodeURIComponent(String(limit));
    const r = await fetch(url, { method:"GET", cache:"no-store" });
    if (!r.ok) throw new Error("top fetch failed: " + r.status);
    return await r.json();
  }
  async function lbPostScore(name, scoreVal){
    const url = lbBase() + "/score";
    const r = await fetch(url, {
      method:"POST",
      headers:{ "content-type":"application/json" },
      body: JSON.stringify({ name, score: Math.floor(Number(scoreVal) || 0) })
    });
    if (!r.ok) throw new Error("score post failed: " + r.status);
    return await r.json();
  }
  function lbRender(rows){
    if(!elLBBody) return;
    const list = Array.isArray(rows) ? rows.slice(0, 10) : [];
    const out = [];
    for(let i=0;i<10;i++){
      const x = list[i];
      if(x){
        const n = escHtml(x.name ?? "NONAME");
        const sc = Number(x.score ?? 0);
        out.push(`<li><span class="name">${i+1}位：${n}</span><span class="val">${sc}</span></li>`);
      }else{
        out.push(`<li><span class="name">${i+1}位：<span style="opacity:.7">—</span></span><span class="val" style="opacity:.7">—</span></li>`);
      }
    }
    elLBBody.innerHTML = out.join("");
  }

  function lbQualifies(scoreVal, list, n=10){
    const s = Math.floor(Number(scoreVal) || 0);
    if (!Array.isArray(list)) return false;
    if (list.length < n) return true;
    const last = Math.floor(Number(list[n-1] && list[n-1].score) || -1);
    return s > last;
  }
  async function lbRefresh(limit=10, statusPrefix=""){
    if (!LEADERBOARD_API || !elLBBody) return null;
    try{
      if (elLBStatus) elLBStatus.textContent = statusPrefix ? (statusPrefix + " 読み込み中…") : "読み込み中…";
      const top = await lbGetTop(limit);
      lbRender(top);
      if (elLBStatus) elLBStatus.textContent = statusPrefix ? (statusPrefix + " 更新") : "更新";
      return top;
    }catch(e){
      console.error(e);
      lbRender([]);
      if (elLBStatus) elLBStatus.textContent = "取得失敗";
      return null;
    }
  }
  async function lbHandleClear(scoreVal){
    const top10 = await lbRefresh(10);
    if (!top10) return;
    if (!lbQualifies(scoreVal, top10, 10)) return;

    let name = prompt("TOP10入り！名前を入力（10文字まで）", "PLAYER");
    if (name === null) name = "PLAYER";
    name = (name || "NONAME").trim().slice(0, 10) || "NONAME";

    try{
      if (elLBStatus) elLBStatus.textContent = "送信中…";
      await lbPostScore(name, scoreVal);
      await lbRefresh(10, "送信完了");
    }catch(e){
      console.error(e);
      if (elLBStatus) elLBStatus.textContent = "送信失敗";
    }
  }
  // -----------------------------
  // /Global leaderboard
  // -----------------------------

  // 起動時：スタート画面でランキングを表示
  lbRefresh(10);


// Global error catcher: show errors on overlay so "start not working" is diagnosable.
window.addEventListener("error", (ev) => {
  try {
    console.error(ev.error || ev.message || ev);
    elOverlay.classList.remove("hidden");
    elOverlay.querySelector("h1").textContent = "エラー発生";
    const msg = (ev && (ev.message || (ev.error && ev.error.message))) ? (ev.message || ev.error.message) : "unknown error";
    const line = (ev && ev.lineno) ? (" (line " + ev.lineno + ")") : "";
    elOverlay.querySelector("p").textContent = "Console を確認: " + msg + line;
    elStart.textContent = "リロード";
    elStart.style.display = "inline-block";
    elHow.style.display = "none";
    elHowTxt.style.display = "none";
    elStart.onclick = () => location.reload();
  } catch {}
});

elHow.addEventListener("click", () => {
    elHowTxt.style.display = (elHowTxt.style.display === "none") ? "block" : "none";
  });

  const keys = new Set();
  let lastFocus = true;

  window.addEventListener("keydown", (e) => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    keys.add(e.code);
    if (e.code === "Escape") togglePause();
  }, { passive:false });

  window.addEventListener("keyup", (e) => {
    keys.delete(e.code);
  });

  window.addEventListener("blur", () => { lastFocus = false; keys.clear(); });
  window.addEventListener("focus", () => { lastFocus = true; });

  const isDown = (codes) => codes.some(c => keys.has(c));

  let audioCtx = null;
  const ensureAudio = () => {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === "suspended") return audioCtx.resume();
  return Promise.resolve();
};

// Unlock audio on browsers that require a synchronous sound on user gesture.
function unlockAudio() {
  try {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    // resume without waiting (still in gesture)
    if (audioCtx.state === "suspended") audioCtx.resume();
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    g.gain.setValueAtTime(0.0001, t);
    o.type = "sine";
    o.frequency.setValueAtTime(440, t);
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start(t);
    o.stop(t + 0.02);
  } catch (e) {
    console.error("unlockAudio failed:", e);
  }
}

// --- MP3 BGM (geme.mp3 / boss2.mp3 / boss.mp3) ---
const bgmNormalEl  = document.getElementById("bgmNormal");
const bgmMidbossEl = document.getElementById("bgmMidboss");
const bgmBossEl    = document.getElementById("bgmBoss");

let _bgmCurrent = null;
let _fadeOutTimer = null;
let _fadeInTimer = null;

function _clearFadeTimers() {
  try { if (_fadeOutTimer) { clearInterval(_fadeOutTimer); _fadeOutTimer = null; } } catch {}
  try { if (_fadeInTimer)  { clearInterval(_fadeInTimer);  _fadeInTimer  = null; } } catch {}
}

function _safePlay(el) {
  if (!el) return;
  try {
    const p = el.play();
    if (p && typeof p.catch === "function") p.catch(() => {});
  } catch {}
}

function stopAllBGM() {
  _clearFadeTimers();
  try {
    for (const el of [bgmNormalEl, bgmMidbossEl, bgmBossEl]) {
      if (!el) continue;
      el.pause();
      el.currentTime = 0;
      el.volume = 0;
    }
    _bgmCurrent = null;
  } catch {}
}

// Fade switch: always restarts target from the beginning (midboss appears multiple times).
function fadeToBGM(targetEl, targetVol = 0.70, ms = 900) {
  if (!targetEl) return;
  if (_bgmCurrent === targetEl) return;

  _clearFadeTimers();

  const prev = _bgmCurrent;
  _bgmCurrent = targetEl;

  // fade out previous
  if (prev) {
    let v = Math.max(0, Math.min(1, prev.volume || 0));
    const steps = Math.max(1, Math.floor(ms / 50));
    const step = v / steps;

    _fadeOutTimer = setInterval(() => {
      v -= step;
      if (v <= 0.001) {
        prev.volume = 0;
        prev.pause();
        try { prev.currentTime = 0; } catch {}
        clearInterval(_fadeOutTimer);
        _fadeOutTimer = null;
      } else {
        prev.volume = v;
      }
    }, 50);
  }

  // start & fade in target
  try {
    targetEl.pause();
    targetEl.currentTime = 0; // every time from start
    targetEl.volume = 0;
  } catch {}
  _safePlay(targetEl);

  {
    let v = 0;
    const steps = Math.max(1, Math.floor(ms / 50));
    const step = targetVol / steps;

    _fadeInTimer = setInterval(() => {
      v += step;
      if (v >= targetVol) {
        targetEl.volume = targetVol;
        clearInterval(_fadeInTimer);
        _fadeInTimer = null;
      } else {
        targetEl.volume = v;
      }
    }, 50);
  }
}

function playNormalBGM(ms = 900)  { fadeToBGM(bgmNormalEl,  0.62, ms); }
function playMidbossBGM(ms = 900) { fadeToBGM(bgmMidbossEl, 0.70, ms); }
function playBossBGM(ms = 900)    { fadeToBGM(bgmBossEl,    0.72, ms); }
// --- /MP3 BGM ---




  function sfx(type="shot") {
    if (!audioCtx) return;
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);

    if (type === "shot") {
      o.type = "square"; o.frequency.setValueAtTime(560, t);
      g.gain.setValueAtTime(0.06, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.06);
      o.start(t); o.stop(t+0.07);
    } else if (type === "missile") {
      o.type = "sawtooth"; o.frequency.setValueAtTime(220, t);
      o.frequency.exponentialRampToValueAtTime(110, t+0.18);
      g.gain.setValueAtTime(0.08, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.2);
      o.start(t); o.stop(t+0.22);
    } else if (type === "power") {
      o.type = "triangle"; o.frequency.setValueAtTime(520, t);
      o.frequency.setValueAtTime(740, t+0.06);
      g.gain.setValueAtTime(0.09, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.25);
      o.start(t); o.stop(t+0.26);
    } else if (type === "hit") {
      o.type = "square"; o.frequency.setValueAtTime(90, t);
      g.gain.setValueAtTime(0.12, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.25);
      o.start(t); o.stop(t+0.26);
    } else if (type === "boom") {
      o.type = "sine"; o.frequency.setValueAtTime(130, t);
      o.frequency.exponentialRampToValueAtTime(60, t+0.3);
      g.gain.setValueAtTime(0.14, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.35);
      o.start(t); o.stop(t+0.36);
    } else if (type === "warn") {
      o.type = "square"; o.frequency.setValueAtTime(880, t);
      g.gain.setValueAtTime(0.07, t); g.gain.exponentialRampToValueAtTime(0.001, t+0.12);
      o.start(t); o.stop(t+0.13);
    }
  }

// --- BGM: Star Soldier–style chiptune (original, procedural) ---
// Uses WebAudio (square/square/triangle + noise) and schedules a short loop.
let bgm = {
  on: false,
  timer: null,
  tempo: 232,          // BPM
  lookahead: 0.10,     // seconds
  scheduleAhead: 0.18, // seconds
  step: 0,
  nextTime: 0,
  gain: null,
  comp: null,
  noiseBuf: null,
};

const mtof = (m) => 440 * Math.pow(2, (m - 69) / 12);

function initBGMIfNeeded() {
  if (!audioCtx) return;
  if (!bgm.gain) {
    bgm.gain = audioCtx.createGain();
    bgm.gain.gain.value = 0.0;

    // Arcade mix: light compression so we can push BGM louder without harsh clipping
    bgm.comp = audioCtx.createDynamicsCompressor();
    bgm.comp.threshold.setValueAtTime(-18, audioCtx.currentTime);
    bgm.comp.knee.setValueAtTime(12, audioCtx.currentTime);
    bgm.comp.ratio.setValueAtTime(6, audioCtx.currentTime);
    bgm.comp.attack.setValueAtTime(0.003, audioCtx.currentTime);
    bgm.comp.release.setValueAtTime(0.12, audioCtx.currentTime);

    bgm.gain.connect(bgm.comp);
    bgm.comp.connect(audioCtx.destination);
  }
  if (!bgm.noiseBuf) {
    const dur = 0.20;
    const len = Math.floor(audioCtx.sampleRate * dur);
    const buf = audioCtx.createBuffer(1, len, audioCtx.sampleRate);
    const ch = buf.getChannelData(0);
    for (let i=0;i<len;i++) ch[i] = (Math.random()*2 - 1) * 0.85;
    bgm.noiseBuf = buf;
  }
}

function chipNote(time, midi, dur, type, gain=0.07, detune=0) {
  if (!audioCtx || !bgm.gain) return;
  if (midi === null) return;

  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();

  o.type = type;
  o.frequency.setValueAtTime(mtof(midi), time);
  if (detune) o.detune.setValueAtTime(detune, time);

  // envelope
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.03, dur));

  o.connect(g);
  g.connect(bgm.gain);

  o.start(time);
  o.stop(time + Math.max(0.04, dur + 0.02));
}

function chipHat(time, dur=0.05, gain=0.035) {
  if (!audioCtx || !bgm.gain || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const hp = audioCtx.createBiquadFilter();
  hp.type = "highpass";
  hp.frequency.setValueAtTime(7000, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.02, dur));

  src.connect(hp);
  hp.connect(g);
  g.connect(bgm.gain);

  src.start(time);
  src.stop(time + Math.max(0.03, dur + 0.02));
}

function chipSnare(time, dur=0.10, gain=0.06) {
  if (!audioCtx || !bgm.gain || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const bp = audioCtx.createBiquadFilter();
  bp.type = "bandpass";
  bp.frequency.setValueAtTime(1800, time);
  bp.Q.setValueAtTime(0.8, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.004);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.05, dur));

  src.connect(bp);
  bp.connect(g);
  g.connect(bgm.gain);

  src.start(time);
  src.stop(time + Math.max(0.06, dur + 0.03));
}
function chipCrash(time, dur=0.35, gain=0.080) {
  if (!audioCtx || !bgm.gain || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const hp = audioCtx.createBiquadFilter();
  hp.type = "highpass";
  hp.frequency.setValueAtTime(2400, time);

  const bp = audioCtx.createBiquadFilter();
  bp.type = "bandpass";
  bp.frequency.setValueAtTime(6200, time);
  bp.Q.setValueAtTime(0.55, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.006);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.12, dur));

  src.connect(hp);
  hp.connect(bp);
  bp.connect(g);
  g.connect(bgm.gain);

  src.start(time);
  src.stop(time + Math.max(0.14, dur + 0.05));
}




function chipKick(time, dur=0.12, gain=0.09) {
  if (!audioCtx || !bgm.gain) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.setValueAtTime(140, time);
  o.frequency.exponentialRampToValueAtTime(60, time + Math.max(0.05, dur));
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.006);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.05, dur));
  o.connect(g); g.connect(bgm.gain);
  o.start(time);
  o.stop(time + Math.max(0.06, dur + 0.03));
}
function bgmStepSec() {
  return (60 / bgm.tempo) / 4; // 16th note
}

// 64-step loop (4 bars of 16th notes)
const BGM_LEN = 64;

// Melody (midi notes) - upbeat chiptune line (original pattern)
const MEL = [
// 4 bars (64 steps). E minor feel, fast arps + hooks.
83,86,88,86, 83,79,76,79, 83,86,88,91, 88,86,83,79,
81,83,84,83, 81,79,76,74, 76,79,81,83, 81,79,76,79,

88,91,93,91, 88,86,83,86, 88,91,93,95, 93,91,88,86,
84,86,88,86, 84,83,81,79, 81,83,84,86, 84,83,81,79,
];

// Harmony (a bit lower, simpler)
const HAR = [
// Harmony/2nd pulse (lower), mostly chord tones
71,74,76,74, 71,67,64,67, 71,74,76,79, 76,74,71,67,
69,71,72,71, 69,67,64,62, 64,67,69,71, 69,67,64,67,

76,79,81,79, 76,74,71,74, 76,79,81,83, 81,79,76,74,
72,74,76,74, 72,71,69,67, 69,71,72,74, 72,71,69,67,
];

// Bass (triangle), hits on 8ths
const BAS = [
// Bass (triangle): roots + walking movement (8ths with occasional pickups)
40,null,40,null, 43,null,43,null, 45,null,45,null, 47,null,47,null,
36,null,36,null, 38,null,38,null, 40,null,40,null, 43,null,43,null,

40,null,40,null, 43,null,43,null, 47,null,47,null, 45,null,45,null,
36,null,36,null, 38,null,38,null, 40,null,40,null, 35,null,35,null,
];

// Arp/Counter (square): fast upper arpeggio to make it more "shooting game" vivid
const ARP = [
  95,91,88,91, 95,91,88,91, 96,93,89,93, 96,93,89,93,
  95,91,88,91, 95,91,88,91, 98,95,91,95, 98,95,91,95,

  100,96,93,96, 100,96,93,96, 98,95,91,95, 98,95,91,95,
  96,93,89,93, 96,93,89,93, 95,91,88,91, 95,91,88,91,
];

// Drums: hat every 16th, snare on 2&4 (steps 16,48), plus extra hits
function scheduleBGMNote(time, step) {
  const i = step % BGM_LEN;
  const barStep = i % 16;

  // --- tonal layers ---
  // lead + harmony: brighter, slightly shorter for punch
    // lead: detuned double-square for aggressive arcade thickness
  chipNote(time, MEL[i], 0.075, "square", 0.120, -10);
  chipNote(time, MEL[i], 0.075, "square", 0.120, +10);
  // harmony: keep under the lead
  chipNote(time, HAR[i], 0.080, "square", 0.070, -18);

  // bass (triangle): keep it driving
  chipNote(time, BAS[i], 0.140, "triangle", 0.110, 0);

  // upper arp: makes it feel more "shooting game"
  // (small gain so it doesn't mask SFX)
  chipNote(time, ARP[i], 0.060, "square", 0.075, 12);

  // --- drums / groove ---
  // hats: stronger + occasional open-hat feel
  chipHat(time, 0.045, 0.045);
  if (barStep === 2 || barStep === 6 || barStep === 10 || barStep === 14) {
    chipHat(time, 0.080, 0.030);
  }

  // kick: double-kick on downbeats + pickup before snare
  if (barStep === 0 || barStep === 8) {
    chipKick(time, 0.16, 0.120);
    chipKick(time + 0.02, 0.12, 0.075);
  }
  if (barStep === 3 || barStep === 11) chipKick(time, 0.12, 0.080);

  // snare: 2&4 + extra ghost note
  if (barStep === 4 || barStep === 12) chipSnare(time, 0.12, 0.110);
  if (barStep === 7 || barStep === 15) chipSnare(time, 0.07, 0.070);
  // end-of-bar roll
  if (barStep === 14) chipSnare(time, 0.08, 0.060);
  if (barStep === 15) chipSnare(time + 0.02, 0.06, 0.050);

  // crash on bar start (strong)
  if (barStep === 0) chipCrash(time, 0.35, 0.085);
}

function bgmSchedulerTick() {
  if (!audioCtx || !bgm.on) return;
  const now = audioCtx.currentTime;
  while (bgm.nextTime < now + bgm.scheduleAhead) {
    scheduleBGMNote(bgm.nextTime, bgm.step);
    bgm.step = (bgm.step + 1) % BGM_LEN;
    bgm.nextTime += bgmStepSec();
  }
}

function startBGM() {
  ensureAudio().then(() => {
    initBGMIfNeeded();
    if (!audioCtx || !bgm.gain) return;

    try { console.log('[BGM] startBGM ARCADE v3 tempo=', bgm.tempo, 'targetGain=0.42'); } catch(e) {}

    // fade in
    const t = audioCtx.currentTime;
    bgm.gain.gain.cancelScheduledValues(t);
    bgm.gain.gain.setValueAtTime(Math.max(0.0001, bgm.gain.gain.value), t);
    bgm.gain.gain.exponentialRampToValueAtTime(0.42, t + 0.22);

    if (bgm.on) return;
    bgm.on = true;
    bgm.step = bgm.step % BGM_LEN;
    bgm.nextTime = audioCtx.currentTime + 0.05;
    bgm.timer = setInterval(bgmSchedulerTick, Math.floor(bgm.lookahead * 1000));
  }).catch((err) => {
    console.error("startBGM resume failed:", err);
  });
}

function pauseBGM(paused) {
  if (!audioCtx || !bgm.gain) return;
  const t = audioCtx.currentTime;
  bgm.gain.gain.cancelScheduledValues(t);
  bgm.gain.gain.setValueAtTime(Math.max(0.0001, bgm.gain.gain.value), t);
  bgm.gain.gain.exponentialRampToValueAtTime(paused ? 0.0001 : 0.42, t + 0.18);
}

function stopBGM() {
  if (!audioCtx || !bgm.gain) { bgm.on = false; return; }
  const t = audioCtx.currentTime;
  bgm.gain.gain.cancelScheduledValues(t);
  bgm.gain.gain.setValueAtTime(Math.max(0.0001, bgm.gain.gain.value), t);
  bgm.gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.20);

  bgm.on = false;
  if (bgm.timer) { clearInterval(bgm.timer); bgm.timer = null; }
}


// --- Boss intro + Boss BGM (phase 1/2) ---
let bossIntro = { active:false, t:0, dur:2.2, flash:0.0 };

let bossBgm = {
  on:false,
  timer:null,
  tempo:168,
  lookahead:0.10,
  scheduleAhead:0.18,
  step:0,
  nextTime:0,
  gain:null,
  mode:1, // 1 or 2
};

function initBossBGMIfNeeded() {
  if (!audioCtx) return;
  initBGMIfNeeded(); // reuse noise buffer
  if (!bossBgm.gain) {
    bossBgm.gain = audioCtx.createGain();
    bossBgm.gain.gain.value = 0.0;
    bossBgm.gain.connect(audioCtx.destination);
  }
}

function chipNoteBus(time, midi, dur, type, outGainNode, gain=0.07, detune=0) {
  if (!audioCtx || !outGainNode) return;
  if (midi === null) return;

  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();

  o.type = type;
  o.frequency.setValueAtTime(mtof(midi), time);
  if (detune) o.detune.setValueAtTime(detune, time);

  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.03, dur));

  o.connect(g);
  g.connect(outGainNode);

  o.start(time);
  o.stop(time + Math.max(0.04, dur + 0.02));
}

function chipHatBus(time, dur, outGainNode, gain=0.03) {
  if (!audioCtx || !outGainNode || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const hp = audioCtx.createBiquadFilter();
  hp.type = "highpass";
  hp.frequency.setValueAtTime(7800, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.005);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.02, dur));

  src.connect(hp);
  hp.connect(g);
  g.connect(outGainNode);

  src.start(time);
  src.stop(time + Math.max(0.03, dur + 0.02));
}

function chipKickBus(time, dur, outGainNode, gain=0.085) {
  if (!audioCtx || !outGainNode) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.setValueAtTime(150, time);
  o.frequency.exponentialRampToValueAtTime(55, time + Math.max(0.05, dur));
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.006);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.05, dur));
  o.connect(g); g.connect(outGainNode);
  o.start(time);
  o.stop(time + Math.max(0.06, dur + 0.03));
}

function chipSnareBus(time, dur, outGainNode, gain=0.06) {
  if (!audioCtx || !outGainNode || !bgm.noiseBuf) return;
  const src = audioCtx.createBufferSource();
  src.buffer = bgm.noiseBuf;

  const bp = audioCtx.createBiquadFilter();
  bp.type = "bandpass";
  bp.frequency.setValueAtTime(2100, time);
  bp.Q.setValueAtTime(0.9, time);

  const g = audioCtx.createGain();
  g.gain.setValueAtTime(0.0001, time);
  g.gain.exponentialRampToValueAtTime(gain, time + 0.004);
  g.gain.exponentialRampToValueAtTime(0.0001, time + Math.max(0.05, dur));

  src.connect(bp);
  bp.connect(g);
  g.connect(outGainNode);

  src.start(time);
  src.stop(time + Math.max(0.06, dur + 0.03));
}

function bossBgmStepSec() {
  return (60 / bossBgm.tempo) / 4; // 16th note
}

const BOSS_BGM_LEN = 64;

// Phase 1: heavy, tense ostinato (original pattern)
const BOSS_MEL_1 = [
  76,null,76,null, 79,null,78,null, 76,null,74,null, 73,null,74,null,
  76,null,76,null, 79,null,81,null, 83,null,81,null, 79,null,78,null,

  76,null,76,null, 79,null,78,null, 76,null,74,null, 73,null,74,null,
  69,null,69,null, 71,null,73,null, 74,null,73,null, 71,null,69,null,
];

const BOSS_HAR_1 = [
  64,null,64,null, 67,null,66,null, 64,null,62,null, 61,null,62,null,
  64,null,64,null, 67,null,69,null, 71,null,69,null, 67,null,66,null,

  64,null,64,null, 67,null,66,null, 64,null,62,null, 61,null,62,null,
  57,null,57,null, 59,null,61,null, 62,null,61,null, 59,null,57,null,
];

const BOSS_BAS_1 = [
  33,null,33,null, 33,null,33,null, 36,null,36,null, 36,null,36,null,
  38,null,38,null, 38,null,38,null, 36,null,36,null, 35,null,35,null,

  33,null,33,null, 33,null,33,null, 36,null,36,null, 36,null,36,null,
  31,null,31,null, 31,null,31,null, 33,null,33,null, 28,null,28,null,
];

// Phase 2: faster + brighter lead, more aggressive drums (original pattern)
const BOSS_MEL_2 = [
  83,86,88,86, 83,79,78,79, 83,86,90,88, 86,83,81,83,
  86,88,90,88, 86,83,81,79, 81,83,86,83, 81,79,78,79,

  88,90,93,90, 88,86,83,86, 88,90,95,93, 90,88,86,83,
  81,83,86,83, 81,79,78,79, 83,86,88,86, 83,81,79,78,
];

const BOSS_HAR_2 = [
  71,74,76,74, 71,67,66,67, 71,74,78,76, 74,71,69,71,
  74,76,78,76, 74,71,69,67, 69,71,74,71, 69,67,66,67,

  76,78,81,78, 76,74,71,74, 76,78,83,81, 78,76,74,71,
  69,71,74,71, 69,67,66,67, 71,74,76,74, 71,69,67,66,
];

const BOSS_BAS_2 = [
  40,null,40,null, 43,null,43,null, 45,null,45,null, 47,null,47,null,
  45,null,45,null, 43,null,43,null, 40,null,40,null, 38,null,38,null,

  40,null,40,null, 43,null,43,null, 47,null,47,null, 45,null,45,null,
  40,null,40,null, 38,null,38,null, 36,null,36,null, 35,null,35,null,
];

function scheduleBossBGMNote(time, step) {
  const i = step % BOSS_BGM_LEN;
  const barStep = i % 16;

  const mel = (bossBgm.mode === 2) ? BOSS_MEL_2 : BOSS_MEL_1;
  const har = (bossBgm.mode === 2) ? BOSS_HAR_2 : BOSS_HAR_1;
  const bas = (bossBgm.mode === 2) ? BOSS_BAS_2 : BOSS_BAS_1;

  const leadGain = (bossBgm.mode === 2) ? 0.095 : 0.080;
  const harGain  = (bossBgm.mode === 2) ? 0.060 : 0.055;
  const basGain  = (bossBgm.mode === 2) ? 0.090 : 0.085;

  chipNoteBus(time, mel[i], 0.090, "square", bossBgm.gain, leadGain, 0);
  chipNoteBus(time, har[i], 0.090, "square", bossBgm.gain, harGain, -10);
  chipNoteBus(time, bas[i], 0.140, "triangle", bossBgm.gain, basGain, 0);

  // drums
  const hatGain = (bossBgm.mode === 2) ? 0.034 : 0.028;
  chipHatBus(time, 0.045, bossBgm.gain, hatGain);

  // kick/snare accents
  if (barStep === 0 || barStep === 8) chipKickBus(time, 0.12, bossBgm.gain, bossBgm.mode === 2 ? 0.095 : 0.085);
  if (barStep === 4 || barStep === 12) chipSnareBus(time, 0.10, bossBgm.gain, bossBgm.mode === 2 ? 0.080 : 0.070);

  if (bossBgm.mode === 2) {
    // extra fill for phase 2
    if (barStep === 14) chipSnareBus(time, 0.06, bossBgm.gain, 0.055);
    if (barStep === 15) chipHatBus(time, 0.06, bossBgm.gain, 0.045);
  } else {
    if (barStep === 15) chipSnareBus(time, 0.06, bossBgm.gain, 0.045);
  }
}

function bossBgmSchedulerTick() {
  if (!audioCtx || !bossBgm.on) return;
  const now = audioCtx.currentTime;
  while (bossBgm.nextTime < now + bossBgm.scheduleAhead) {
    scheduleBossBGMNote(bossBgm.nextTime, bossBgm.step);
    bossBgm.step = (bossBgm.step + 1) % BOSS_BGM_LEN;
    bossBgm.nextTime += bossBgmStepSec();
  }
}

function startBossBGM(mode=1) {
  ensureAudio().then(() => {
    initBossBGMIfNeeded();
    if (!audioCtx || !bossBgm.gain) return;

    bossBgm.mode = mode;
    bossBgm.tempo = (mode === 2) ? 186 : 168;

    // fade in
    const t = audioCtx.currentTime;
    bossBgm.gain.gain.cancelScheduledValues(t);
    bossBgm.gain.gain.setValueAtTime(Math.max(0.0001, bossBgm.gain.gain.value), t);
    bossBgm.gain.gain.exponentialRampToValueAtTime(0.20, t + 0.20);

    if (bossBgm.on) return;
    bossBgm.on = true;
    bossBgm.step = bossBgm.step % BOSS_BGM_LEN;
    bossBgm.nextTime = audioCtx.currentTime + 0.05;
    bossBgm.timer = setInterval(bossBgmSchedulerTick, Math.floor(bossBgm.lookahead * 1000));
  }).catch((err) => {
    console.error("startBossBGM resume failed:", err);
  });
}

function stopBossBGM() {
  if (!audioCtx || !bossBgm.gain) { bossBgm.on = false; return; }
  const t = audioCtx.currentTime;
  bossBgm.gain.gain.cancelScheduledValues(t);
  bossBgm.gain.gain.setValueAtTime(Math.max(0.0001, bossBgm.gain.gain.value), t);
  bossBgm.gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.18);

  bossBgm.on = false;
  if (bossBgm.timer) { clearInterval(bossBgm.timer); bossBgm.timer = null; }
}

function bossIntroFlash(str=0.7) {
  bossIntro.flash = Math.max(bossIntro.flash, str);
}

function triggerBossIntro() {
  bossIntro.active = true;
  bossIntro.t = 0;
  bossIntro.dur = 2.2;
  bossIntro.flash = 0.9;
  sfx("warn");
  // a couple of warning chirps
  setTimeout(() => { try { sfx("warn"); } catch {} }, 260);
  setTimeout(() => { try { sfx("warn"); } catch {} }, 520);
}
// --- /Boss intro + Boss BGM ---

// --- /BGM ---


  class Pool {
    constructor(create, cap=256) { this.create=create; this.items=[]; this.cap=cap; }
    get() { return this.items.pop() || this.create(); }
    put(o) { if (this.items.length < this.cap) this.items.push(o); }
  }


  const shotPool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,r:4,ttl:0,kind:"shot",dmg:1}), 600);
  const enemyShotPool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,r:5,ttl:0,kind:"e",homing:0,spd:0}), 900);
  const missilePool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,r:5,ttl:0,trail:0,dmg:2}), 200);
  const fxPool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,ttl:0,size:0,kind:"spark"}), 900);
  const capsulePool = new Pool(() => ({active:false,x:0,y:0,vx:0,vy:0,r:10,ttl:0}), 32);

  const enemyPool = new Pool(() => ({
    active:false, x:0,y:0,vx:0,vy:0, r:16, hp:1, score:100,
    ai:"", t:0, p:0, w:32,h:32, solid:false
  }), 220);

  const gaugeItems = ["SPEED","MISSILE","DOUBLE","LASER","OPTION","SHIELD"];
  const gaugeLabels = {SPEED:"スピード",MISSILE:"ミサイル",DOUBLE:"ダブル",LASER:"レーザー",OPTION:"オプション",SHIELD:"シールド"};
  let gaugeProgress = -1; // 初期は未選択 // 0..len-1 as step
  let gaugeReady = false;

  let paused = false;
  let started = false;

  let score = 0;
  let lives = 3;

  let checkpoint = "A";
  let stageTime = 0;      // seconds since stage start (from last checkpoint restart, we use absolute stage timeline for spawns)
  let stageTimeAbs = 0;   // absolute stage time across deaths (to preserve progression). We'll reset to checkpoint time on death.
  let progressMaxAbs = 0;   // 到達した最大の絶対時間（死亡で戻さない）
  let stageTimeGlobal = 0; // 死亡で巻き戻さない進捗用タイム
  let section = "A";

  const checkpointTimes = { A:0, C:150, M:280, B:370 }; // seconds in the stage timeline

  const player = {
    x: 220, y: H*0.5,
    vx:0, vy:0,
    w: 42, h: 24, // sprite box
    hx: 22, hy: 12, // hitbox half-size (smaller)
    invuln: 0,
    speedLevel: 0, // 0..2
    missile: false,
    shotLevel: 0, // 0:single 1:double
    hasLaser: false,
    options: 0,   // 0..2
    shield: 0,    // 0..1
    fireCD: 0,
    missileCD: 0,
    alive: true,
    trail: [], // for options follow
    laserOn: false,
    laserSfx: 0,
    optionLaserOn: 0,
  };

  const optionDelayFrames = [10, 20]; // 2 options
  const optionPos = [{x:player.x,y:player.y},{x:player.x,y:player.y}];

  let terrain = []; // array of {x,y,w,h} AABB blocks (solid)
  let terrainHint = []; // for rendering outlines (lightweight)

  let shots = [];
  let enemyShots = [];
  let missiles = [];
  let enemies = [];
  let capsules = [];
  let fx = [];

  let midboss = null;
  let boss = null;

  let director = { midbossStarted:false, midbossDead:false, bossStarted:false, bossDead:false, warnOutcrop:false,
    pMidIdx:0, pMidActive:false,
    bossPhase2Bgm:false
  };

  let fps = 0, fpsAcc = 0, fpsFrames = 0;

  function renderGaugeUI() {
    elGauge.innerHTML = "";
    for (let i=0;i<gaugeItems.length;i++) {
      const d = document.createElement("div");
      d.className = "cell";
      d.textContent = gaugeLabels[gaugeItems[i]] || gaugeItems[i];
      if (gaugeProgress >= 0 && i === gaugeProgress) d.classList.add("active");
      if (gaugeProgress >= 0 && gaugeReady && i === gaugeProgress) d.classList.add("ready");
      elGauge.appendChild(d);
    }
  }

  function renderLivesUI() {
    elLives.innerHTML = "";
    const label = document.createElement("span");
    label.textContent = "残機：";
    label.style.marginRight = "8px";
    elLives.appendChild(label);

    for (let i=0;i<3;i++) {
      const d = document.createElement("div");
      d.className = "life" + (i < lives ? " on" : "");
      elLives.appendChild(d);
    }
  }

  function setCheckpointLabel() {
    const cpMap = {A:"A（開始）", C:"C（洞窟）", M:"M（中ボス）", B:"B（ボス）"};
    elCP.textContent = cpMap[checkpoint] || checkpoint;
  }

  function circleHit(a, b) {
    const dx = a.x - b.x, dy = a.y - b.y;
    const rr = (a.r + b.r);
    return dx*dx + dy*dy <= rr*rr;
  }

  function playerHitCircle(c) {
    const px1 = player.x - player.hx, px2 = player.x + player.hx;
    const py1 = player.y - player.hy, py2 = player.y + player.hy;
    const cx = c.x, cy = c.y, r = c.r;
    const nx = clamp(cx, px1, px2);
    const ny = clamp(cy, py1, py2);
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy <= r*r;
  }

  function rectOverlap(ax,ay,aw,ah, bx,by,bw,bh) {
    return (ax < bx+bw && ax+aw > bx && ay < by+bh && ay+ah > by);
  }

  function clearTerrain() { terrain.length = 0; terrainHint.length = 0; }

  function genCave(sectionId) {
    clearTerrain();
    const tile = 32;
    const length = (sectionId === "C") ? 2200 : 1800; // px world length
    const startX = 0;
    const cols = Math.floor(length / tile);
    const blocks = [];

    let baseCeil = (sectionId === "C") ? 110 : 100;
    let baseFloor = (sectionId === "C") ? 660 : 670;
    let amp = (sectionId === "C") ? 70 : 55;
    let freq = (sectionId === "C") ? 0.07 : 0.09;

    const pinch = (sectionId === "C") ? [
      {x: 620, w: 300, shrink: 150},
      {x: 1450, w: 260, shrink: 170},
    ] : [];

    for (let i=0;i<cols;i++) {
      const x = startX + i*tile;
      const s = Math.sin((x*freq));
      const s2 = Math.sin((x*freq*0.57)+1.8);
      let ceil = baseCeil + (s*amp*0.6) + (s2*amp*0.25);
      let floor = baseFloor + (s*amp*0.55) - (s2*amp*0.25);

      for (const p of pinch) {
        if (x >= p.x && x <= p.x + p.w) {
          const t = (x - p.x) / p.w;
          const k = 1 - Math.abs(t-0.5)*2; // peak at middle
          ceil += k * (p.shrink*0.55);
          floor -= k * (p.shrink*0.55);
        }
      }

      ceil = clamp(ceil, 30, 260);
      floor = clamp(floor, 420, 710);

      const ceilRows = Math.ceil(ceil / tile);
      for (let r=0;r<ceilRows;r++) blocks.push({x, y:r*tile, w:tile, h:tile});
      const floorRowsStart = Math.floor(floor / tile);
      for (let r=floorRowsStart;r<Math.ceil(H/tile);r++) blocks.push({x, y:r*tile, w:tile, h:tile});

      terrainHint.push({x, ceilY: ceil, floorY: floor});
    }

    terrain.push(...blocks);
  }

  function genOutcrop() {
  }

  function drawBackground(t) {
    ctx.fillStyle = "#060812";
    ctx.fillRect(0,0,W,H);

    const baseX = (t*120) % W;        // scroll speed
    const baseX2 = (t*60) % W;

    ctx.globalAlpha = 0.9;
    ctx.fillStyle = "#0f1530";
    for (let i=0;i<90;i++) {
      const x = (i*73 + (W-baseX)) % W;
      const y = (i*151) % H;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 0.7;
    ctx.fillStyle = "#1b2a66";
    for (let i=0;i<60;i++) {
      const x = (i*127 + (W-baseX2)) % W;
      const y = (i*193 + 90) % H;
      ctx.fillRect(x, y, 1, 1);
    }
    ctx.globalAlpha = 1;
  }

  function drawTerrain(worldOffsetX) {
    if (terrainHint.length === 0) return;
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    for (const b of terrain) {
      const sx = b.x - worldOffsetX;
      if (sx < -64 || sx > W+64) continue;
      ctx.fillRect(sx, b.y, b.w, b.h);
    }

    ctx.strokeStyle = "rgba(231,236,255,0.12)";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (const h of terrainHint) {
      const sx = h.x - worldOffsetX;
      if (sx < -64 || sx > W+64) continue;
      ctx.moveTo(sx, h.ceilY);
      ctx.lineTo(sx+32, h.ceilY);
      ctx.moveTo(sx, h.floorY);
      ctx.lineTo(sx+32, h.floorY);
    }
    ctx.stroke();
  }

  function drawPlayer() {
    const blink = player.invuln > 0 ? (Math.floor(player.invuln*12)%2===0) : false;
    if (blink) ctx.globalAlpha = 0.45;

    ctx.save();
    ctx.translate(player.x, player.y);
    ctx.fillStyle = "#c9d3ff";
    ctx.beginPath();
    ctx.moveTo(-18, -10);
    ctx.lineTo(16, 0);
    ctx.lineTo(-18, 10);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#4dd7ff";
    ctx.fillRect(-8, -4, 10, 8);

    ctx.fillStyle = "#92a2ff";
    ctx.fillRect(-24, -6, 8, 12);

    ctx.restore();
    ctx.globalAlpha = 1;

    if (player.shield > 0) {
      ctx.strokeStyle = "rgba(54,211,153,0.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.ellipse(player.x, player.y, 34, 22, 0, 0, TAU);
      ctx.stroke();
    }

  }

  function drawOptions() {
    if (player.options <= 0) return;
    for (let i=0;i<player.options;i++) {
      const p = optionPos[i];
      ctx.strokeStyle = "rgba(231,236,255,0.7)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 11, 0, TAU);
      ctx.stroke();
      ctx.fillStyle = "rgba(231,236,255,0.12)";
      ctx.beginPath();
      ctx.arc(p.x, p.y, 11, 0, TAU);
      ctx.fill();
    }
  }

  function drawShots() {
    const tt = performance.now() * 0.001;

    // Laser beam (continuous)
    if (player.laserOn) {
      const x0 = player.x + 22;
      const x1 = W + 20;
      const y = player.y;
      const flick = 0.75 + 0.25*Math.sin(tt*38 + y*0.03);
      const outerH = 14 * flick;
      const innerH = 5.0;

      ctx.save();
      ctx.globalCompositeOperation = "lighter";

      // Outer glow
      ctx.globalAlpha = 0.32 * flick;
      ctx.fillStyle = "rgba(90,190,255,1.0)";
      ctx.fillRect(x0, y - outerH*0.5, x1 - x0, outerH);

      // Core
      ctx.globalAlpha = 0.95;
      const g = ctx.createLinearGradient(x0, y, x1, y);
      g.addColorStop(0.0, "rgba(90,190,255,0.00)");
      g.addColorStop(0.08, "rgba(90,190,255,0.95)");
      g.addColorStop(0.18, "rgba(255,255,255,1.00)");
      g.addColorStop(0.92, "rgba(90,190,255,0.95)");
      g.addColorStop(1.0, "rgba(90,190,255,0.00)");
      ctx.fillStyle = g;
      ctx.fillRect(x0, y - innerH*0.5, x1 - x0, innerH);

      ctx.restore();
    }

    // Option lasers
    if (player.optionLaserOn > 0) {
      for (let i=0;i<player.optionLaserOn;i++) {
        const p = optionPos[i];
        const x0 = p.x + 18;
        const x1 = W + 20;
        const y = p.y;
        const flick = 0.75 + 0.25*Math.sin(tt*38 + y*0.03 + i*1.7);
        const outerH = 12 * flick;
        const innerH = 4.5;

        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = 0.28 * flick;
        ctx.fillStyle = "rgba(90,190,255,1.0)";
        ctx.fillRect(x0, y - outerH*0.5, x1 - x0, outerH);

        ctx.globalAlpha = 0.88;
        const g = ctx.createLinearGradient(x0, y, x1, y);
        g.addColorStop(0.0, "rgba(90,190,255,0.00)");
        g.addColorStop(0.10, "rgba(90,190,255,0.88)");
        g.addColorStop(0.20, "rgba(255,255,255,0.92)");
        g.addColorStop(0.90, "rgba(90,190,255,0.88)");
        g.addColorStop(1.0, "rgba(90,190,255,0.00)");
        ctx.fillStyle = g;
        ctx.fillRect(x0, y - innerH*0.5, x1 - x0, innerH);

        ctx.restore();
      }
    }

    // Player normal shots
    ctx.fillStyle = "rgba(231,236,255,0.95)";
    for (const s of shots) {
      if (!s.active) continue;
      ctx.fillRect(s.x-6, s.y-1.5, 12, 3);
    }

    // Missiles
    ctx.fillStyle = "rgba(54,211,153,0.92)";
    for (const m of missiles) {
      if (!m.active) continue;
      ctx.fillRect(m.x-5, m.y-2, 10, 4);
    }

    // Enemy bullets
    ctx.fillStyle = "rgba(255,75,75,0.92)";
    for (const b of enemyShots) {
      if (!b.active) continue;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, TAU);
      ctx.fill();
    }
  }



  function drawEnemies() {
    const tt = performance.now() * 0.001;
    for (const e of enemies) {
      if (!e.active) continue;

      // 共有：簡易メタル質感
      function metalFill(x, y, w, h, a0=0.75, a1=0.18) {
        const g = ctx.createLinearGradient(x, y-h*0.4, x, y+h*0.6);
        g.addColorStop(0, `rgba(231,236,255,${a0})`);
        g.addColorStop(0.35, `rgba(140,170,210,${a1})`);
        g.addColorStop(1, `rgba(231,236,255,${a0*0.55})`);
        ctx.fillStyle = g;
      }
      function glowCore(x,y,r,alpha=0.85){
        const g = ctx.createRadialGradient(x,y,0,x,y,r*1.4);
        g.addColorStop(0, `rgba(255,75,75,${alpha})`);
        g.addColorStop(0.45, `rgba(255,75,75,${alpha*0.35})`);
        g.addColorStop(1, `rgba(255,75,75,0)`);
        ctx.fillStyle=g;
        ctx.beginPath(); ctx.arc(x,y,r*1.2,0,TAU); ctx.fill();
        ctx.fillStyle=`rgba(255,75,75,${alpha})`;
        ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
      }
      function thruster(x,y,scale=1){
        const p = 0.5 + 0.5*Math.sin(tt*10 + x*0.03);
        const len = (18 + 10*p) * scale;
        const g = ctx.createLinearGradient(x, y, x-len, y);
        g.addColorStop(0, `rgba(120,200,255,${0.55+0.25*p})`);
        g.addColorStop(0.6, `rgba(120,200,255,${0.15+0.15*p})`);
        g.addColorStop(1, `rgba(120,200,255,0)`);
        ctx.fillStyle=g;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x-len, y-6*scale);
        ctx.lineTo(x-len, y+6*scale);
        ctx.closePath();
        ctx.fill();
      }


      function bolt(x,y,r=1.2,a=0.45){
        ctx.fillStyle=`rgba(231,236,255,${a})`;
        ctx.beginPath(); ctx.arc(x,y,r,0,TAU); ctx.fill();
        ctx.strokeStyle=`rgba(0,0,0,${a*0.35})`;
        ctx.lineWidth=1;
        ctx.beginPath(); ctx.moveTo(x-r*0.6,y); ctx.lineTo(x+r*0.6,y); ctx.stroke();
      }
      function panelLines(points, a=0.22){
        ctx.strokeStyle=`rgba(0,0,0,${a})`;
        ctx.lineWidth=1;
        ctx.beginPath();
        for(const [x1,y1,x2,y2] of points){ ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); }
        ctx.stroke();
      }
      function hazardStripe(x,y,w,h,phase=0){
        ctx.save();
        ctx.translate(x,y);
        ctx.beginPath(); ctx.roundRect(-w/2,-h/2,w,h,4); ctx.clip();
        ctx.globalAlpha=0.55;
        ctx.rotate(-0.45);
        ctx.fillStyle="rgba(255,220,140,0.85)";
        for(let i=-w*2;i<w*2;i+=10){
          ctx.fillRect(i+phase, -h*2, 5, h*4);
        }
        ctx.globalAlpha=1;
        ctx.restore();
      }

      ctx.save();
      ctx.translate(e.x, e.y);

      if (e.ai === "turret") {
        // 角型砲台：メタル面＋砲身＋赤いコア
        metalFill(-16, -16, 32, 32, 0.75, 0.22);
        ctx.beginPath();
        ctx.roundRect(-16,-16,32,32,8);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.28)";
        ctx.lineWidth=2;
        ctx.stroke();

        // 面取り＆パネルライン
        ctx.strokeStyle="rgba(0,0,0,0.22)";
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-12,-6); ctx.lineTo(12,-6);
        ctx.moveTo(-12,6); ctx.lineTo(12,6);
        ctx.stroke();

        // 砲身
        ctx.fillStyle="rgba(231,236,255,0.22)";
        ctx.fillRect(-2,-4,20,8);
        ctx.strokeStyle="rgba(231,236,255,0.25)";
        ctx.strokeRect(-2,-4,20,8);

        glowCore(0,0,4,0.9);
        // ボルト＆警告ストライプ
        bolt(-10,-10,1.2,0.40); bolt(10,-10,1.2,0.40); bolt(-10,10,1.2,0.40); bolt(10,10,1.2,0.40);
        hazardStripe(-6,0,10,20, (tt*40)%10);

      } else if (e.ai === "droneSine") {
        // ドローン：船体＋キャノピー＋翼灯（メカ寄り強化）
        metalFill(-22,-14,44,28,0.62,0.18);
        ctx.beginPath();
        ctx.ellipse(0,0,20,12,0,0,TAU);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.25)";
        ctx.lineWidth=2;
        ctx.stroke();

        // キャノピー
        const cg = ctx.createRadialGradient(6,-3,2,6,-3,12);
        cg.addColorStop(0,"rgba(120,200,255,0.55)");
        cg.addColorStop(1,"rgba(120,200,255,0.05)");
        ctx.fillStyle=cg;
        ctx.beginPath();
        ctx.ellipse(6,-3,10,7,0.15,0,TAU);
        ctx.fill();

        // 翼
        ctx.fillStyle="rgba(231,236,255,0.10)";
        ctx.beginPath();
        ctx.moveTo(-6,0); ctx.lineTo(-22,-10); ctx.lineTo(-18,0); ctx.lineTo(-22,10);
        ctx.closePath();
        ctx.fill();

        // 追加：装甲プレート＆ベント
        ctx.fillStyle='rgba(0,0,0,0.18)';
        ctx.beginPath();
        ctx.moveTo(2,-10); ctx.lineTo(18,-6); ctx.lineTo(12,-1); ctx.lineTo(-2,-3);
        ctx.closePath(); ctx.fill();
        panelLines([[-12,-2,12,-2],[-6,6,10,6],[4,-8,10,0]],0.20);
        bolt(-8,0,1.1,0.38); bolt(8,0,1.1,0.38);
        ctx.fillStyle='rgba(231,236,255,0.12)'; ctx.fillRect(-16,-2,6,4);
        ctx.fillStyle='rgba(0,0,0,0.28)'; ctx.fillRect(-15,-1,4,2);

        // 翼灯（点滅）
        const blink = 0.35 + 0.35*(0.5+0.5*Math.sin(tt*6 + e.y*0.02));
        ctx.fillStyle=`rgba(54,211,153,${blink})`;
        ctx.beginPath(); ctx.arc(14,0,2.6,0,TAU); ctx.fill();

      } else if (e.ai === "charger") {
        // 突撃機：尖った機首＋可動フィン

        // 突進機：鋭い機首＋エンジン
        metalFill(-18,-10,36,20,0.58,0.16);
        ctx.beginPath();
        ctx.moveTo(18,0);
        ctx.lineTo(2,-12);
        ctx.lineTo(-18,-8);
        ctx.lineTo(-18,8);
        ctx.lineTo(2,12);
        ctx.closePath();
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.22)";
        ctx.lineWidth=2;
        ctx.stroke();

        // コクピット
        ctx.fillStyle="rgba(120,200,255,0.18)";
        ctx.beginPath(); ctx.ellipse(4,0,6,4,0,0,TAU); ctx.fill();

        // 推進炎
        thruster(-18,0,0.9);

      } else if (e.ai === "armored") {
        // 装甲艇：角張った装甲＋キャタピラ風パーツ

        // 装甲機：重装甲パネル＋コア
        metalFill(-26,-18,52,36,0.55,0.14);
        ctx.beginPath();
        ctx.roundRect(-24,-16,48,32,10);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.20)";
        ctx.lineWidth=2;
        ctx.stroke();

        // 装甲パネル
        ctx.strokeStyle="rgba(0,0,0,0.25)";
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-18,-6); ctx.lineTo(18,-6);
        ctx.moveTo(-18,6); ctx.lineTo(18,6);
        ctx.moveTo(-6,-12); ctx.lineTo(-6,12);
        ctx.stroke();

        // コア
        ctx.fillStyle="rgba(54,211,153,0.22)";
        ctx.beginPath(); ctx.roundRect(-10,-7,20,14,6); ctx.fill();
        ctx.strokeStyle="rgba(54,211,153,0.35)";
        ctx.stroke();
        thruster(-24,0,0.75);

      } else if (e.ai === "slime") {
        // メカマイン：球体装甲＋スポーク

        // 有機体：粘膜の層（グラデ＋縁）
        const g = ctx.createRadialGradient(-6,-6,4,0,0,22);
        g.addColorStop(0,"rgba(255,120,120,0.28)");
        g.addColorStop(0.55,"rgba(255,75,75,0.18)");
        g.addColorStop(1,"rgba(255,75,75,0.06)");
        ctx.fillStyle=g;
        ctx.beginPath();
        const wob = 1.0 + 0.06*Math.sin(tt*5 + e.x*0.01);
        ctx.arc(0,0,16*wob,0,TAU);
        ctx.fill();
        ctx.strokeStyle="rgba(255,120,120,0.28)";
        ctx.lineWidth=2;
        ctx.stroke();
        // ハイライト
        ctx.fillStyle="rgba(231,236,255,0.10)";
        ctx.beginPath(); ctx.ellipse(-4,-6,7,4, -0.2, 0, TAU); ctx.fill();

      } else if (e.ai === "midboss") {
        // 中ボス：大型メタル＋派手エフェクト（コア脈動／シールドリング／走査光）
        metalFill(-160,-120,260,240,0.40,0.10);
        ctx.beginPath();
        ctx.roundRect(-150,-110,240,220,18);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.18)";
        ctx.lineWidth=3;
        ctx.stroke();

        // パネルライン
        ctx.strokeStyle="rgba(0,0,0,0.22)";
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(-120,-60); ctx.lineTo(70,-60);
        ctx.moveTo(-120,60); ctx.lineTo(70,60);
        ctx.moveTo(-60,-100); ctx.lineTo(-60,100);
        ctx.stroke();

        // 追加：外周エッジ発光（走査）
        {
          const scan = 0.5 + 0.5*Math.sin(tt*3.2 + e.t*0.8);
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = 0.25 + 0.18*scan;
          const eg = ctx.createLinearGradient(-150,-110, 90,110);
          eg.addColorStop(0.0, "rgba(120,200,255,0.05)");
          eg.addColorStop(0.5, "rgba(120,200,255,0.22)");
          eg.addColorStop(1.0, "rgba(255,220,140,0.10)");
          ctx.strokeStyle = eg;
          ctx.lineWidth = 6;
          ctx.beginPath(); ctx.roundRect(-150,-110,240,220,18); ctx.stroke();
          ctx.restore();
        }

        const open = (e.p >= 1);
        const coreAlpha = open ? 0.95 : 0.30;

        // コア（上下2基）＋リング発光
        function ring(x,y,r,ph){
          const a = 0.45 + 0.35*Math.sin(tt*6.0 + ph + e.t*1.2);
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = a;
          ctx.strokeStyle = "rgba(120,200,255,0.35)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          const t0 = (tt*2.6 + ph) % TAU;
          ctx.arc(x,y,r, t0, t0 + Math.PI*1.35);
          ctx.stroke();
          ctx.globalAlpha = a*0.6;
          ctx.strokeStyle = "rgba(255,220,140,0.22)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x,y,r+7, t0+1.7, t0+1.7 + Math.PI*1.05);
          ctx.stroke();
          ctx.restore();
        }

        glowCore(40,-55,18,coreAlpha);
        glowCore(40,55,18,coreAlpha);
        ring(40,-55,24,0.3);
        ring(40,55,24,2.0);

        // 追加：コア間のエネルギーアーク（開放時だけ）
        if (open) {
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = 0.22 + 0.18*(0.5+0.5*Math.sin(tt*10.0 + e.t*2.0));
          ctx.strokeStyle = "rgba(120,200,255,0.55)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          for (let i=0;i<3;i++){
            const k = i/2;
            const wob = 6*Math.sin(tt*7 + k*4 + e.t*1.3);
            ctx.moveTo(40 + wob, -55 + 10);
            ctx.quadraticCurveTo(30 - wob, 0, 40 + wob, 55 - 10);
          }
          ctx.stroke();
          ctx.restore();
        }

        // 閉鎖シャッター
        if (!open) {
          ctx.fillStyle="rgba(231,236,255,0.14)";
          ctx.beginPath(); ctx.roundRect(14,-85,52,60,10); ctx.fill();
          ctx.beginPath(); ctx.roundRect(14,25,52,60,10); ctx.fill();
        }

        // 追加：周囲シールドリング（常時・薄く）
        {
          const pulse = 0.5 + 0.5*Math.sin(tt*2.2 + e.t*0.9);
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = 0.10 + 0.10*pulse;
          ctx.strokeStyle = "rgba(54,211,153,0.35)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(-20,0, 155, 105, 0, 0, TAU);
          ctx.stroke();
          ctx.globalAlpha *= 0.65;
          ctx.strokeStyle = "rgba(120,200,255,0.25)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(-20,0, 165, 115, 0, 0, TAU);
          ctx.stroke();
          ctx.restore();
        }

        // サイドスラスター
        thruster(-150,-55,1.2);
        thruster(-150,55,1.2);

        // 追加：警告灯（点滅）
        {
          const blink = 0.25 + 0.55*(0.5+0.5*Math.sin(tt*8.0 + e.t*2.8));
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = blink;
          ctx.fillStyle="rgba(255,75,75,0.45)";
          ctx.beginPath(); ctx.arc(-120,-85,4.2,0,TAU); ctx.fill();
          ctx.beginPath(); ctx.arc(-120,85,4.2,0,TAU); ctx.fill();
          ctx.restore();
        }

      } else if (e.ai === "boss") {
        // ボス：巨大艦体＋派手エフェクト（コア多層／シールド／走査ライン強化）
        metalFill(-260,-170,420,340,0.32,0.08);
        ctx.beginPath();
        ctx.roundRect(-250,-160,400,320,24);
        ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.14)";
        ctx.lineWidth=4;
        ctx.stroke();

        // 追加：外装の発光パネル（脈動）
        {
          const p = 0.5 + 0.5*Math.sin(tt*2.4 + e.t*0.9);
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = 0.10 + 0.10*p;
          ctx.fillStyle="rgba(120,200,255,0.18)";
          ctx.beginPath(); ctx.roundRect(-220,-120,70,52,12); ctx.fill();
          ctx.beginPath(); ctx.roundRect(-220,68,70,52,12); ctx.fill();
          ctx.restore();
        }

        // サイドユニット
        ctx.fillStyle="rgba(231,236,255,0.10)";
        ctx.beginPath(); ctx.roundRect(-210,-130,44,44,10); ctx.fill();
        ctx.beginPath(); ctx.roundRect(-210,86,44,44,10); ctx.fill();
        ctx.strokeStyle="rgba(231,236,255,0.16)";
        ctx.lineWidth=2;
        ctx.strokeRect(-210,-130,44,44);
        ctx.strokeRect(-210,86,44,44);

        const coreOpen = (e.p >= 1);
        const a = coreOpen ? 0.95 : 0.30;

        // コア：多層グロー＋回転リング
        {
          const pulse = 0.55 + 0.45*Math.sin(tt*4.2 + e.t*1.1);
          ctx.save();
          ctx.globalCompositeOperation="lighter";

          // outer halo
          ctx.globalAlpha = (coreOpen ? 0.28 : 0.14) + 0.10*pulse;
          const g = ctx.createRadialGradient(70,0,8, 70,0, 70);
          g.addColorStop(0.0, "rgba(255,75,75,0.55)");
          g.addColorStop(0.35,"rgba(255,75,75,0.20)");
          g.addColorStop(1.0, "rgba(255,75,75,0.00)");
          ctx.fillStyle = g;
          ctx.beginPath(); ctx.arc(70,0, 62, 0, TAU); ctx.fill();

          // core
          glowCore(70,0, coreOpen ? 24 : 16, a);

          // rotating rings
          const t0 = (tt*2.1 + e.t*0.6) % TAU;
          ctx.globalAlpha = 0.32 + 0.18*pulse;
          ctx.strokeStyle = "rgba(120,200,255,0.45)";
          ctx.lineWidth = 3;
          ctx.beginPath(); ctx.arc(70,0, 34, t0, t0 + Math.PI*1.35); ctx.stroke();
          ctx.globalAlpha *= 0.7;
          ctx.strokeStyle = "rgba(255,220,140,0.30)";
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(70,0, 44, t0+1.3, t0+1.3 + Math.PI*1.10); ctx.stroke();

          ctx.restore();
        }

        // 排気（強化）
        thruster(-250,-90,1.7);
        thruster(-250,0,1.7);
        thruster(-250,90,1.7);

        // 追加：ボス全体シールド（フェーズで強度変化）
        {
          const sh = 0.5 + 0.5*Math.sin(tt*1.9 + e.t*0.8);
          const base = coreOpen ? 0.14 : 0.08;
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = base + 0.10*sh;
          ctx.strokeStyle = "rgba(120,200,255,0.28)";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.ellipse(-60,0, 235, 160, 0, 0, TAU);
          ctx.stroke();
          ctx.globalAlpha *= 0.6;
          ctx.strokeStyle = "rgba(54,211,153,0.22)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.ellipse(-60,0, 248, 172, 0, 0, TAU);
          ctx.stroke();
          ctx.restore();
        }

        // 掃射ライン演出（強化：二重ライン＋閃光）
        if (e.p >= 1 && e.t % 3.2 < 0.8) {
          const k = (e.t % 3.2) / 0.8;
          const yL = lerp(-140, 140, k);

          ctx.save();
          ctx.globalCompositeOperation = "lighter";

          ctx.globalAlpha = 0.18;
          ctx.strokeStyle = "rgba(255,75,75,0.35)";
          ctx.lineWidth = 10;
          ctx.beginPath();
          ctx.moveTo(-230, yL);
          ctx.lineTo(130, yL);
          ctx.stroke();

          ctx.globalAlpha = 0.30;
          ctx.strokeStyle = "rgba(255,220,140,0.25)";
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(-230, yL);
          ctx.lineTo(130, yL);
          ctx.stroke();

          // flash at core
          ctx.globalAlpha = 0.22;
          ctx.fillStyle = "rgba(255,220,140,0.22)";
          ctx.beginPath(); ctx.arc(70,0, 46, 0, TAU); ctx.fill();

          ctx.restore();
        }

        // 追加：点滅警告灯
        {
          const blink = 0.22 + 0.58*(0.5+0.5*Math.sin(tt*7.6 + e.t*2.9));
          ctx.save();
          ctx.globalCompositeOperation="lighter";
          ctx.globalAlpha = blink;
          ctx.fillStyle="rgba(255,75,75,0.40)";
          ctx.beginPath(); ctx.arc(-170,-130,4.5,0,TAU); ctx.fill();
          ctx.beginPath(); ctx.arc(-170,130,4.5,0,TAU); ctx.fill();
          ctx.beginPath(); ctx.arc(-40,-150,3.8,0,TAU); ctx.fill();
          ctx.beginPath(); ctx.arc(-40,150,3.8,0,TAU); ctx.fill();
          ctx.restore();
        }

      } else {
        ctx.fillStyle = "rgba(231,236,255,0.2)";
        ctx.fillRect(-16, -16, 32, 32);
      }

      ctx.restore();

      if (e.ai === "midboss" || e.ai === "boss") {
        const max = e.ai==="midboss" ? 220 : 520;
        const w = 280;
        const x = (W-w)/2, y = 24 + (e.ai==="boss"?18:0);
        ctx.fillStyle="rgba(0,0,0,0.35)";
        ctx.fillRect(x,y,w,10);
        ctx.fillStyle="rgba(255,75,75,0.55)";
        ctx.fillRect(x,y,w*(clamp(e.hp,0,max)/max),10);
        ctx.strokeStyle="rgba(231,236,255,0.18)";
        ctx.strokeRect(x,y,w,10);
      }
    }
  }

  function drawCapsules() {
    for (const c of capsules) {
      if (!c.active) continue;
      ctx.fillStyle="rgba(54,211,153,0.26)";
      ctx.beginPath(); ctx.arc(c.x, c.y, 12, 0, TAU); ctx.fill();
      ctx.strokeStyle="rgba(54,211,153,0.72)";
      ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(c.x, c.y, 12, 0, TAU); ctx.stroke();
      ctx.fillStyle="rgba(231,236,255,0.85)";
      ctx.fillRect(c.x-4, c.y-4, 8, 8);
    }
  }

  function drawFX() {
    for (const p of fx) {
      if (!p.active) continue;
      const a = clamp(p.ttl / 0.6, 0, 1);
      ctx.globalAlpha = a;
      if (p.kind === "spark") {
        ctx.fillStyle = "rgba(231,236,255,0.95)";
        ctx.fillRect(p.x, p.y, p.size, p.size);
      } else if (p.kind === "boom") {
        ctx.strokeStyle = "rgba(255,75,75,0.85)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, TAU);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }
  }

  
  // --- Cave corridor clamp for enemies (prevents unreachable low spawns) ---
  function clampEnemyToCaveCorridor(e, worldX) {
    try {
      if (!terrainHint || terrainHint.length === 0) return;
      const tile = 32;
      const idx = Math.max(0, Math.min(terrainHint.length - 1, Math.floor(worldX / tile)));
      const h = terrainHint[idx];
      const margin = 40; // keep enemies away from walls / floor blocks
      const top = h.ceilY + margin;
      const bottom = h.floorY - margin;
      if (!(top < bottom)) return;
      e.y = Math.max(top, Math.min(bottom, e.y));
    } catch (_) {}
  }
  // --- /Cave corridor clamp ---
function addEnemy(ai, x, y, params={}) {
    const e = enemyPool.get();
    e.active = true;
    e.x = x; e.y = y;
    e.vx = params.vx ?? -140;
    e.vy = params.vy ?? 0;
    e.r = params.r ?? 16;
    e.w = params.w ?? 32;
    e.h = params.h ?? 32;
    e.hp = params.hp ?? 3;
    e.score = params.score ?? 100;
    e.ai = ai;
    e.t = 0;
    e.p = params.p ?? 0;
    e.solid = params.solid ?? false;
    if (section === "C") clampEnemyToCaveCorridor(e, e.x);
    enemies.push(e);
    return e;
  }

  function addCapsule(x,y) {
    if (capsules.filter(c=>c.active).length >= 8) return;
    const c = capsulePool.get();
    c.active = true; c.x=x; c.y=y;
    c.vx = -90; c.vy = 0;
    c.r = 10; c.ttl = 10;
    capsules.push(c);
  }

  function burstFX(x,y, n=10, kind="spark") {
    for (let i=0;i<n;i++) {
      const p = fxPool.get();
      p.active = true;
      p.x = x + rand(-6,6);
      p.y = y + rand(-6,6);
      p.vx = rand(-120, 120);
      p.vy = rand(-120, 120);
      p.ttl = 0.35 + Math.random()*0.35;
      p.size = 2 + Math.random()*2;
      p.kind = kind;
      fx.push(p);
    }


  // Big explosion for midboss/boss defeat (do not touch start logic; pure visuals)
  function megaExplosionFX(x, y, scale=1.0) {
    // multiple spark sprays
    for (let k=0;k<4;k++) {
      burstFX(x + rand(-18,18), y + rand(-18,18), Math.floor(26*scale), "spark");
    }
    // multiple boom rings
    for (let k=0;k<5;k++) {
      burstFX(x + rand(-28,28), y + rand(-28,28), Math.floor(16*scale), "boom");
    }
    // a few large, slow rings
    const bigN = 7 + Math.floor(4*scale);
    for (let i=0;i<bigN;i++) {
      const p = fxPool.get();
      p.active = true;
      p.x = x + rand(-40,40);
      p.y = y + rand(-30,30);
      p.vx = rand(-18,18);
      p.vy = rand(-18,18);
      p.ttl = 0.55 + Math.random()*0.55;
      p.size = (22 + Math.random()*52) * scale;
      p.kind = "boom";
      fx.push(p);
    }
    // brief screen flash using existing bossIntro flash channel (safe if bossIntro exists)
    try { bossIntroFlash(0.95); } catch (_) {}
  }

  }

  function fireEnemyShot(x,y, vx,vy, r=5, homing=0) {
    const b = enemyShotPool.get();
    b.active = true;
    b.x=x; b.y=y;
    b.vx=vx; b.vy=vy;
    b.r=r;
    b.ttl=7;
    b.homing = homing; // seconds to home
    b.spd = Math.hypot(vx,vy);
    enemyShots.push(b);
  }

  function fireAim(x,y, speed=220, spread=0) {
    const dx = (player.x - x), dy = (player.y - y);
    const ang = Math.atan2(dy, dx) + spread;
    fireEnemyShot(x,y, Math.cos(ang)*speed, Math.sin(ang)*speed, 5, 0);
  }

  function fireFan(x,y, speed=200, n=3, angCenter=Math.PI, angSpan=0.55) {
    if (n === 1) { fireEnemyShot(x,y, Math.cos(angCenter)*speed, Math.sin(angCenter)*speed, 5, 0); return; }
    for (let i=0;i<n;i++) {
      const t = (i/(n-1)) - 0.5;
      const a = angCenter + t*angSpan;
      fireEnemyShot(x,y, Math.cos(a)*speed, Math.sin(a)*speed, 5, 0);
    }
  }

  function fireRing(x,y, speed=170, n=12) {
    for (let i=0;i<n;i++) {
      const a = (i/n)*TAU;
      fireEnemyShot(x,y, Math.cos(a)*speed, Math.sin(a)*speed, 5, 0);
    }
  }

  function fireHomingLite(x,y, speed=170, homingSeconds=0.8) {
    const dx = (player.x - x), dy = (player.y - y);
    const ang = Math.atan2(dy, dx);
    fireEnemyShot(x,y, Math.cos(ang)*speed, Math.sin(ang)*speed, 5, homingSeconds);
  }

  function firePlayerShot(fromX, fromY, vx, vy, kind="shot", dmg=1, r=4) {
    const s = shotPool.get();
    s.active = true;
    s.x = fromX; s.y = fromY;
    s.vx = vx; s.vy = vy;
    s.r = r;
    s.ttl = 2.0;
    s.kind = kind;
    s.dmg = dmg;
    shots.push(s);
  }

  function firePlayerMissile(fromX, fromY) {
    const m = missilePool.get();
    m.active = true;
    m.x = fromX; m.y = fromY;
    m.vx = 360;
    m.vy = 0;
    m.r = 5;
    m.ttl = 2.2;
    m.trail = 0;
    m.dmg = 2;
    missiles.push(m);
  }

  function doPlayerFire(dt) {
  const firing = isDown(["KeyZ","Space"]);
  const missileKey = isDown(["KeyX"]);
  const activateKey = isDown(["KeyC"]);

  if (activateKey && !doPlayerFire._cHeld) {
    activatePowerup();
  }
  doPlayerFire._cHeld = activateKey;

  // Laser is a continuous beam (not a projectile). Reset each frame.
  player.laserOn = false;
  player.optionLaserOn = 0;

  // Normal shots (single/double) use cooldown.
  player.fireCD = Math.max(0, player.fireCD - dt);
  if (firing && player.fireCD <= 0) {
    let cd = 0.12;

    if (player.shotLevel === 0) {
      firePlayerShot(player.x+18, player.y, 520, 0, "shot", 1, 4);
    } else { // double
      firePlayerShot(player.x+18, player.y-5, 520, -40, "shot", 1, 4);
      firePlayerShot(player.x+18, player.y+5, 520, 40, "shot", 1, 4);
      cd = 0.14;
    }

    for (let i=0;i<player.options;i++) {
      const p = optionPos[i];
      if (player.shotLevel === 0) {
        firePlayerShot(p.x+16, p.y, 520, 0, "shot", 0.7, 4);
      } else {
        firePlayerShot(p.x+16, p.y-5, 520, -40, "shot", 0.7, 4);
        firePlayerShot(p.x+16, p.y+5, 520, 40, "shot", 0.7, 4);
      }
    }

    sfx("shot");
    player.fireCD = cd;
  }

  // Laser: hold-to-fire continuous beam (can be combined with SINGLE/DOUBLE)
  if (player.hasLaser && firing) {
    player.laserOn = true;
    player.optionLaserOn = player.options;
  }

  // Laser SFX
  if (player.laserOn) {
    player.laserSfx = Math.max(0, player.laserSfx - dt);
    if (player.laserSfx <= 0) {
      sfx("laser");
      player.laserSfx = 0.22;
    }
  }

  // Missiles
  player.missileCD = Math.max(0, player.missileCD - dt);
  if (player.missile && missileKey && player.missileCD <= 0) {
    firePlayerMissile(player.x-6, player.y+10);
    for (let i=0;i<player.options;i++) {
      const p = optionPos[i];
      const m = missilePool.get();
      m.active = true; m.x = p.x-6; m.y = p.y+10;
      m.vx = 360; m.vy = 0; m.r=5; m.ttl=2.0; m.trail=0; m.dmg=1.4;
      missiles.push(m);
    }
    sfx("missile");
    player.missileCD = 0.36;
  }
}
doPlayerFire._cHeld = false;


  function addGaugeStep() {
    gaugeProgress = (gaugeProgress < 0) ? 0 : ((gaugeProgress + 1) % gaugeItems.length);
    gaugeReady = true;
    renderGaugeUI();
  }

  function resetGauge() {
    gaugeProgress = -1;
    gaugeReady = false;
    renderGaugeUI();
  }

  function activatePowerup() {
    if (gaugeProgress < 0) return;
    if (!gaugeReady) return;
    const item = gaugeItems[gaugeProgress];

    if (item === "SPEED") {
      player.speedLevel = clamp(player.speedLevel + 1, 0, 2);
    } else if (item === "MISSILE") {
      player.missile = true;
    } else if (item === "DOUBLE") {
      player.shotLevel = Math.max(player.shotLevel, 1);
    } else if (item === "LASER") {
      player.hasLaser = true;
    } else if (item === "OPTION") {
      player.options = clamp(player.options + 1, 0, 2);
    } else if (item === "SHIELD") {
      player.shield = 1;
    }

    sfx("power");
    resetGauge();
  }

    let frameDT = 1/60;
let worldX = 0;
  const scrollSpeed = 150; // px/s baseline

  function setSectionFromTime(t) {
    if (t < 70) section = "A";
    else if (t < 150) section = "B";
    else if (t < 225) section = "C";
    else if (t < 280) section = "D";
    else if (t < 310) section = "M";
    else if (t < 370) section = "E";
    else section = "BOSS";
  }

  function maybeInitTerrainForSection() {
    if ((section === "C") && !maybeInitTerrainForSection._cDone) {
      genCave("C");
      maybeInitTerrainForSection._cDone = true;
      maybeInitTerrainForSection._eDone = false;
    }
    if ((section === "E") && !maybeInitTerrainForSection._eDone) {
      genCave("E");
      maybeInitTerrainForSection._eDone = true;
    }
    if ((section === "A" || section === "B" || section === "D" || section === "M" || section === "BOSS") && terrain.length > 0) {
      if (section !== "C" && section !== "E") clearTerrain();
    }
  }
  maybeInitTerrainForSection._cDone = false;
  maybeInitTerrainForSection._eDone = false;

  const sched = {
    A1: 0, A2: 8,
    B1: 70, B2: 78,
    Cslime: 152,
    D1: 226, D2: 238,
    Mid: 280,
    E1: 312, E2: 320, E3: 332,
    Boss: 370,
    OutWarn: 252,
  };
  const SPAWN_SCALE = 0.80; // 敵出現の多さ（小さいほど多い）
  const CAPSULE_RATE = 1.35; // アイテム出やすさ倍率（>1で出やすい）

  function directorUpdate(t, dt) {
    setSectionFromTime(t);
    maybeInitTerrainForSection();

    elCP.textContent = checkpoint;

    // 進捗20%ごと中ボス（20/40/60/80%）
    const pctNow = Math.floor((progressMaxAbs / STAGE_TOTAL_SEC) * 100);
    const pList = [20,40,60,80];

    if (director.pMidActive) {
      // 中ボス戦中は通常スポーンを抑制
      if (!midboss || !midboss.active) {
        director.pMidActive = false;
      } else {
        return;
      }
    }

    if (!director.bossStarted && !director.bossDead && director.pMidIdx < pList.length && pctNow >= pList[director.pMidIdx]) {
      const th = pList[director.pMidIdx];
      director.pMidIdx += 1;
      director.pMidActive = true;
      director.midbossStarted = true;
      director.midbossDead = false;
      const tier = Math.max(1, Math.min(4, Math.floor(th/20))); // 1..4
      const hp = 120 + (tier-1)*60; // 20%:120 → 80%:300
      const pwr = 1.0 + (tier-1)*0.25; // 1.00,1.25,1.50,1.75
      midboss = addEnemy("midboss", W+200, H/2, {vx:-60, hp:hp, score:3000 + tier*900, r:120, w:240, h:240});

      if (started && !director.bossStarted) { try { playMidbossBGM(900); } catch {} }
      midboss._tier = tier;
      midboss._pwr = pwr;
      midboss.ai = "midboss";
      midboss.p = 0;
      midboss._progressTag = th;
      return;
    }


    if (t < 70) {
      if (t >= sched.A1) {
        for (let i=0;i<3;i++) {
          const y = (i===0? 140 : (i===1? 360 : 580));
          const dir = (Math.floor(t/6)%2===0) ? 1 : -1;
          addEnemy("small", W+40 + i*40, y, {vx:-200, vy: dir*60, hp:2, score:120, r:14});
        }
        sched.A1 += 6.0*SPAWN_SCALE;
      }
      if (t >= sched.A2 && !directorUpdate._A2Placed) {
        const ys = [120, 360, 600];
        for (let i=0;i<3;i++) addEnemy("turret", W+260 + i*220, ys[i], {vx:-120, hp:8, score:300, r:16});
        for (let i=0;i<3;i++) addEnemy("turret", W+260 + i*220, ys[i]-80, {vx:-120, hp:8, score:300, r:16}); // slightly offset
        directorUpdate._A2Placed = true;
      }
    }

    if (t >= 70 && t < 150) {
      if (t >= sched.B1) {
        for (let i=0;i<2;i++) {
          const baseY = rand(140, 580);
          addEnemy("droneSine", W+40 + i*60, baseY, {vx:-170, hp:7, score:260, r:16});
        }
        sched.B1 += 7.5*SPAWN_SCALE;
      }
      if (t >= sched.B2) {
        const e = addEnemy("spawner", W+40, rand(130, 590), {vx:-90, hp:10, score:300, r:14});
        e.ai = "homingEmitter";
        sched.B2 += 12.0*SPAWN_SCALE;
      }
    }

    if (t >= 150 && t < 225) {
      if (t >= sched.Cslime) {
        const isCeil = (Math.floor((t-150)/6)%2===0);
        const y = isCeil ? rand(80, 170) : rand(550, 650);
        const e = addEnemy("slime", W+40, y, {vx:-140, hp:9, score:420, r:16});
        e.p = isCeil ? -1 : 1; // attach side
        sched.Cslime += 6.0*SPAWN_SCALE;
      }
      if (!directorUpdate._Ccap1 && t > 158) {
        addCapsule(W-120, 360);
        directorUpdate._Ccap1 = true;
      }
    }

    if (t >= 225 && t < 280) {
      if (t >= sched.D1) {
        for (let i=0;i<5;i++) addEnemy("charger", W+40 + i*44, rand(120, 600), {vx:-340, hp:3, score:180, r:14});
        sched.D1 += 9.0*SPAWN_SCALE;
      }
      if (t >= sched.D2) {
        addEnemy("armored", W+40, rand(140, 580), {vx:-150, hp:18, score:600, r:20});
        sched.D2 += 7.0*SPAWN_SCALE;
      }

      if (!director.warnOutcrop && t >= sched.OutWarn) {
        director.warnOutcrop = true;
        directorUpdate._outcropT = t;
        sfx("warn");
      }
    }

    if (t >= 310 && t < 370) {
      if (t >= sched.E1) {
        addEnemy("turret", W+40, rand(120, 600), {vx:-120, hp:9, score:340, r:16});
        sched.E1 += 10.0*SPAWN_SCALE;
      }
      if (t >= sched.E2) {
        addEnemy("droneSine", W+40, rand(130, 590), {vx:-190, hp:8, score:260, r:16});
        sched.E2 += 6.5*SPAWN_SCALE;
      }
      if (t >= sched.E3) {
        const e = addEnemy("rear", -60, rand(140, 580), {vx: 120, hp:3, score:150, r:14});
        e.ai = "rearSpawn";
        e.p = 0.5; // warning time
        sched.E3 += 11.0*SPAWN_SCALE;
      }
    }

    if (t >= 370 && !director.bossDead) {
      if (!director.bossStarted) {
        director.bossStarted = true;
        boss = addEnemy("boss", W+260, H/2, {vx:-45, hp:1040, score:20000, r:170, w:360, h:320});
        boss.ai = "boss";
        boss.p = 0; // phase 0 turret break
        boss.maxHp = boss.hp;
        director.bossPhase2Bgm = false;

        // Boss intro + dedicated BGM
        triggerBossIntro();
        stopAllBGM();
        setTimeout(() => { try { playBossBGM(900); } catch {} }, 2000);
      }
    }
  }
  directorUpdate._A2Placed = false;
  directorUpdate._Ccap1 = false;
  directorUpdate._outcropT = 0;

  function updateEnemies(dt, tAbs) {
    for (const e of enemies) {
      if (!e.active) continue;
      e.t += dt;

      e.x += e.vx*dt;
      e.y += e.vy*dt;

      if (e.ai === "small") {
        if (e.y < 80) e.vy = Math.abs(e.vy);
        if (e.y > H-80) e.vy = -Math.abs(e.vy);
      }
      else if (e.ai === "turret") {
        if (e.t > 0.8 && (e.t % 1.2) < dt) {
          fireAim(e.x-12, e.y, 240);
        }
      }
      else if (e.ai === "droneSine") {
        e.y += Math.sin(e.t*2.2) * 48 * dt;
        if (e.t > 0.9 && (e.t % 1.1) < dt) {
          fireFan(e.x-10, e.y, 210, 3, Math.PI, 0.55);
        }
      }
      else if (e.ai === "homingEmitter") {
        if (e.t > 0.8 && (e.t % 1.3) < dt) {
          if (enemyShots.filter(b=>b.active).length < 8) fireHomingLite(e.x-8, e.y, 180, 0.8);
        }
      }
      else if (e.ai === "slime") {
        if (e.p < 0) e.y = clamp(e.y, 90, 180);
        else e.y = clamp(e.y, 540, 650);
        if (e.t > 0.7 && (e.t % 1.6) < dt) {
          const ang = (e.p < 0) ? (Math.PI*0.35) : (-Math.PI*0.35);
          e.p2 = 0.0;
          e.p3 = ang;
        }
        if (e.p2 !== undefined) {
          e.p2 += dt;
          if (e.p2 < 0.22 && (Math.floor(e.p2*40)%6===0)) {
            fireEnemyShot(e.x-8, e.y, -240, Math.sin(e.p3)*120, 5, 0);
          }
          if (e.p2 > 0.28) { e.p2 = undefined; }
        }
      }
      else if (e.ai === "charger") {
      }
      else if (e.ai === "armored") {
        if (e.t > 1.2 && (e.t % 1.7) < dt) {
          fireAim(e.x-10, e.y, 220);
        }
      }
      else if (e.ai === "rearSpawn") {
        e.p -= dt;
        if (e.p > 0) {
          if ((Math.floor(e.t*10)%2)===0) {
            const p = fxPool.get();
            p.active=true; p.x=40; p.y=e.y; p.vx=0; p.vy=0; p.ttl=0.06; p.size=10; p.kind="boom";
            fx.push(p);
          }
        } else {
          e.ai = "small";
          e.x = 60;
          e.vx = 200;
          e.vy = rand(-40,40);
          e.hp = 2;
          e.score = 150;
          e.r = 14;
        }
      }
      else if (e.ai === "midboss") {
        if (e.x > W-220) e.vx = -90;
        else e.vx = 0;

        if (e.t > 2.0) e.p = 1; // open cores

        // Core open pulse (one-shot)
        if (e.p === 1 && !e._coreOpened) {
          e._coreOpened = true;
          burstFX(e.x+40, e.y-55, 22, "spark");
          burstFX(e.x+40, e.y+55, 22, "spark");
          burstFX(e.x-40, e.y, 18, "boom");
          try { bossIntroFlash(0.55); } catch (_) {}
        }

        // Ambient midboss aura (throttled)
        if ((Math.floor(e.t*18) % 3) === 0) {
          const p = fxPool.get();
          p.active = true;
          p.x = e.x + rand(-130, 130);
          p.y = e.y + rand(-100, 100);
          p.vx = rand(-35, 35);
          p.vy = rand(-35, 35);
          p.ttl = 0.22 + Math.random()*0.22;
          p.size = 2 + Math.random()*3;
          p.kind = "spark";
          fx.push(p);
        }
        if ((Math.floor(e.t*9) % 11) === 0) {
          const p = fxPool.get();
          p.active = true;
          p.x = e.x + rand(-80, 80);
          p.y = e.y + rand(-60, 60);
          p.vx = 0; p.vy = 0;
          p.ttl = 0.32 + Math.random()*0.22;
          p.size = 10 + Math.random()*22;
          p.kind = "boom";
          fx.push(p);
        }

        const f = e._pwr || 1.0;
        if (e.p === 0) {
          if ((e.t % (1.0 / f)) < dt) fireAim(e.x-140, e.y, 240 * f);
        } else {
          if ((e.t % (1.6 / f)) < dt) fireRing(e.x+40, e.y-55, 170 * f, 10);
          if ((e.t % (1.8 / f)) < dt) fireRing(e.x+40, e.y+55, 170 * f, 10);
          if ((e.t % (2.4 / f)) < dt) fireAim(e.x-80, e.y, 260 * f);
        }
      }
      else if (e.ai === "boss") {
        if (e.x > W-260) e.vx = -70;
        else e.vx = 0;

        if (bossIntro && bossIntro.active) {
          // during intro, no attacks
          e.y = H/2 + Math.sin(e.t*0.45) * 70;
          continue;
        }

        if (e.maxHp === undefined) e.maxHp = e.hp;

        // phase thresholds scale with max HP
        if (e.hp < e.maxHp * 0.73) e.p = Math.max(e.p, 1);
        if (e.hp < e.maxHp * 0.31) e.p = Math.max(e.p, 2);

        // Boss phase-change pulse (visual only)
        if (e._phase === undefined) e._phase = e.p;
        if (e.p !== e._phase) {
          e._phase = e.p;
          burstFX(e.x-80, e.y, 26, "spark");
          burstFX(e.x-80, e.y, 18, "boom");
          try { bossIntroFlash(0.50 + 0.12*e.p); } catch (_) {}
          try { sfx("power"); } catch (_) {}
        }

        // Ambient boss aura (throttled)
        if ((Math.floor(e.t*20) % 2) === 0) {
          const p = fxPool.get();
          p.active = true;
          p.x = e.x + rand(-170, 170);
          p.y = e.y + rand(-130, 130);
          p.vx = rand(-28, 28);
          p.vy = rand(-28, 28);
          p.ttl = 0.20 + Math.random()*0.24;
          p.size = 2 + Math.random()*3;
          p.kind = "spark";
          fx.push(p);
        }
        if ((Math.floor(e.t*8) % 9) === 0) {
          const p = fxPool.get();
          p.active = true;
          p.x = e.x + rand(-120, 120);
          p.y = e.y + rand(-90, 90);
          p.vx = 0; p.vy = 0;
          p.ttl = 0.34 + Math.random()*0.26;
          p.size = 14 + Math.random()*34;
          p.kind = "boom";
          fx.push(p);
        }

        // BGM phase 2 at 50% HP
        if (!director.bossPhase2Bgm && e.hp <= e.maxHp * 0.50) {
          director.bossPhase2Bgm = true;
          bossIntroFlash(0.55);
          sfx("power");
          startBossBGM(2);
        }

        e.y = H/2 + Math.sin(e.t*0.45) * 70;

        if (e.p === 0) {
          if ((e.t % 0.95) < dt) fireFan(e.x-200, e.y-110, 220, 3, Math.PI, 0.55);
          if ((e.t % 1.15) < dt) fireFan(e.x-200, e.y+110, 220, 3, Math.PI, 0.55);
        } else if (e.p === 1) {
          if ((e.t % 1.35) < dt) {
            for (let i=0;i<10;i++) {
              const a = (i/10)*TAU;
              const vx = Math.cos(a)*160 - 80;
              const vy = Math.sin(a)*160;
              fireEnemyShot(e.x+70, e.y, vx, vy, 5, 0);
            }
          }
          const m = e.t % 3.2;
          if (m > 0.8 && m < 0.8 + dt) {
            const y = lerp(e.y-140, e.y+140, (m-0.8)/0.0001); // placeholder
          }
          if (m > 0.8 && m < 1.0) {
          }
          if (m > 0.78 && m < 0.78 + dt) {
            const k = clamp(m/0.78,0,1);
          }
          if (m > 0.79 && m < 0.79+dt) {
            const k = 0; // not used
          }
          if (m > 0.80 && m < 0.80+dt) {
            const k = ((e.t - m) % 99999); // no-op
          }
          if (m > 0.80 && m < 0.80+dt) {
          }
          if (e._lastSweep === undefined) e._lastSweep = -999;
          if (m < 0.02 && (e.t - e._lastSweep) > 3.0) {
            e._lastSweep = e.t;
          }
          if (e._lastSweep > 0 && e.t > e._lastSweep + 0.8 && !e._sweepDone) {
            e._sweepDone = true;
            const phase = (Math.floor(e._lastSweep / 3.2) % 2);
            const y = phase === 0 ? (e.y - 90) : (e.y + 90);
            for (let i=0;i<26;i++) {
              fireEnemyShot(e.x-230, y + (i-13)*8, -380, 0, 5, 0);
            }
          }
          if (e._lastSweep > 0 && e.t > e._lastSweep + 1.0) {
            e._sweepDone = false;
          }
        } else {
          if ((e.t % 1.0) < dt) fireRing(e.x+70, e.y, 190, 14);
          if ((e.t % 1.4) < dt) {
            fireFan(e.x-200, e.y-110, 250, 5, Math.PI, 0.9);
            fireFan(e.x-200, e.y+110, 250, 5, Math.PI, 0.9);
          }
          if ((e.t % 2.2) < dt) {
            for (let i=0;i<3;i++) fireHomingLite(e.x+20, e.y + (i-1)*34, 190, 0.7);
          }
        }
      }

      if (e.ai !== "midboss" && e.ai !== "boss") {
        if (e.x < -120 || e.y < -120 || e.y > H+120) {
          e.active = false;
        }
      } else {
        e.x = clamp(e.x, W-320, W+300);
      }

    }

    for (let i=enemies.length-1;i>=0;i--) {
      if (!enemies[i].active) { enemyPool.put(enemies[i]); enemies.splice(i,1); }
    }
  }

  function updateBullets(dt, worldOffsetX) {
    for (const s of shots) {
      if (!s.active) continue;
      s.x += s.vx*dt;
      s.y += s.vy*dt;
      s.ttl -= dt;
      if (s.ttl <= 0 || s.x > W+80 || s.y < -80 || s.y > H+80) s.active=false;
    }
    for (let i=shots.length-1;i>=0;i--) {
      if (!shots[i].active) { shotPool.put(shots[i]); shots.splice(i,1); }
    }

    for (const m of missiles) {
      if (!m.active) continue;
      m.x += m.vx*dt;
      m.y += m.vy*dt;
      m.ttl -= dt;

      if (terrainHint.length > 0) {
        const wx = m.x + worldOffsetX;
        const idx = Math.floor(wx/32);
        const h = terrainHint[idx];
        if (h) {
          const mid = (h.ceilY + h.floorY) * 0.5;
          const target = (m.y > mid) ? (h.floorY - 18) : (h.ceilY + 18);
          m.y = lerp(m.y, target, 0.06);
        }
      }

      if (m.ttl <= 0 || m.x > W+120 || m.y < -120 || m.y > H+120) m.active=false;
      m.trail += dt;
      if (m.trail > 0.05) {
        m.trail = 0;
        const p = fxPool.get();
        p.active = true; p.x = m.x-6; p.y = m.y; p.vx = -20; p.vy = rand(-10,10); p.ttl = 0.25; p.size = 2.5; p.kind="spark";
        fx.push(p);
      }
    }
    for (let i=missiles.length-1;i>=0;i--) {
      if (!missiles[i].active) { missilePool.put(missiles[i]); missiles.splice(i,1); }
    }

    for (const b of enemyShots) {
      if (!b.active) continue;
      if (b.homing > 0) {
        b.homing -= dt;
        const dx = (player.x - b.x), dy = (player.y - b.y);
        const ang = Math.atan2(dy, dx);
        const sp = b.spd || Math.hypot(b.vx,b.vy);
        b.vx = lerp(b.vx, Math.cos(ang)*sp, 0.08);
        b.vy = lerp(b.vy, Math.sin(ang)*sp, 0.08);
      }
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      b.ttl -= dt;
      if (b.ttl <= 0 || b.x < -120 || b.x > W+120 || b.y < -120 || b.y > H+120) b.active=false;
    }
    for (let i=enemyShots.length-1;i>=0;i--) {
      if (!enemyShots[i].active) { enemyShotPool.put(enemyShots[i]); enemyShots.splice(i,1); }
    }

    for (const c of capsules) {
      if (!c.active) continue;
      c.x += c.vx*dt;
      c.y += c.vy*dt;
      c.ttl -= dt;
      if (c.ttl <= 0 || c.x < -60) c.active=false;
    }
    for (let i=capsules.length-1;i>=0;i--) {
      if (!capsules[i].active) { capsulePool.put(capsules[i]); capsules.splice(i,1); }
    }

    for (const p of fx) {
      if (!p.active) continue;
      p.x += p.vx*dt;
      p.y += p.vy*dt;
      p.ttl -= dt;
      if (p.ttl <= 0) p.active=false;
    }
    for (let i=fx.length-1;i>=0;i--) {
      if (!fx[i].active) { fxPool.put(fx[i]); fx.splice(i,1); }
    }
  }

  function updatePlayer(dt, worldOffsetX) {
    if (!player.alive) return;

    const base = 280;
    const speed = base + player.speedLevel*90;

    const up = isDown(["KeyW","ArrowUp"]);
    const down = isDown(["KeyS","ArrowDown"]);
    const left = isDown(["KeyA","ArrowLeft"]);
    const right = isDown(["KeyD","ArrowRight"]);

    let ax = 0, ay = 0;
    if (up) ay -= 1;
    if (down) ay += 1;
    if (left) ax -= 1;
    if (right) ax += 1;

    if (ax !== 0 || ay !== 0) {
      const len = Math.hypot(ax, ay);
      ax /= len; ay /= len;
    }

    player.x += ax * speed * dt;
    player.y += ay * speed * dt;

    player.x = clamp(player.x, 80, W-120);
    player.y = clamp(player.y, 60, H-60);

    if (terrain.length > 0) {
      const wx = player.x + worldOffsetX;
      const idx = clamp(Math.floor(wx/32), 0, terrainHint.length-1);
      const h = terrainHint[idx];
      if (h) {
        const top = h.ceilY + 10 + player.hy;
        const bot = h.floorY - 10 - player.hy;
        player.y = clamp(player.y, top, bot);
      }
    }

    player.invuln = Math.max(0, player.invuln - dt);

    player.trail.push({x: player.x, y: player.y});
    if (player.trail.length > 90) player.trail.shift();
    for (let i=0;i<2;i++) {
      const d = optionDelayFrames[i];
      const idx2 = player.trail.length - 1 - d;
      if (idx2 >= 0) {
        optionPos[i].x = player.trail[idx2].x;
        optionPos[i].y = player.trail[idx2].y;
      }
    }

    doPlayerFire(dt);
  }

  function awardScore(n) {
    score += n;
    elScore.textContent = String(score);
  }

  function damageEnemy(e, dmg) {
    e.hp -= dmg;

    // Hit effects: only for midboss/boss, throttled (visual only)
    if ((e.ai === "midboss" || e.ai === "boss") && e.hp > 0) {
      e._hitFx = (e._hitFx || 0) + 1;
      const hx = e.x + rand(-90, 90);
      const hy = e.y + rand(-70, 70);
      if ((e._hitFx % 2) === 0) burstFX(hx, hy, 6, "spark");
      if ((e._hitFx % 6) === 0) burstFX(hx, hy, 4, "boom");
    }

    if (e.hp <= 0) killEnemy(e);
  }

  function killEnemy(e) {
    e.active = false;
    awardScore(e.score || 100);
    if (e.ai==="boss"||e.ai==="midboss") {
      if (typeof megaExplosionFX === "function") {
        megaExplosionFX(e.x, e.y, 1.15);
      } else {
        burstFX(e.x, e.y, 18, "boom");
        burstFX(e.x, e.y, 22, "spark");
      }
    } else {
      burstFX(e.x, e.y, 14, "spark");
    }
    sfx("boom");


    if (e.ai === "boss") {
      director.bossDead = true;
      stopBossBGM();
      stopBGM();
    }

    if (e.ai === "turret" && !killEnemy._turretDropsDone) {
      killEnemy._turretDropsDone = (killEnemy._turretDropsDone || 0) + 1;
      if (killEnemy._turretDropsDone <= 2) addCapsule(e.x, e.y);
    } else {
      if (Math.random() < Math.min(0.35, (0.10 * CAPSULE_RATE))) addCapsule(e.x, e.y);
    }

    if (e.ai === "armored") {
      for (let i=0;i<8;i++) {
        const a = (i/8)*TAU;
        fireEnemyShot(e.x, e.y, Math.cos(a)*170, Math.sin(a)*170, 5, 0);
      }
    }

    if (e === midboss) {
      director.midbossDead = true;
      if (e._progressTag) director.pMidActive = false;

      // Midboss defeated: drop 3–5 capsules (restart from the beginning each time)
      const dropN = 3 + Math.floor(Math.random() * 3); // 3..5
      for (let i=0;i<dropN;i++) {
        const ox = (i - (dropN-1)*0.5) * 26 + rand(-10, 10);
        const oy = rand(-55, 55);
        const cx = clamp(e.x + ox, 80, W - 80);
        const cy = clamp(e.y + oy, 80, H - 80);
        addCapsule(cx, cy);
      }

      midboss = null;
      if (started && !director.bossStarted) { try { playNormalBGM(900); } catch {} }
    }
    if (e === boss) {
      director.bossDead = true;
      boss = null;
      gameWin();
    }
  }
  killEnemy._turretDropsDone = 0;

  function hurtPlayer() {
    if (player.invuln > 0) return;

    if (player.shield > 0) {
      player.shield = 0;
      player.invuln = 1.0;
      sfx("hit");
      burstFX(player.x, player.y, 18, "boom");
      return;
    }

    lives -= 1;
    renderLivesUI();
    sfx("hit");
    burstFX(player.x, player.y, 26, "boom");

    if (lives <= 0) {
      gameOver();
      return;
    }

    respawn();
  }


  function resetPlayerFull() {
    // Full initialization on death (no carry-over).
    player.vx = 0; player.vy = 0;
    player.speedLevel = 0;
    player.missile = false;
    player.shotLevel = 0;
    player.hasLaser = false;
    player.options = 0;
    player.shield = 0;
    player.fireCD = 0;
    player.missileCD = 0;
    player.alive = true;
    player.laserOn = false;
    player.laserSfx = 0;
    player.optionLaserOn = 0;
    player.trail.length = 0;
    for (let i=0;i<2;i++) { optionPos[i].x = player.x; optionPos[i].y = player.y; }

    // Reset power-up gauge selection
    gaugeProgress = -1;
    gaugeReady = false;
    renderGaugeUI();

    // Clear player projectiles
    for (const s of shots) { s.active = false; }
    for (const m of missiles) { m.active = false; }
  }

  function respawn() {
    player.invuln = 1.5;
    player.x = 220;
    player.y = H/2;
    player.trail.length = 0;
    for (let i=0;i<2;i++) { optionPos[i].x = player.x; optionPos[i].y = player.y; }

        resetPlayerFull();

    for (const b of enemyShots) { b.active = false; }
    for (const e of enemies) {
      if (e.active && e.x < 520) e.active = false;
    }

    const ct = checkpointTimes[checkpoint];
    stageTimeAbs = ct;
    stageTime = 0;

    resyncSchedules(ct);

    maybeInitTerrainForSection._cDone = false;
    maybeInitTerrainForSection._eDone = false;

    setSectionFromTime(stageTimeAbs);
    maybeInitTerrainForSection();

    setCheckpointLabel();
  }

  function resyncSchedules(t) {
    sched.A1 = Math.max(sched.A1, t);
    sched.A2 = Math.max(sched.A2, t);
    sched.B1 = Math.max(sched.B1, t);
    sched.B2 = Math.max(sched.B2, t);
    sched.Cslime = Math.max(sched.Cslime, t);
    sched.D1 = Math.max(sched.D1, t);
    sched.D2 = Math.max(sched.D2, t);
    sched.E1 = Math.max(sched.E1, t);
    sched.E2 = Math.max(sched.E2, t);
    sched.E3 = Math.max(sched.E3, t);
    sched.OutWarn = Math.max(sched.OutWarn, t);

    if (t < 280) director.midbossStarted = false, director.midbossDead = false, midboss = null;
    if (t < 370) director.bossStarted = false, director.bossDead = false, boss = null;
  }

  function updateCheckpoint(tAbs) {
    if (tAbs >= checkpointTimes.C && checkpoint === "A") checkpoint = "C";
    if (tAbs >= checkpointTimes.M && (checkpoint === "A" || checkpoint === "C")) checkpoint = "M";
    if (tAbs >= checkpointTimes.B && checkpoint !== "B") checkpoint = "B";
    setCheckpointLabel();
  }

  function resolveCombat(worldOffsetX) {
    for (const s of shots) {
      if (!s.active) continue;
      for (const e of enemies) {
        if (!e.active) continue;
        if (e.x < -60 || e.x > W+80) continue;

        const er = (e.ai==="boss") ? 150 : (e.ai==="midboss" ? 120 : e.r);
        const tmp = {x:e.x, y:e.y, r:er};
        if (circleHit(s, tmp)) {
          s.active = false;
          if (e.ai === "midboss") {
            if (e.p >= 1) damageEnemy(e, s.dmg);
          } else if (e.ai === "boss") {
            if (e.p >= 1) damageEnemy(e, s.dmg);
            else damageEnemy(e, s.dmg*0.45); // turret phase: reduced damage
          } else {
            damageEnemy(e, s.dmg);
          }
          break;
        }
      }
    }

    for (const m of missiles) {
      if (!m.active) continue;
      for (const e of enemies) {
        if (!e.active) continue;
        const er = (e.ai==="boss") ? 150 : (e.ai==="midboss" ? 120 : e.r);
        const tmp = {x:e.x, y:e.y, r:er};
        if (circleHit(m, tmp)) {
          m.active = false;
          damageEnemy(e, m.dmg);
          for (const e2 of enemies) {
            if (!e2.active || e2===e) continue;
            const dx = e2.x - e.x, dy = e2.y - e.y;
            if (dx*dx + dy*dy < 70*70) damageEnemy(e2, m.dmg*0.5);
          }
          burstFX(m.x, m.y, 12, "boom");
          break;
        }
      }
    }
// Laser continuous damage (beam). Uses rectangle hit vs enemy circle.
// DPS tuning
const LASER_DPS = 26.0;
const OPTION_LASER_DPS = LASER_DPS * 0.70;

function circleRectHit(cx, cy, r, rx, ry, rw, rh) {
  const nx = clamp(cx, rx, rx+rw);
  const ny = clamp(cy, ry, ry+rh);
  const dx = cx - nx, dy = cy - ny;
  return (dx*dx + dy*dy) <= r*r;
}

function applyLaserDamageAt(y, dps) {
  const rx = player.x + 18;
  const ry = y - 7;          // beam thickness area
  const rw = (W + 40) - rx;
  const rh = 14;
  for (const e of enemies) {
    if (!e.active) continue;
    if (e.x < -60 || e.x > W+120) continue;

    const er = (e.ai==="boss") ? 150 : (e.ai==="midboss" ? 120 : e.r);
    if (!circleRectHit(e.x, e.y, er, rx, ry, rw, rh)) continue;

    // Phase gates same as projectile logic
    let mult = 1.0;
    if (e.ai === "midboss") {
      if (e.p < 1) continue;
    } else if (e.ai === "boss") {
      if (e.p < 1) mult = 0.45; // turret phase
    }
    damageEnemy(e, (dps * mult) * frameDT);
  }
}

if (player.laserOn) {
  applyLaserDamageAt(player.y, LASER_DPS);
  for (let i=0;i<player.optionLaserOn;i++) {
    applyLaserDamageAt(optionPos[i].y, OPTION_LASER_DPS);
  }
}



    if (player.invuln <= 0) {
      for (const b of enemyShots) {
        if (!b.active) continue;
        if (playerHitCircle(b)) {
          b.active = false;
          hurtPlayer();
          break;
        }
      }
    }

    if (player.invuln <= 0) {
      for (const e of enemies) {
        if (!e.active) continue;
        const er = (e.ai==="boss") ? 140 : (e.ai==="midboss" ? 110 : e.r);
        const tmp = {x:e.x, y:e.y, r:er};
        const pc = {x:player.x, y:player.y, r:18};
        if (circleHit(tmp, pc)) {
          hurtPlayer();
          break;
        }
      }
    }

    if (terrain.length > 0) {
      for (const b of enemyShots) {
        if (!b.active) continue;
        const wx = b.x + worldOffsetX;
        const idx = clamp(Math.floor(wx/32), 0, terrainHint.length-1);
        const h = terrainHint[idx];
        if (!h) continue;
        if (b.y < h.ceilY + 10 || b.y > h.floorY - 10) b.active = false;
      }
      for (const s of shots) {
        if (!s.active) continue;
        const wx = s.x + worldOffsetX;
        const idx = clamp(Math.floor(wx/32), 0, terrainHint.length-1);
        const h = terrainHint[idx];
        if (!h) continue;
        if (s.y < h.ceilY + 10 || s.y > h.floorY - 10) s.active = false;
      }
    }

    for (const c of capsules) {
      if (!c.active) continue;
      const tmp = {x:c.x, y:c.y, r:12};
      const pc = {x:player.x, y:player.y, r:18};
      if (circleHit(tmp, pc)) {
        c.active = false;
        addGaugeStep();
        sfx("power");
      }
    }
  }

  let outcrop = {active:false, x:W+80, y: H*0.5, w: 120, h: 280, t:0, warnedAt:0};
  function updateOutcrop(dt, tAbs) {
    if (director.warnOutcrop && !outcrop.active) {
      const t0 = directorUpdate._outcropT;
      if (tAbs > t0 + 2.8) {
        outcrop.active = true;
        outcrop.x = W + 140;
        outcrop.y = H*0.5;
        outcrop.w = 150;
        outcrop.h = 320;
        outcrop.t = 0;
      }
    }
    if (outcrop.active) {
      outcrop.t += dt;
      const k = clamp(outcrop.t / 1.2, 0, 1);
      outcrop.x = lerp(W+140, W-80, Math.sin(k*Math.PI)); // in then out
      if (player.invuln <= 0) {
        const rx = outcrop.x - outcrop.w/2;
        const ry = outcrop.y - outcrop.h/2;
        if (rectOverlap(player.x-player.hx, player.y-player.hy, player.hx*2, player.hy*2, rx, ry, outcrop.w, outcrop.h)) {
          hurtPlayer();
        }
      }
      if (outcrop.t > 1.2) outcrop.active = false;
    }
  }

  function drawOutcrop() {
    if (!director.warnOutcrop) return;
    const tAbs = stageTimeAbs;
    const t0 = directorUpdate._outcropT;
    if (tAbs < t0 + 2.5) {
      const blink = (Math.floor((tAbs-t0)*8)%2===0);
      ctx.fillStyle = blink ? "rgba(255,75,75,0.9)" : "rgba(255,75,75,0.35)";
      ctx.fillRect(W-30, 20, 14, 14);
      ctx.strokeStyle = "rgba(231,236,255,0.2)";
      ctx.strokeRect(W-32, 18, 18, 18);
    }
    if (outcrop.active) {
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      const rx = outcrop.x - outcrop.w/2;
      const ry = outcrop.y - outcrop.h/2;
      ctx.fillRect(rx, ry, outcrop.w, outcrop.h);
      ctx.strokeStyle = "rgba(231,236,255,0.16)";
      ctx.strokeRect(rx, ry, outcrop.w, outcrop.h);
    }
  }

  function resetGame() {
    score = 0; lives = 3;
    checkpoint = "A";
    section = "A";
    stageTime = 0;
    stageTimeAbs = 0;
    stageTimeGlobal = 0;
    progressMaxAbs = 0;
    updateProgressUI();
    stageTimeGlobal = 0;
    progressMaxAbs = 0;
    updateProgressUI();
    worldX = 0;

    player.x = 220; player.y = H/2;
    player.invuln = 1.2;
    player.speedLevel = 0;
    player.missile = false;
    player.shotLevel = 0;
    player.hasLaser = false;
    player.options = 0;
    player.shield = 0;
    player.fireCD = 0;
    player.missileCD = 0;
    player.trail.length = 0;

    shots.length = 0; enemyShots.length = 0; missiles.length = 0;
    enemies.length = 0; capsules.length = 0; fx.length = 0;
    clearTerrain();

    director = { midbossStarted:false, midbossDead:false, bossStarted:false, bossDead:false, warnOutcrop:false, pMidIdx:0, pMidActive:false };
    directorUpdate._A2Placed = false;
    directorUpdate._Ccap1 = false;
    killEnemy._turretDropsDone = 0;

    sched.A1 = 0; sched.A2 = 8;
    sched.B1 = 70; sched.B2 = 78;
    sched.Cslime = 152;
    sched.D1 = 226; sched.D2 = 238;
    sched.E1 = 312; sched.E2 = 320; sched.E3 = 332;
    sched.OutWarn = 252;

    outcrop.active = false;

    resetGauge();

    elScore.textContent = "0";
    renderGaugeUI();
    renderLivesUI();
    setCheckpointLabel();
  }

  function togglePause() {
    if (!started) return;
    paused = !paused;
    if (paused) {
      pauseBGM(true);
      elOverlay.classList.remove("hidden");
      elOverlay.querySelector("h1").textContent = "ポーズ中";
      elOverlay.querySelector("p").textContent = "Escで再開します。";
      elStart.textContent = "再開";
      elStart.style.display = "inline-block";
      elHow.style.display = "none";
      elHowTxt.style.display = "none";
    } else {
      elOverlay.classList.add("hidden");
      pauseBGM(false);
    }
  }

  function gameOver() {
    stopAllBGM();
    started = false;
    paused = false;
    elOverlay.classList.remove("hidden");
    elOverlay.querySelector("h1").textContent = "ゲームオーバー";

    const msg = `Score: <b>${score}</b><br/>Press <span class="kbd">R</span> to restart.`;
    if (elOverlayP1) elOverlayP1.innerHTML = msg;
    else elOverlay.querySelector("p").innerHTML = msg;

    if (elOverlayP2) elOverlayP2.style.display = "none";
    elStart.textContent = "リスタート";
    elStart.style.display = "inline-block";
    elHow.style.display = "none";
    elHowTxt.style.display = "none";

    // show latest leaderboard on overlay
    lbRefresh(10);
  }

  function gameWin() {
    stopAllBGM();
    started = false;
    paused = false;
    elOverlay.classList.remove("hidden");
    elOverlay.querySelector("h1").textContent = "ステージクリア";

    const msg = `Score: <b>${score}</b><br/>ステージ1クリア。<span class="kbd">R</span>でリスタート。`;
    if (elOverlayP1) elOverlayP1.innerHTML = msg;
    else elOverlay.querySelector("p").innerHTML = msg;

    if (elOverlayP2) elOverlayP2.style.display = "none";
    elStart.textContent = "リスタート";
    elStart.style.display = "inline-block";
    elHow.style.display = "none";
    elHowTxt.style.display = "none";

    // Clear: if TOP10 qualifies, prompt name & submit; always show TOP10
    lbHandleClear(score);
  }

  window.addEventListener("keydown", (e) => {
    if (e.code === "KeyR" && !started) {
      unlockAudio();
      ensureAudio();
      resetGame();
      started = true;
      elOverlay.classList.add("hidden");
      playNormalBGM();
    }
  });

  const fixed = 1/60;
  let acc = 0;
  let last = performance.now();

  function step(now) {
    const dtReal = Math.min(0.05, (now - last) / 1000);
    last = now;

    fpsAcc += dtReal; fpsFrames++;
    if (fpsAcc >= 0.5) {
      fps = Math.round(fpsFrames / fpsAcc);
      elFPS.textContent = String(fps);
      fpsAcc = 0; fpsFrames = 0;
    }

    if (started && !paused) {
      acc += dtReal;
      while (acc >= fixed) {
        update(fixed);
        acc -= fixed;
      }
      render();
    } else {
      render();
    }

    requestAnimationFrame(step);
  }

  function update(dt) {
    frameDT = dt;
    stageTime += dt;
    stageTimeAbs += dt * SCROLL_SCALE;
    stageTimeGlobal += dt * SCROLL_SCALE;
    progressMaxAbs = stageTimeGlobal;
    updateProgressUI();

    const sp = scrollSpeed + (player.speedLevel*18);
    worldX += (sp * SCROLL_SCALE) * dt;

    updateCheckpoint(stageTimeAbs);
    directorUpdate(stageTimeAbs, dt);

    if (bossIntro && bossIntro.active) {
      bossIntro.t += dt;
      bossIntro.flash = Math.max(0, bossIntro.flash - dt*1.6);
      if (bossIntro.t >= bossIntro.dur) bossIntro.active = false;
    }

    updateOutcrop(dt, stageTimeAbs);

    updatePlayer(dt, worldX);
    updateEnemies(dt, stageTimeAbs);
    updateBullets(dt, worldX);
    resolveCombat(worldX);


  }

  function render() {
    drawBackground(stageTimeAbs);
    drawTerrain(worldX);

    drawOutcrop();

    drawOptions();
    drawPlayer();

    drawEnemies();
    drawShots();
    drawCapsules();
    drawFX();

    // Boss intro overlay (WARNING + flashes)
    if (bossIntro && bossIntro.active) {
      const p = bossIntro.t / bossIntro.dur;
      const a = clamp(1.0 - p, 0.0, 1.0);
      // flash bars
      const flash = clamp(bossIntro.flash, 0.0, 1.0);
      if (flash > 0.01) {
        ctx.fillStyle = "rgba(255,60,60," + (0.18*flash) + ")";
        for (let i=0;i<12;i++) {
          const yy = i * (H/12);
          if ((i + Math.floor(stageTimeAbs*6)) % 2 === 0) ctx.fillRect(0, yy, W, H/12);
        }
      }
      // center text
      ctx.save();
      ctx.globalAlpha = 0.25 + 0.65*a;
      ctx.fillStyle = "rgba(255,80,80,1.0)";
      ctx.font = "900 64px system-ui, sans-serif";
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText("WARNING", W*0.5, H*0.45);
      ctx.font = "900 22px system-ui, sans-serif";
      ctx.fillText("BOSS INCOMING", W*0.5, H*0.56);
      ctx.restore();
    }

    ctx.fillStyle = "rgba(231,236,255,0.10)";
    ctx.font = "700 18px system-ui, sans-serif";
    ctx.fillText(section, 18, H-18);
  }

  elStart.addEventListener("click", () => {
  // Robust start handler: even if audio/BGM fails, the game must start.
  try {
    unlockAudio();
    const p = ensureAudio();
    // If ensureAudio returns a Promise in some versions, don't block start.
    if (p && typeof p.then === "function") { /* ignore */ }
  } catch (err) {
    console.error("ensureAudio failed:", err);
  }

  try {
    if (!started) {
      resetGame();
      started = true;
      paused = false;
      elOverlay.classList.add("hidden");
    } else {
      paused = false;
      elOverlay.classList.add("hidden");
    }
  } catch (err) {
    console.error("start/reset failed:", err);
  }

  // Start/Resume BGM (optional)
  try {
    if (director && director.bossStarted && !director.bossDead) {
      playBossBGM(450);
    } else if (midboss) {
      playMidbossBGM(450);
    } else {
      playNormalBGM(450);
    }
  } catch (err) {
    console.error("BGM start failed:", err);
  }
});

renderGaugeUI();
  renderLivesUI();
  setCheckpointLabel();

  requestAnimationFrame(step);
})();
</script>
</body>
</html>
